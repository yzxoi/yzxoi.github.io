<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF587D Duff in Mafia</title>
      <link href="/2022/06/24/cf587d-duff-in-mafia/"/>
      <url>/2022/06/24/cf587d-duff-in-mafia/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/problemset/problem/587/D">CF587D</a></p></blockquote><p>给定一张 $n$ 个点 $m$ 条边的无向图，每条边有一个颜色 $c$ 和权值 $t$。</p><p>你要选出一些边，使得它们是一个<strong>匹配</strong>，同时剩下的边每种颜色也是一个<strong>匹配</strong>。</p><p>同时，你要最小化选出的边的最大权值。</p><p>$n,m \le 5 \times 10^4$。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>考虑二分一个最大权值 $x$，2-SAT 判断合法性，对于边 $i$ 建两点 $x_i,x_i’$，表示选&#x2F;不选。显然连边有 $3$ 种情况：</p><ul><li>对于权值 $t_i &gt; x$ 的边 $i$ 有 $x_i \rightarrow x_i’$，表示该边不能选。</li><li>对于每个点 $k$，其相连的边有 $x_1,x_2,\cdots,x_o$，则所有 $x_i\rightarrow x_j’(i\not &#x3D; j)$，表示选了一条边则与其相连的边都不能再选。</li><li>对于每个点 $k$，其相连的且<strong>颜色相同</strong>的边有 $x_1,x_2,\cdots,x_o$，则所有 $x_i’\rightarrow x_j(i\not &#x3D; j)$，表示选出一条边则其他与其相连的同颜色的边都必选并成为一个匹配。</li></ul><p>发现后面两类边的总边数是 $O(M^2)$ 的，但每次都是由一个点向其他除了该点的一类点连边，可以使用前缀和优化。</p><p>具体地，记 $s_i$ 表示前缀 $1,2,\cdots,i$ 点的代表点，记 $t_i$ 表示后缀 $i,i+1,\cdots,o$ 点的代表点，每次只需要向前后缀连边即可。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tp template<span class="string">&lt;typename Ty&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ts template<span class="string">&lt;typename Ty,typename... Ar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W while</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RI register int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cn const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CI Cn int&amp;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gc getchar</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D isdigit(c=gc())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pc(c) putchar((c))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Debug&#123;</span><br><span class="line">Tp I <span class="type">void</span> _debug(Cn <span class="type">char</span>* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I <span class="type">void</span> _debug(Cn <span class="type">char</span>* f,Ty x,Ar... y)&#123;<span class="built_in">W</span>(*f!=<span class="string">&#x27;,&#x27;</span>) cerr&lt;&lt;*f++;cerr&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>;_debug(f+<span class="number">1</span>,y...);&#125;</span><br><span class="line">Tp ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;<span class="string">&quot;[&quot;</span>;<span class="keyword">for</span>(Cn <span class="keyword">auto</span>&amp; vv:V) os&lt;&lt;vv&lt;&lt;<span class="string">&quot;,&quot;</span>;os&lt;&lt;<span class="string">&quot;]&quot;</span>;<span class="keyword">return</span> os;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span></span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> Debug;</span><br><span class="line"><span class="keyword">namespace</span> FastIO&#123;</span><br><span class="line"><span class="function">Tp I <span class="type">void</span> <span class="title">read</span><span class="params">(Ty&amp; x)</span></span>&#123;<span class="type">char</span> c;<span class="type">int</span> f=<span class="number">1</span>;x=<span class="number">0</span>;<span class="built_in">W</span>(!D) f=c^<span class="string">&#x27;-&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>;<span class="built_in">W</span>(x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c&amp;<span class="number">15</span>),D);x*=f;&#125;</span><br><span class="line"><span class="function">Ts I <span class="type">void</span> <span class="title">read</span><span class="params">(Ty&amp; x,Ar&amp;... y)</span></span>&#123;<span class="built_in">read</span>(x),<span class="built_in">read</span>(y...);&#125;</span><br><span class="line"><span class="function">Tp I <span class="type">void</span> <span class="title">write</span><span class="params">(Ty x)</span></span>&#123;x&lt;<span class="number">0</span>&amp;&amp;(<span class="built_in">pc</span>(<span class="string">&#x27;-&#x27;</span>),x=-x,<span class="number">0</span>),x&lt;<span class="number">10</span>?(<span class="built_in">pc</span>(x+<span class="string">&#x27;0&#x27;</span>),<span class="number">0</span>):(<span class="built_in">write</span>(x/<span class="number">10</span>),<span class="built_in">pc</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>),<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function">Tp I <span class="type">void</span> <span class="title">writeln</span><span class="params">(Cn Ty&amp; x)</span></span>&#123;<span class="built_in">write</span>(x),<span class="built_in">pc</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">Cn <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,M=N*<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt,dfn[M],stk[M],low[M],col[M],cc,top,nc;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,c,t;&#125;a[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vi vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line">vi v[N],A,e[M];</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">LK</span><span class="params">(CI o)</span></span>&#123;</span><br><span class="line">RI F=<span class="number">-1</span>,T;<span class="keyword">for</span>(<span class="keyword">auto</span> i:A)&#123;</span><br><span class="line">RI f=++cnt,t=++cnt;e[o?i:i+m].<span class="built_in">pb</span>(f),e[t].<span class="built_in">pb</span>(o?i+m:i);</span><br><span class="line">~F&amp;&amp;(e[F].<span class="built_in">pb</span>(f),e[t].<span class="built_in">pb</span>(T),e[F].<span class="built_in">pb</span>(o?i+m:i),e[o?i:i+m].<span class="built_in">pb</span>(T),<span class="number">0</span>);F=f,T=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">Tarjan</span><span class="params">(CI x)</span></span>&#123;</span><br><span class="line">stk[++top]=x,dfn[x]=low[x]=++nc;<span class="keyword">for</span>(<span class="keyword">auto</span> i:e[x]) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">Tarjan</span>(i),low[x]=<span class="built_in">min</span>(low[x],low[i]);<span class="keyword">else</span> <span class="keyword">if</span>(!col[i]) low[x]=<span class="built_in">min</span>(low[x],dfn[i]);</span><br><span class="line"><span class="keyword">if</span>(dfn[x]==low[x])&#123;col[x]=++cc;<span class="built_in">W</span>(stk[top]^x) col[stk[top--]]=cc;top--;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="type">void</span> <span class="title">Cl</span><span class="params">(CI x)</span></span>&#123;RI i;<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) a[i].t&gt;x&amp;&amp;(<span class="built_in">assert</span>(e[i].<span class="built_in">back</span>()==i+m),e[i].<span class="built_in">pop_back</span>(),<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function">I <span class="type">bool</span> <span class="title">chk</span><span class="params">(CI x)</span></span>&#123;</span><br><span class="line">RI i;<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) a[i].t&gt;x&amp;&amp;(e[i].<span class="built_in">pb</span>(i+m),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(top=nc=cc=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;=cnt;i++) dfn[i]=col[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=cnt;i++) !dfn[i]&amp;&amp;(<span class="built_in">Tarjan</span>(i),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(col[i]==col[i+m]) <span class="keyword">return</span> <span class="built_in">Cl</span>(x),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Cl</span>(x),<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">RI i,l=<span class="number">0</span>,r=<span class="number">0</span>,mid;<span class="keyword">for</span>(<span class="built_in">read</span>(n,m),cnt=m&lt;&lt;<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">read</span>(a[i].u,a[i].v,a[i].c,a[i].t),r=<span class="built_in">max</span>(r,a[i].t),v[a[i].u].<span class="built_in">pb</span>(i),v[a[i].v].<span class="built_in">pb</span>(i);<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),[&amp;](CI x,CI y)&#123;<span class="keyword">return</span> a[x].c&lt;a[y].c;&#125;),A.<span class="built_in">clear</span>(),A=v[i],<span class="built_in">LK</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(RI tl=<span class="number">0</span>,tr=<span class="number">0</span>;tl&lt;v[i].<span class="built_in">size</span>();<span class="built_in">LK</span>(<span class="number">0</span>),tl=++tr)&#123;A.<span class="built_in">clear</span>(),A.<span class="built_in">pb</span>(v[i][tl]);<span class="built_in">W</span>(tr+<span class="number">1</span>&lt;v[i].<span class="built_in">size</span>()&amp;&amp;a[v[i][tr+<span class="number">1</span>]].c==a[v[i][tr]].c) A.<span class="built_in">pb</span>(v[i][++tr]);&#125;</span><br><span class="line">&#125;<span class="keyword">if</span>(!<span class="built_in">chk</span>(r)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>),<span class="number">0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);<span class="built_in">W</span>(l&lt;r) <span class="built_in">chk</span>(mid=l+r&gt;&gt;<span class="number">1</span>)?r=mid:l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">write</span>(l),<span class="built_in">pc</span>(<span class="string">&#x27; &#x27;</span>),<span class="built_in">chk</span>(l),A.<span class="built_in">clear</span>(),i=<span class="number">1</span>;i&lt;=m;i++) col[i]&lt;col[i+m]&amp;&amp;(A.<span class="built_in">pb</span>(i),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">writeln</span>(A.<span class="built_in">size</span>());<span class="keyword">for</span>(<span class="keyword">auto</span> i:A) <span class="built_in">write</span>(i),<span class="built_in">pc</span>(<span class="string">&#x27; &#x27;</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1364E X-OR</title>
      <link href="/2022/06/08/cf1364e-x-or/"/>
      <url>/2022/06/08/cf1364e-x-or/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/contest/1364/problem/E">CF1364E</a></p></blockquote><p>有一个固定的长度为 $n$ 的排列 $P$，其值域为 $[0,n-1]$，你可以进行不超过 $4269$ 次询问，之后你需要输出这个排列 $P$​。</p><p>你可以按照 <code>? a b</code> 的格式进行询问，之后你会得到 $P_a$ 与 $P_b$ 的按位或。</p><p>保证 $3\le n\le 2048$，$0\le P_i\le n-1$。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>首先发现如果找到 $0$ 的位置，其他的全部问一遍就都出来了，因此转化为如何找 $0$。</p><p>不妨先随机两个位置 $x,y$，再枚举其他所有 $i$：</p><ul><li>$P_x P_y &gt; P_y P_i$：$P_x$ 必然非 $0$，因此用 $i$ 代替 $x$ 继续循环。</li><li>$P_xP_y &#x3D; P_yP_i$：$P_y$ 必然非 $0$，因此用 $i$ 代替 $y$ 继续循环。</li><li>$P_xP_y &lt;P_yP_i$：$P_i$ 必然非 $0$，因此不换。</li></ul><p>那么最后肯定剩下 $x,y$，其中一个必为 $0$。</p><p>于是我们可以再随机一个数 $i$：</p><ul><li>$P_x P_i &gt; P_yP_i$：$P_x$ 必然非 $0$，因此 $P_y&#x3D;0$。</li><li>$P_xP_i &lt; P_yP_i$：$P_y$ 必然非 $0$，因此 $P_x&#x3D;0$。</li><li>$P_xP_i &#x3D; P_yP_i$：分辨不出来啥再重新随一个:(</li></ul><hr><p>简单分析一下询问次数：</p><p>首先第一部分找到两个中必有 $0$ 的一对数字，扫了一次所有的点，而其中第二种情况需要多询问一次新的 $P_xP_i$的值（为下次循环做准备），而产生第二种情况的充要条件是 $P_x \&amp; P_y &#x3D; P_x,P_i\&amp; P_y &#x3D; P_i$，其概率可以估计为 $\sum_{i&#x3D;1}^n\frac 1{n^3} 2^{2\operatorname{popcount}(i)}\approx 0.0056843422353267669677734375$，可以看出这是非常小的。</p><p>因此这部分的询问次数大约为 $0.0056843422353267669677734375\times 2048+2048\approx 2059$。</p><p>其次第二部分随到第三种情况的概率：$\sum_{i&#x3D;1}^n \frac 1{n^2}2^{\operatorname{popcount}(i)}\approx 0.04223537445068359375$。</p><p>不妨设其期望次数为 $f$，则有 $f&#x3D;0.04223537445068359375\times (f+1) +(1-0.04223537445068359375)\times 1$</p><p>因此 $f&#x3D;1.0441$。</p><p>所以总询问次数期望为：$2059+1+2048&#x3D;4108$，远远小于 $4269$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e5+10;</span><br><span class="line">int n,Ans[N];</span><br><span class="line">I int Q(CI x,CI y)&#123;</span><br><span class="line">    RI t;cout&lt;&lt;&quot;? &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;t;return t;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mt19937 mt(time(nullptr));</span><br><span class="line">    RI i,x,y,v,t,q1,q2,p0;read(n);x=mt()%n+1,y=mt()%n+1;W(x==y) y=mt()%n+1;</span><br><span class="line">    for(v=Q(x,y),i=1;i&lt;=n;i++) if(i^x&amp;&amp;i^y)&#123;</span><br><span class="line">        if(v&gt;(t=Q(y,i))) x=i,v=t;</span><br><span class="line">        else if(v==t) y=i,v=Q(x,y);</span><br><span class="line">    &#125;do&#123;</span><br><span class="line">    t=mt()%n+1;W(t==xt==y) t=mt()%n+1;</span><br><span class="line">    if((q1=Q(x,t))&gt;(q2=Q(y,t))) p0=y;else if(q1&lt;q2) p0=x;&#125;while(!p0);</span><br><span class="line">    for(i=1;i&lt;=n;i++) Ans[i]=i==p0?0:Q(p0,i);</span><br><span class="line">    for(cout&lt;&lt;&quot;! &quot;,i=1;i&lt;=n;i++) cout&lt;&lt;Ans[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交互 </tag>
            
            <tag> 概率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF708E Student&#39;s Camp</title>
      <link href="/2022/06/07/cf708e-students-camp/"/>
      <url>/2022/06/07/cf708e-students-camp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/contest/708/problem/E">CF708E</a></p></blockquote><p>有一个 $(n+2) \times m$ 的网格。</p><p>除了第一行和最后一行，其他每一行每一天最左边和最右边的格子都有 $p$ 的概率消失。</p><p>求 $k$ 天后，网格始终保持连通的概率。</p><p>$n,m \le 1.5 \times 10^3$，$k \le 10^5$，答案对 $10^9+7$ 取模。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>不妨设 $f_{i,l,r}$ 表示进行到第 $i$ 行，剩 $[l,r]$ 的格子的概率，有：<br>$$<br>f_{i,l,r} &#x3D; p_{l,r} \sum_{l_p,r_p} f_{i-1,l_p,r_p} [[l_p,r_p]\cap [l,r] \not &#x3D; \emptyset]<br>$$<br>其中 $p_{l,r}$ 表示一行打到只剩 $[l,r]$ 的概率，有：<br>$$<br>\begin{align}<br>&amp;p_{l,r} &#x3D; P_{l-1}P_{m-r}\\<br>&amp;P_{i}&#x3D;\binom ki p^i(1-p)^{k-i}<br>\end{align}<br>$$<br>直接转移是 $O(nm^4)$，显然不行，考虑优化。</p><p>由于限制的是区间交集问题，我们不妨设 $Fl_{i,j}$，$Fr_{i,j}$，$Sl_{i,j}$，$Sr_{i,j}$ 表示各个前缀和，即：<br>$$<br>\begin{align}<br>&amp;Fl_{i,l}&#x3D;\sum_{r\ge l} f_{i,l,r}\\<br>&amp;Fr_{i,r}&#x3D;\sum_{l\leq r} f_{i,l,r}\\<br>&amp;Sl_{i,L}&#x3D;\sum_{l,r\ge L} f_{i,l,r} &#x3D; \sum_{l\ge L} Fl_{i,l}\\<br>&amp;Sr_{i,R}&#x3D;\sum_{l,r\leq R} f_{i,l,r}&#x3D;\sum_{r\leq R} Fr_{i,r}<br>\end{align}<br>$$<br>由于对称性，容易发现：<br>$$<br>Fl_{i,j}&#x3D;Fr_{i,m+1-j}\\<br>Sl_{i,j}&#x3D;Sr_{i,m+1-j}<br>$$<br>考虑转移 $Fr_{i,j}$：<br>$$<br>\begin{align}<br>Fr_{i,r}&amp; &#x3D;\sum_{l\leq r} p_{l,r}\sum_{l_p,r_p}f_{i-1,l_p,r_p}\\<br>&amp; &#x3D; \sum_{l\leq r} p_{l,r} (Sr_{i-1,m}-Sr_{i-1,l-1}-Sl_{i-1,r+1})\\<br>&amp; &#x3D; \sum_{l\leq} P_{l-1}P_{m-r}(Sr_{i-1,m}-Sr_{i-1,l-1}-Sr_{i-1,m-r})\\<br>&amp; &#x3D; P_{m-r} ((Sr_{i-1,m}-Sr_{i-1,m-r})\sum_{l\leq r}P_{l-1})-P_{m-r}\sum_{l\leq r}P_{l-1}Sr_{i-1,l-1}<br>\end{align}<br>$$<br>发现，设 $G_r&#x3D;\sum_{l\leq r}P_{l-1}$，$H_r&#x3D;\sum_{l\leq r}P_{l-1}Sr_{i-1,l-1}$，于是转移就能 $O(nm)$ 求解啦。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1.5e3+10,X=1e9+7,K=1e5+10;</span><br><span class="line">int n,m,p,k,P[N],fac[K],ifac[K],G[N],Sr[N][N],Fr[N][N],H[N];</span><br><span class="line">I int QP(RI a,RI b)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%X),a=1LL*a*a%X,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I int C(CI n,CI m)&#123;return 1LL*fac[n]*ifac[m]%X*ifac[n-m]%X;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,x,y;for(read(n,m,x,y,k),p=1LL*x*QP(y,X-2)%X,fac[0]=i=1;i&lt;=k;i++) fac[i]=1LL*fac[i-1]*i%X;</span><br><span class="line">    for(ifac[k]=QP(fac[k],X-2),i=k-1;~i;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%X;</span><br><span class="line">    for(i=0;i&lt;=min(m,k);i++) P[i]=1LL*C(k,i)*QP(p,i)%X*QP(1-p,k-i)%X;</span><br><span class="line">    for(i=1;i&lt;=m;i++) G[i]=(G[i-1]+P[i-1])%X;</span><br><span class="line">    for(Fr[0][m]=Sr[0][m]=1,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(j=1;j&lt;=m;j++) H[j]=(H[j-1]+1LL*P[j-1]*Sr[i-1][j-1]%X)%X;</span><br><span class="line">        for(j=1;j&lt;=m;j++) Fr[i][j]=(1LL*P[m-j]*(Sr[i-1][m]-Sr[i-1][m-j])%X*G[j]%X-1LL*P[m-j]*H[j]%X)%X;</span><br><span class="line">        for(j=1;j&lt;=m;j++) Sr[i][j]=(Sr[i][j-1]+Fr[i][j])%X;</span><br><span class="line">    &#125;return writeln((Sr[n][m]+X)%X),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 概率 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF536D Tavas in Kansas</title>
      <link href="/2022/06/07/cf536d-tavas-in-kansas/"/>
      <url>/2022/06/07/cf536d-tavas-in-kansas/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/problemset/problem/536/D">CF536D</a></p></blockquote><ul><li>给定一张 $n$ 个点 $m$ 条边的可能有自环和重边的无向连通图，每条边都有一个非负边权。</li><li>小 X 和小 Y 在这张图上玩一个游戏，在游戏中，第 $i$ 个城市有一个权值 $p_i$。</li><li>一开始，小 X 在城市 $s$ 中，小 Y 在城市 $t$ 中，两人各有一个得分，初始为 $0$，小 X 为先手，然后轮流进行操作。</li><li>当轮到某一个人时，他必须选择一个非负整数 $x$，以选定所有与他所在的城市的最短距离不超过 $x$ 的还未被选定过的城市，他的得分将会加上这些城市的权值。</li><li>另外，每个人每次必须能够至少选定一个城市。</li><li>当没有人可以选择时，游戏结束，得分高者获胜。</li><li>现在请你计算出，在两人都使用最佳策略的情况下，谁会获胜（或者判断为平局）。</li><li>$n \le 2 \times 10^3$，$m \le 10^5$，$p_i \le 10^9$。 <img src="https://espresso.codeforces.com/1d24e4eb9a90bfeb2317cb6a6df97c56da66ddd6.png"></li></ul><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>首先从 $s,t$ 分别跑一次最短路，容易发现答案仅与其相对大小有关，因此先离散化。</p><p>容易将其抽象成一个表格，其中第 $i$ 号点位于 $(d_{s,i},d_{t,i})$，权值为 $p_i$，两人分别从 上&#x2F;左 取若干 行&#x2F;列。</p><p>注意到 $n\leq 2\times 10^3$，考虑 dp，设 $f_{k,i,j}$ 表示在各自最优策略下当前小 X&#x2F;小 Y 先手，剩余的点为 $(i,j)$ 及其右下角范围，小 X 的权值与小 Y 的权值的差。</p><p>发现其实没必要枚举每个人取到哪一行&#x2F;列进行转移，只需要一行行一列列转移时注意是否要交给对方即可。<br>$$<br>\begin{align}<br>&amp;f_{0,i,j}\leftarrow \max { f_{0,i+1,j} , f_{1,i+1,j}}+S(i,j,i,c_1) \quad [\exists p\in [i,j,i,c_1]]\\<br>&amp;f_{1,i,j}\leftarrow \min { f_{0,i,j+1} , f_{1,i,j+1}}-S_{i,j,c_0,j} \quad[\exists p\in [i,j,c_0,j]]<br>\end{align}<br>$$<br>$O(N^2)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e3+10,M=1e5+10;</span><br><span class="line">int n,m,s[2],a[N],vis[N],fir[N],nxt[M&lt;&lt;1],son[M&lt;&lt;1],w[M&lt;&lt;1],tot,cnt,c[2],sz[N][N];</span><br><span class="line">LL sum[N][N],b[N],dp[2][N][N],F[2][N];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I void Spfa()&#123;</span><br><span class="line">    RI u,i,j;for(memset(vis,0,sizeof(vis)),memset(F,63,sizeof(F)),j=0;j&lt;2;j++)&#123;</span><br><span class="line">        W(!q.empty()) q.pop();F[j][s[j]]=0,q.push(s[j]);W(!q.empty())</span><br><span class="line">        for(vis[u=q.front()]=0,q.pop(),i=fir[u];i;i=nxt[i]) F[j][to]&gt;F[j][u]+w[i]&amp;&amp;(F[j][to]=F[j][u]+w[i],!vis[to]&amp;&amp;(q.push(to),vis[to]=1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I int Sz(CI i1,CI j1,CI i2,CI j2)&#123;return sz[i2][j2]-sz[i1-1][j2]-sz[i2][j1-1]+sz[i1-1][j1-1];&#125;</span><br><span class="line">I LL Sum(CI i1,CI j1,CI i2,CI j2)&#123;return sum[i2][j2]-sum[i1-1][j2]-sum[i2][j1-1]+sum[i1-1][j1-1];&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,x,y,z;for(read(n,m,s[0],s[1]),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(x,y,z),Add(x,y,z),Add(y,x,z);</span><br><span class="line">    for(Spfa(),k=0;k&lt;2;k++)&#123;</span><br><span class="line">        for(cnt=0,i=1;i&lt;=n;i++) b[++cnt]=F[k][i];</span><br><span class="line">        for(sort(b+1,b+cnt+1),c[k]=cnt=unique(b+1,b+cnt+1)-b-1,i=1;i&lt;=n;i++) F[k][i]=lower_bound(b+1,b+cnt+1,F[k][i])-b;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++) sum[F[0][i]][F[1][i]]+=a[i],sz[F[0][i]][F[1][i]]++;</span><br><span class="line">    for(i=1;i&lt;=c[0];i++) for(j=1;j&lt;=c[1];j++) sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1],sz[i][j]+=sz[i-1][j]+sz[i][j-1]-sz[i-1][j-1];</span><br><span class="line">    for(i=c[0];i;i--) for(j=c[1];j;j--)&#123;</span><br><span class="line">        if(Sz(i,j,i,c[1])) dp[0][i][j]=max(dp[0][i+1][j],dp[1][i+1][j])+Sum(i,j,i,c[1]);</span><br><span class="line">        else dp[0][i][j]=dp[0][i+1][j];</span><br><span class="line">        if(Sz(i,j,c[0],j)) dp[1][i][j]=min(dp[0][i][j+1],dp[1][i][j+1])-Sum(i,j,c[0],j);</span><br><span class="line">        else dp[1][i][j]=dp[1][i][j+1];</span><br><span class="line">    &#125;</span><br><span class="line">    return puts(dp[0][1][1]&gt;0?&quot;Break a heart&quot;:dp[0][1][1]&lt;0?&quot;Cry&quot;:&quot;Flowers&quot;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6274 [eJOI2017]六</title>
      <link href="/2022/06/07/p6274-ejoi2017%E5%85%AD/"/>
      <url>/2022/06/07/p6274-ejoi2017%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P6274">P6274</a> <a href="http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/six_statement-en.pdf">eJOI 2017 Problem B Six</a></p></blockquote><p>Elly 正在研究关于 正整数 $N$ 的一些性质，发现 $N$ 有不多于 $6$ 个不同的质因数。</p><p>接下来，她以一种特定的方式来生成的一个列表，一开始列表为空。她先写下了 $N$ 的一个大于一的因数 $x$ ，加入列表前，她先要确保 在所有已经在列表中的数中， 不能有 <strong>超过</strong> $1$ <strong>个</strong> 数与 $x$ <strong>不互质</strong>。</p><hr><p>举个例子，当 $N&#x3D;12156144$ 时：</p><p>合法的列表有： $ (42), (616, 6, 91, 23),(91, 616, 6, 23), (66, 7), (66, 7, 7, 23, 299, 66), \(143, 13, 66),(42,12156144),\text{etc.} $</p><p>而不合法的有：之一是 $(5,11)$，原因是 $5$ 不是 $N$ 的因子；还有一个是 $ (66, 13, 143)$ ，原因是 $143$ 与其他两个数都不互质。</p><hr><p>现在 Elly 希望你计算出给定的 $N$，可以生成几个不同的合法的列表。答案对 $10^9+7$ 取模。</p><p><strong>若两个列表长度不同，或存在一个位置使得两个列表的该位置的值不同，那么我们说这两个列表不同的</strong>。</p><p>对于所有数据，保证 $1\le N\le 10^{15}$，$N$ 至多有 $6$ 个质因数。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>考虑如何转换 <code>不能有超过 $1$ 个数与 $x$ 不互质</code> 的限制。</p><p>注意到 $N$ 至多只有 $6$ 个质因数，因此如果对所有数质因数分解，将会只有至多 $6$ 个状态（有&#x2F;无该因子），将其压起来设为状态 $S$，判断是否互质即等价于判断其 $S$ 的按位与是否非 $0$。</p><p>考虑使用一个三进制来表示状态，可以先预处理出所有状态对应的方案数 $O(2^MM)$。</p><p>每个状态包含 $i$ 类数的数量以及与其不互质的数的个数。转移的话直接枚举 $j$ 类数即可转移。</p><p>看上去状态数很多，实际上很少，因此可过（（</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int M=7,X=1e9+7,N=1e7+10;</span><br><span class="line">LL n,p[M];</span><br><span class="line">int f[1&lt;&lt;M],c[M],cnt,g[N],Ans;</span><br><span class="line">map&lt;__int128,int&gt; mp;</span><br><span class="line">I int DFS(__int128 x)&#123;</span><br><span class="line">    if(mp.count(x)) return mp[x];</span><br><span class="line">    RI i,j,k,S=1,o;for(i=1;i&lt;(1&lt;&lt;cnt);i++) if((k=(x&gt;&gt;(i&lt;&lt;1))&amp;3)&lt;2)&#123;</span><br><span class="line">        __int128 t=x;for(j=0;j&lt;(1&lt;&lt;cnt);j++) i&amp;j&amp;&amp;(x&gt;&gt;(j&lt;&lt;1)&amp;3)&lt;2&amp;&amp;(x+=((__int128)1&lt;&lt;(j&lt;&lt;1)),0);</span><br><span class="line">        if(!f[i]) for(f[i]=1,j=1;j&lt;=cnt;j++) i&gt;&gt;j-1&amp;1&amp;&amp;(f[i]=1LL*f[i]*c[j]%X);</span><br><span class="line">        S=(1LL*DFS(x)*f[i]%X+S)%X,x=t;</span><br><span class="line">    &#125;return mp[x]=S;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    LL i;for(read(n),i=2;i*i&lt;=n;i++) if(!(n%i))&#123;</span><br><span class="line">        p[++cnt]=i;W(!(n%i)) n/=i,++c[cnt];</span><br><span class="line">    &#125;n&gt;1&amp;&amp;(p[++cnt]=n,c[cnt]=1);</span><br><span class="line">    return writeln(DFS(0)-1),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压 </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> 质因数分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HHHOJ 2022.05.29「NOIP模拟赛 贰」</title>
      <link href="/2022/06/04/hhhoj-2022-05-29%E3%80%8Cnoip%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%B4%B0%E3%80%8D/"/>
      <url>/2022/06/04/hhhoj-2022-05-29%E3%80%8Cnoip%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E8%B4%B0%E3%80%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="比赛概况"><a href="#比赛概况" class="headerlink" title="比赛概况"></a>比赛概况</h2><p>100+50+100&#x3D;250，2&#x2F;16，t2 RE怒丢50pts</p><h2 id="A-Median"><a href="#A-Median" class="headerlink" title="A. Median"></a>A. Median</h2><p>定义两个数列，$S &#x3D; {S(1), S(2), …, S(n)}$ 和 $S_2 &#x3D; {S_2(1), S_2(2), …, S_2(n)}$</p><p>$$S(k) &#x3D; (p_k\times k) \bmod w,\text{where } p_k \text{ is the kth prime number}$$</p><p>$$S_2(k) &#x3D; S(k) + S(\lfloor\frac{k}{10}\rfloor + 1)$$</p><p>令 $M(i,j)$ 表示 $S_2(i)$ 到 $S_2(j)$ 的中位数。</p><p>现在给定 $n,k$，求 $$\sum_{i&#x3D;1}^{n-k+1} M(i, i + k - 1)$$</p><p>$w\leq k\leq n \leq 10^7$</p><h3 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h3><p>乍一看感觉比较神秘？仔细想一想应该是随机分布的，由于中位数每次移动只会移两位，所以暴力跳就好了。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e7+10,M=1.8e8;</span><br><span class="line">int n,k,w,s2[N],p[N],cnt,t[N&lt;&lt;1],HL,DL,HR,DR;bool vis[M];</span><br><span class="line">LL Ans;</span><br><span class="line">I void GP()&#123;RI i,j;for(i=2;cnt&lt;=n;i++) for(!vis[i]&amp;&amp;(p[++cnt]=i),j=1;j&lt;=cnt&amp;&amp;1LL*i*p[j]&lt;M;j++) if(vis[i*p[j]]=1,!(i%p[j])) break ;&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">#define s(i) (1LL*p[i]*(i)%w) </span><br><span class="line">RI i,l,r,mid,X;for(read(n,k,w),GP(),gdb(cnt,p[cnt]),i=1;i&lt;=n;i++) s2[i]=s(i)+s(i/10+1);</span><br><span class="line">for(i=1;i&lt;k;i++) t[s2[i]]++;for(HL=HR=-1,i=k;i&lt;=n;i++)&#123;</span><br><span class="line">t[s2[i]]++,s2[i]&lt;=HL&amp;&amp;++DL,s2[i]&lt;=HR&amp;&amp;++DR;</span><br><span class="line">W(DL&lt;k/2) DL+=t[++HL];W(DL-t[HL]&gt;=k/2) DL-=t[HL--];</span><br><span class="line">W(DR&lt;k/2+1) DR+=t[++HR];W(DR-t[HR]&gt;=k/2+1) DR-=t[HR--];</span><br><span class="line">Ans+=k&amp;1?HR&lt;&lt;1:(HL+HR);</span><br><span class="line">t[s2[i-k+1]]--,s2[i-k+1]&lt;=HL&amp;&amp;--DL,s2[i-k+1]&lt;=HR&amp;&amp;--DR;</span><br><span class="line">&#125;return printf(&quot;%.1lf\n&quot;,Ans/2.0),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Game"><a href="#B-Game" class="headerlink" title="B. Game"></a>B. Game</h2><p>Alice和Bob又在玩游戏。</p><p>现在有一个长为 $n$ 的正整数序列 $a_i$ ，其中的数字小于等于 $n$，且相同的数字可能出现多次。</p><p>游戏最先，他们把序列的前 $p$ 个元素放入一个<strong>可重集</strong> $S$，接下来两人轮流操作，一次操作包括：</p><ul><li>当前操作者从集合中拿出一个数，计入自己的得分。</li><li>将序列中下一个数放入集合，也就是说，第一次操作后，$a_{p+1}$会被放入集合，以此类推。如果没有剩余的未放入的数，即不放入任何数。</li></ul><p>Alice先手，她想知道，如果两人都采取最优策略让自己的得分最大，假设 Alice 最终分数为 $A$，Bob 最终分数为 $B$，则 $A-B$ 的值将会是多少。</p><p>他们进行了很多次游戏，每次游戏序列 $a_i$ 是相同的，只是给出不同的 $p$。</p><p>$n\leq 100000,k\leq 2000,1\leq a_i\leq n,1\leq p_i\leq n,k\leq n$</p><h3 id="Tutorial-1"><a href="#Tutorial-1" class="headerlink" title="Tutorial"></a>Tutorial</h3><p>显然只需要每次取最大的，开个权值数组记录每个数出现的次数，一个指针指向这个数组中最大的出现过的数，这个指针是会不断的变小的，因为如果新加入的数更大，就会直接被拿走。</p><p>所以时间复杂度是 $O(kn)$。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,K=2e3+10;</span><br><span class="line">int n,Qk,a[N],t[N];LL Ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,p,o,mx;for(read(n,Qk),i=1;i&lt;=n;i++) read(a[i]);for(i=1;i&lt;=Qk;i++)&#123;</span><br><span class="line">for(read(p),mx=Ans=0,o=1,j=1;j&lt;p;j++) t[a[j]]++,mx=max(mx,a[j]);for(j=1;j&lt;=n;o^=1,j++)&#123;</span><br><span class="line">W(!t[mx]) --mx;if(j+p-1&lt;=n&amp;&amp;a[j+p-1]&gt;mx) Ans+=(o&amp;1?1:-1)*a[j+p-1];else Ans+=(o&amp;1?1:-1)*mx,--t[mx],j+p-1&lt;=n&amp;&amp;++t[a[j+p-1]];</span><br><span class="line">&#125;writeln(Ans);</span><br><span class="line">&#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Park"><a href="#C-Park" class="headerlink" title="C. Park"></a>C. Park</h2><p>公园里有 $n$ 个雕像，有 $n-1$ 条道路分别连接其中两个雕像，使得任意两个雕像可以相连。</p><p>现在每个景点 $i$ 聚集着一群 $p_i$ 只鸽子，旅行家手里有 $v$ 数量的面包屑。</p><p>一旦旅行家在雕像 $i$ 撒下 $1$ 单位面包屑，那么 <strong>相邻</strong> 的雕像的鸽子就都会飞到雕像 $i$ 来觅食。</p><p>时间线是这样的：首先，旅行家到达雕像 $i$ 并与 $p_i$ 鸽子会面。然后，他放下 $1$ 单位面包屑。他离开雕像。在旅行家到达下一座雕像之前，来自相邻雕像的鸽子移动到雕像 $i$（所以这些鸽子 <strong>不计入</strong> 他遇到的鸽子数）。<strong>注意</strong>旅行家每到达雕像可以撒下面包屑，也可以不撒。</p><p>旅行家可以在任何一座雕像上进入公园，沿着一些道路走下去（但不要使用同一道路两次），然后离开公园。</p><p>在旅行家离开公园后，没有面包屑的小学生将进入并穿越完全相同的路线，并遇见许多群鸽子。</p><p>通过最多 $v$ 单位面包屑，旅行家希望最大化旅行家在路线上遇到的鸽子数量与小学生遇到的鸽子数量之间的差异。</p><p>$1\leq n\leq 10^5,0\leq v\leq 100,0\leq p_i\leq 10^9$</p><h3 id="Tutorial-2"><a href="#Tutorial-2" class="headerlink" title="Tutorial"></a>Tutorial</h3><p>记录两个数组 $c_{i,j},d_{i,j}$ 分别表示从子树$i$ 中某个点走到 $i$ 或 从$i$ 走到子树中某个点，撒了 $j$ 的最大收益</p><p>注意对一个子树遍历的相对顺序会影响贡献，所以得扫两次。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=110;</span><br><span class="line">int n,a[N],v0,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot;</span><br><span class="line">LL c[N],Ans,up[N][M],dn[N][M];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">#define pb push_back</span><br><span class="line">I void DFS(CI x,CI fa)&#123;</span><br><span class="line">#define G(x,y) ((x&lt;(y))&amp;&amp;(x=(y)))</span><br><span class="line">RI i,rd;for(i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(DFS(to,x),0);</span><br><span class="line">for(v.clear(),i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(v.pb(to),0);</span><br><span class="line">for(rd=1;rd&lt;=2;rd++,reverse(v.begin(),v.end()))&#123;</span><br><span class="line">for(i=1;i&lt;=v0;i++) up[x][i]=c[x],dn[x][i]=c[x]-a[fa];</span><br><span class="line">for(auto y:v)&#123;</span><br><span class="line">for(i=1;i&lt;=v0;i++) Ans=max(Ans,up[x][i]+dn[y][v0-i]);</span><br><span class="line">for(i=1;i&lt;=v0;i++) G(up[x][i],up[y][i-1]+c[x]-a[y]),G(up[x][i],up[y][i]),G(dn[x][i],dn[y][i-1]+c[x]-a[fa]),G(dn[x][i],dn[y][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,x,y;for(read(n,v0),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">for(i=1;i&lt;n;i++) read(x,y),Add(x,y),Add(y,x);</span><br><span class="line">for(j=1;j&lt;=n;j++) for(i=fir[j];i;i=nxt[i]) c[j]+=a[to];</span><br><span class="line">return DFS(1,0),writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1648D Serious Business</title>
      <link href="/2022/03/17/cf1648d-serious-business/"/>
      <url>/2022/03/17/cf1648d-serious-business/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="http://codeforces.com/problemset/problem/1648/D">CF1648D</a></p></blockquote><p>给定一个 $3$ 行 $n$ 列的矩阵，每个位置有权值 $a_i,j$，初始时除第二行任意位置均不允许通过外第一行第三行均允许通过。</p><p>接下来有 $q$ 个操作，第 $i$ 个操作可使第二行的 $l_i\sim r_i$ 的位置可以通过，代价为 $k_i$。</p><p>你可以任意选择若干操作执行，需要最大化从 $(1,1)$ 走到 $(3,n)$ 的路径上的权值之和减去代价。</p><p>$n,q\leq 5\times 10^5$。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>记 $s_{i,j}&#x3D;\sum_{k&#x3D;1}^j s_{i,k}$，显然答案可以拆分为：<br>$$<br>\max_{1\leq i\leq j\leq n} s_{1,i} - s_{2,i-1} + s_{2,j} - s_{3,j-1} + s_{3,n} - \operatorname{cost}(i,j)<br>$$<br>考虑用线段树维护 $s_{1,i}-s_{2,i-1} - \operatorname{cost}(i,j)$（第一部分），$s_{2,j}-s_{3,j-1}+s_{3,n}$（第二部分），$Ans$（第一部分与第二部分之和）。</p><p>不妨将这 $q$ 个操作按照 $r$ 排序，那么考虑其影响，每次可以扣 $[l_i,r_i]$ 中的答案减去 $k_i$ 即可纳入答案，而该操作对之后的影响即为 $r_{i+1}$ 的第一部分的贡献可以变为 $[l_i,r_i]$ 的答案的第一部分。</p><p>时间复杂度：$O(q(\log q+\log n))$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e5+10;</span><br><span class="line">int n,q,a[4][N],Ans;</span><br><span class="line">struct Que&#123;int l,r,k;&#125;g[N];</span><br><span class="line">struct node&#123;int l,r,v;&#125;O;</span><br><span class="line">I node operator+(Cn node&amp; x,Cn node&amp; y)&#123;return (node)&#123;max(x.l,y.l),max(x.r,y.r),max(max(x.v,y.v),x.l+y.r)&#125;;&#125;</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        node T[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define PU(x) (T[x]=T[x&lt;&lt;1]+T[x&lt;&lt;11])</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x]=(node)&#123;a[1][l]-a[2][l-1],a[2][l]+a[3][n]-a[3][l-1],a[1][l]-a[2][l-1]+a[2][l]+a[3][n]-a[3][l-1]&#125;);</span><br><span class="line">            B(LT),B(RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return T[x].l=max(T[x].l,v),T[x].v=T[x].l+T[x].r,void();</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I node Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            if(R&lt;=mid) return Q(L,R,LT);if(L&gt;mid) return Q(L,R,RT);</span><br><span class="line">            return Q(L,R,LT)+Q(L,R,RT);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,j;for(read(n,q),i=1;i&lt;=3;i++) for(j=1;j&lt;=n;j++) read(a[i][j]),a[i][j]+=a[i][j-1];for(i=1;i&lt;=q;i++) read(g[i].l,g[i].r,g[i].k);</span><br><span class="line">    for(sort(g+1,g+q+1,[&amp;](Cn Que&amp; x,Cn Que&amp; y)&#123;return x.r&lt;y.r;&#125;),T.B(),Ans=-2e18,i=1;i&lt;=q;i++)</span><br><span class="line">        O=T.Q(g[i].l,g[i].r),Ans=max(Ans,O.v-g[i].k),g[i].r&lt;n&amp;&amp;(T.U(g[i].r+1,O.l-g[i].k),0);return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 864「扫描线」藏宝地图</title>
      <link href="/2022/02/14/ybtoj-864-%E3%80%8C%E6%89%AB%E6%8F%8F%E7%BA%BF%E3%80%8D%E8%97%8F%E5%AE%9D%E5%9C%B0%E5%9B%BE/"/>
      <url>/2022/02/14/ybtoj-864-%E3%80%8C%E6%89%AB%E6%8F%8F%E7%BA%BF%E3%80%8D%E8%97%8F%E5%AE%9D%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/864">YbtOJ #864</a></p></blockquote><p>小 A 有一张藏宝地图，可以视作一张 $10^6\times 10^6$ 的网格图，左上角为 $(1,1)$，右下角为 $(w,h)$。</p><p>地图中有 $k$ 个无交的矩形障碍框（障碍框在格边上）。</p><p>有 $n$ 个探险家和 $m$ 个宝藏，分别处于网格图中的某个格子内。</p><p>探险家每一步只能选择向右&#x2F;向下走或返回 <strong>初始</strong> 位置，且不能越过障碍框或走出地图边界。求每个探险家能找到的宝藏的数量。</p><p><img src="https://z3.ax1x.com/2021/12/01/oGi7hd.png"></p><p>$0\le n,m,k\le2\times10^5$，所有的坐标范围在 $[1,10^6]$ 范围内。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p><img src="https://s2.loli.net/2022/02/14/UmYj6MlkwVhFnd8.png"></p><p>一目了然，不言而明。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e5+10,M=1e6;</span><br><span class="line">int k,n,m,Ans[N],o[M+5];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define PPA pair&lt;PA,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;PPA&gt; v1[M+5],v2[M+5];</span><br><span class="line">vector&lt;PA&gt; v4[M+5];</span><br><span class="line">vector&lt;int&gt; v3[M+5]; </span><br><span class="line">#define pb push_back</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int T[(M&lt;&lt;2)+10],tg[(M&lt;&lt;2)+10];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=M</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x]=T[x&lt;&lt;1]+T[x&lt;&lt;11])</span><br><span class="line">        I void AP(CI x)&#123;T[x]=0,tg[x]=1;&#125;</span><br><span class="line">        I void PD(CI x)&#123;tg[x]&amp;&amp;(AP(x&lt;&lt;1),AP(x&lt;&lt;11),tg[x]=0);&#125;</span><br><span class="line">    public:</span><br><span class="line">        I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            RI X=0;return PD(x),L&lt;=mid&amp;&amp;(X+=Q(L,R,LT)),R&gt;mid&amp;&amp;(X+=Q(L,R,RT)),X;</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x]+=v);</span><br><span class="line">            PD(x),p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void A(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return AP(x);</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(A(L,R,LT),0),R&gt;mid&amp;&amp;(A(L,R,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">set&lt;int&gt; S;</span><br><span class="line">I int O(CI x)&#123;return *S.lower_bound(x);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;treasure.in&quot;,&quot;r&quot;,stdin),freopen(&quot;treasure.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x1,y1,x2,y2,t;for(read(k),i=1;i&lt;=k;i++) read(x1,y1,x2,y2),v1[y2].pb(MP(MP(x1,x2),i)),v2[y1-1].pb(MP(MP(x1,x2),i));</span><br><span class="line">    for(read(m),i=1;i&lt;=m;i++) read(x1,y1),v3[y1].pb(x1);for(read(n),i=1;i&lt;=n;i++) read(x1,y1),v4[y1].pb(MP(x1,i));</span><br><span class="line">    for(S.insert(M+1),i=M;i;i--)&#123;</span><br><span class="line">        for(auto j:v1[i]) t=T.Q(j.fi.fi,min(O(j.fi.fi),M)),o[j.se]=T.Q(j.fi.se+1,min(O(j.fi.se+1),M)),T.A(j.fi.fi,j.fi.se),j.fi.fi&gt;1&amp;&amp;(T.U(j.fi.fi-1,t),S.insert(j.fi.fi-1),0),S.insert(j.fi.se);</span><br><span class="line">        for(auto j:v2[i]) T.A(j.fi.fi,j.fi.se),j.fi.fi&gt;1&amp;&amp;(T.U(j.fi.fi-1,-o[j.se]),S.erase(j.fi.fi-1),0),S.erase(j.fi.se);</span><br><span class="line">        for(auto j:v3[i]) T.U(j,1);</span><br><span class="line">        for(auto j:v4[i]) Ans[j.se]=T.Q(j.fi,min(O(j.fi),M));</span><br><span class="line">    &#125;for(i=1;i&lt;=n;i++) writeln(Ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> set </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 634「左偏树」转移石子</title>
      <link href="/2022/02/14/ybtoj-634-%E3%80%8C%E5%B7%A6%E5%81%8F%E6%A0%91%E3%80%8D%E8%BD%AC%E7%A7%BB%E7%9F%B3%E5%AD%90/"/>
      <url>/2022/02/14/ybtoj-634-%E3%80%8C%E5%B7%A6%E5%81%8F%E6%A0%91%E3%80%8D%E8%BD%AC%E7%A7%BB%E7%9F%B3%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/634">YbtOJ #634</a></p></blockquote><p>小 A 有一棵 $n$ 个点的无根树，节点标号为 $1\sim n$。其中第 $i$ 条边长度为 $l_i$。</p><p>在标号为 $i$ 的点上原本有 $x_i$ 颗石子。</p><p>石子只能沿着树边转移，且对于一条边 $(u,v,l)$，将一颗石子从 $u$ 移到 $v$ 或从 $v$ 移到 $u$ 的代价都是 $l$。</p><p>小 A 希望在若干次转移之后使得标号为 $i$ 的点上至少有 $y_i$ 颗石子，求最小的转移代价。</p><p>$1\le n\le2.5\times10^5$，$\sum y_i\le\sum x_i\le10^6$，$1\leq l\leq 10^6$。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>显然一个点上原有的 $\min{x_i,y_i}$ 颗石子没有必要移动。</p><p>因此 $x_i &gt; y_i$ 的情况可以视作能够给出 $x_i-y_i$ 颗石子，$x_i &lt; y_i$ 的情况可以视作需要接收 $y_i-x_i$ 颗石子。</p><p>然后就可以暴力建图：</p><ul><li>从超级源向能够给出石子的点连边，容量为需要给出的石子数，费用为 $0$。</li><li>从需要接收石子的点向超级汇连边，容量为需要接收的石子数，费用为 $-INF$（这样使得接收石子的点肯定会接收满）。</li><li>从需要给出石子的点向需要接收石子的点之间连边，容量为 $INF$，费用为距离。</li></ul><p>然后考虑模拟费用流来优化。在每个点处理它不同子树间的流动。</p><p>假设有输出点 $x$ 和接收点 $y$，当前点（$\operatorname{LCA}$）为 $z$，它们之间的路径长度就是 $d_x+d_y-2d_z$，匹配费用就是 $d_x+d_y-2d_z-INF$。</p><p>由于当前点确定时 $-2d_z$ 为定值，因此规定输出点的权值 $A_x&#x3D;d_x$，接收点的权值 $B_y&#x3D;d_y-INF$，然后分别开一个小根堆，每次取出各自的堆顶尝试更新答案即可。（更新答案的条件：$A_x+B_y-2d_z &lt; 0$）</p><p>但我们还要考虑退流，如果我们想让输出点 $x$ 能换成和另一个接收点匹配，相当于新建一个权值为 $2d_z-B_y$ 的输出点 $x’$，这两个输出点权值相加刚好消得只剩 $A_x$，除去了原本的接收点的贡献。同理，想让接收点 $y$ 能换成和另一个输出点匹配，相当于新建一个权值为 $2d_z-A_x$ 的接收点 $y’$。</p><p>因为这里的堆需要合并，写个左偏树即可。</p><p>也就是反悔贪心。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2.5e5+10;Cn LL inf=1e13;</span><br><span class="line">int n,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],w[N&lt;&lt;1],tot;LL d[N],Ans;</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA a[N];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">class Tree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int cnt;struct node&#123;int l,r,d;LL v;&#125;T[N*40];</span><br><span class="line">    public:</span><br><span class="line">        int rt[N];</span><br><span class="line">        I int M(RI x,RI y)&#123;</span><br><span class="line">            if(!x!y) return x+y;if(T[x].v&gt;T[y].v) swap(x,y);</span><br><span class="line">            T[x].r=M(T[x].r,y);if(T[T[x].l].d&lt;T[T[x].r].d) swap(T[x].l,T[x].r);</span><br><span class="line">            return T[x].d=T[T[x].r].d+1,x;</span><br><span class="line">        &#125;</span><br><span class="line">        I void P(int&amp; x,LL v)&#123;T[++cnt]=(node)&#123;0,0,0,v&#125;,x=M(x,cnt);&#125;</span><br><span class="line">        I void O(int&amp; x)&#123;x=M(T[x].l,T[x].r);&#125;</span><br><span class="line">        I LL top(CI x)&#123;return T[rt[x]].v;&#125;</span><br><span class="line">        I void pop(CI x)&#123;O(rt[x]);&#125;</span><br><span class="line">&#125;p,q;</span><br><span class="line">I void DFS(CI x,CI fa)&#123;</span><br><span class="line">    W(a[x].se--) p.P(p.rt[x],d[x]);W(a[x].fi--) q.P(q.rt[x],d[x]-inf);</span><br><span class="line">    RI i;LL tp,tq,t;for(i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(d[to]=d[x]+w[i],DFS(to,x),p.rt[x]=p.M(p.rt[x],p.rt[to]),q.rt[x]=q.M(q.rt[x],q.rt[to]),0);</span><br><span class="line">    W(p.rt[x]&amp;&amp;q.rt[x]&amp;&amp;(t=(tp=p.top(x))+(tq=q.top(x))-2*d[x])&lt;0)</span><br><span class="line">        Ans+=t,p.pop(x),q.pop(x),p.P(p.rt[x],tp-t),q.P(q.rt[x],tq-t);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;rock.in&quot;,&quot;r&quot;,stdin),freopen(&quot;rock.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,y,z,X=0;for(read(n),i=1;i&lt;n;i++) read(x,y,z),Add(x,y,z),Add(y,x,z);</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(a[i].fi,a[i].se),x=min(a[i].fi,a[i].se),a[i].fi-=x,a[i].se-=x,X+=a[i].se;</span><br><span class="line">    return DFS(1,0),writeln(Ans+X*inf),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 反悔贪心 </tag>
            
            <tag> 左偏树 </tag>
            
            <tag> 模拟费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 824「计算几何初探」圆与连线</title>
      <link href="/2022/02/14/ybtoj-824-%E3%80%8C%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%8E%A2%E3%80%8D%E5%9C%86%E4%B8%8E%E8%BF%9E%E7%BA%BF/"/>
      <url>/2022/02/14/ybtoj-824-%E3%80%8C%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%8E%A2%E3%80%8D%E5%9C%86%E4%B8%8E%E8%BF%9E%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/824">YbtOJ #824</a></p></blockquote><p>小 A 有一个平面直角坐标系，其中有一个圆心在原点的半径为 $r$ 的圆（即它的方程为 $x^2+y^2&#x3D;r^2$）和 $n$ 个特殊点 $(x_i,y_i)$。</p><p>小 A 想知道最多能够留下多少个特殊点，满足任意两点连线不与圆相交。</p><p>$1\le n\le 2\times10^3$，$r,x_i,y_i\le5\times10^3$。</p><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><p>求出每个点与圆的两条切线，那么在这两条切线之间的其他点与该点的连线都会与圆相交，而切线外的点则不会。</p><p>实际上，我们把每个点与圆的两个切点看成一个区间（具体实现中，方便起见我们我们用 <strong>角度</strong> 来表示这个区间），那么点 $A$ 与其两条切线间的点 $B$，对应的区间必然包含（两点在圆的同侧）或是相离（两点在圆的异侧），也就是说两点连线无交当且仅当它们的区间是非包含关系的相交。</p><p>求角度的区间还是比较简单的，首先我们求出当前点的角度 $g$，然后求出当前点与圆心的连线和圆心向切线的垂线的夹角 $d$（$\cos d&#x3D;\frac{\sqrt{x^2+y^2}}{R}$），则 $[g-d,g+d]$ 就是对应的区间。（具体实现中最好把左右端点表示到 $[-\pi,\pi]$ 中，注意这里的区间包含或是相离是一样的，因此即使交换左右端点也没有关系。）</p><p>然后题意就被转化为在一个序列上选出若干个区间满足两两相交。</p><p>我们先将所有区间按左端点排序，不妨枚举最左边的区间，然后对之后所有满足与该区间相交的区间，按照右端点求一遍最长上升子序列，即可求出答案。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e3+10;Cn double pi=acos(-1);</span><br><span class="line">int n,r,Ans;</span><br><span class="line">#define PA pair&lt;double,double&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA a[N];double f[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;circle.in&quot;,&quot;r&quot;,stdin),freopen(&quot;circle.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,x,y,top;double ang,cir;for(read(n,r),i=1;i&lt;=n;i++) read(x,y),ang=atan2(y,x),cir=acos(1.0*r/sqrt(x*x+y*y)),(a[i].fi=ang-cir)&lt;-pi&amp;&amp;(a[i].fi+=2*pi),(a[i].se=ang+cir)&gt;pi&amp;&amp;(a[i].se-=2*pi),a[i].fi&gt;a[i].se&amp;&amp;(swap(a[i].fi,a[i].se),0);</span><br><span class="line">    for(sort(a+1,a+n+1),i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        f[top=0]=a[i].se;for(j=i+1;j&lt;=n;j++) if(a[j].fi&gt;a[i].se) break ;else if(a[j].se&gt;a[i].se) f[top]&lt;=a[j].se?f[++top]=a[j].se:*lower_bound(f+1,f+top+1,a[j].se)=a[j].se;Ans=max(Ans,top+1);</span><br><span class="line">    &#125;return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 915「欧拉函数」欧拉欧拉</title>
      <link href="/2022/02/13/ybtoj-915-%E3%80%8C%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E3%80%8D%E6%AC%A7%E6%8B%89%E6%AC%A7%E6%8B%89/"/>
      <url>/2022/02/13/ybtoj-915-%E3%80%8C%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E3%80%8D%E6%AC%A7%E6%8B%89%E6%AC%A7%E6%8B%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/915">YbtOJ #915</a></p></blockquote><p>小 A 有两个正整数 $n,k$。</p><p>规定一个正整数序列 $a$ 是合法的，当且仅当它的长度为 $k$，且序列中的每一个 $a_i$ 都小于等于 $n$。</p><p>由于小 A 特别喜欢欧拉，他定义一个序列 $a$ 的权值 $F(a)&#x3D;\phi(\operatorname{lcm}(a_1,a_2,\cdots,a_k))$。</p><p>现在，小 A 希望你求出 <strong>所有合法序列的权值之积</strong> 在模 $10^9+7$ 意义下的值。</p><p>$1\le n,k\le 10^6$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目即求：<br>$$<br>\prod_{i_1&#x3D;1}^n\prod_{i_2&#x3D;1}^n\cdots\prod_{i_n&#x3D;1}^n\phi(\operatorname{lcm}(i_1,i_2,\cdots,i_n))<br>$$<br>把欧拉函数拆开，不妨以每个质数 $p$ 考虑，不妨设 $\forall j\in [1,n],p^{c_j}i_j$，且 $c&#x3D;\max_{j&#x3D;1}^n c_j$。</p><p>显然有 $p^c\operatorname{lcm}$ 且 $p^{c+1}\operatorname{lcm}$。</p><p>我们又知道：<br>$$<br>\phi(p^c)&#x3D;(p-1)p^{c-1}<br>$$</p><ul><li>考虑 $(p-1)$ 的贡献，由于若 $\exists j\in [1,n], pi_j$，则该贡献就会被乘上，于是它的总贡献为：$(p-1)^{n^k-(n-\lfloor \frac np \rfloor)^k}$。</li><li>考虑 $p^{c-1}$ 的贡献，考虑暴枚 $c$，显然时间复杂度为 $\log$ 左右的，可以接受，总贡献为：$\prod_{j\ge 2\land p^j \leq n}p^{n^k-(n-\lfloor \frac n{p^j} \rfloor)^k}$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+10,mod=1e9+7;</span><br><span class="line">int n,k,Mul,p[N],cnt,v[N],Ans=1;</span><br><span class="line">I void Pre()&#123;RI i,j;for(i=2;i&lt;=n;i++) for(!v[i]&amp;&amp;(p[++cnt]=i),j=1;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;j++) if(v[i*p[j]]=1,!(i%p[j])) break ;&#125;</span><br><span class="line">I int QP(RI a,RI b,CI p)&#123;a%=p;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I int Phi(RI x)&#123;</span><br><span class="line">    RI i,X=x;for(i=2;i*i&lt;=x;i++) if(!(x%i))&#123;</span><br><span class="line">        X=X/i*(i-1);W(!(x%i)) x/=i; </span><br><span class="line">    &#125;x&gt;1&amp;&amp;(X=X/x*(x-1));return X;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    freopen(&quot;euler.in&quot;,&quot;r&quot;,stdin),freopen(&quot;euler.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,phi;for(read(n,k),Pre(),phi=Phi(mod),i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        Ans=1LL*Ans*QP(p[i]-1,(QP(n,k,phi)+phi-QP(n-(n/p[i]),k,phi))%phi,mod)%mod;</span><br><span class="line">        for(j=n/p[i]/p[i];j;j/=p[i]) Ans=1LL*Ans*QP(p[i],(QP(n,k,phi)+phi-QP(n-j,k,phi))%phi,mod)%mod;</span><br><span class="line">    &#125;return writeln(Ans),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 664「可持久化数据结构」进制路径</title>
      <link href="/2022/02/13/ybtoj-664-%E3%80%8C%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E8%BF%9B%E5%88%B6%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/02/13/ybtoj-664-%E3%80%8C%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E8%BF%9B%E5%88%B6%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/664">YbtOJ #664</a></p></blockquote><p>小 A 有一张 $n$ 个点 $m$ 条边的无向图。图中标号为 $i$ 的边可以用一个三元组 $(u_i,v_i,x_i)$ 表示，其中 $u_i,v_i$ 为它的两个端点，长度为 $2^{x_i}$。</p><p>现在他指定了图中的两个点 $s,t$，求 $s$ 到 $t$ 的最短路长度，并任意给出一条最短路径。</p><p>$1\le n\le10^5$，$0\le m\le10^5$，$0\le x_i\le10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这里的最短路和普通的最短路是一样的，唯一区别就是边权很大。则我们需要支持的操作就应该是大二进制数的加法和比大小。</p><p>我们对于每个点，开一个线段树，每一位维护二进制下这一位的值，表示其距离。</p><p>然后由于边权是 $2$ 的幂，所以也就相当于在二进制下某一位上加上 $1$。</p><p>如果要给第 $x$ 位加 $1$，就是要找到大于等于 $x$ 的最低的为 $0$ 的位（设其为 $t$），然后把 $x\sim t-1$ 这些位上改为 $0$，把第 $t$ 位改为 $1$。</p><p>而要求出大于等于第 $x$ 位的最低为 $0$ 的位，可以考虑二分。假设当前二分到 $mid$，那么若 $x\sim mid$ 间的 $1$ 的个数小于等于 $t-x$，就说明 $x\sim mid$ 之间存在至少一个 $0$，返回 true，否则返回 false。</p><p>接下来考虑如何比较两个大二进制数的大小。</p><p>可以从两棵线段树的根节点出发，由于比较的是最高位，所以若两个节点右儿子不同，就去比较右儿子；若两个节点右儿子相同，才去比较左儿子。而要快速判断两个右儿子是否一样，只要哈希一下就可以了。</p><p>具体实现中对于每个点开一棵线段树显然不现实，可以用主席树来优化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+100,p=1e9+7;</span><br><span class="line">int n,m,vis[N],Pr[N],fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],w[N&lt;&lt;1],tot,rt[N],b[N];</span><br><span class="line">class ChairmanTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int cnt;struct node&#123;int l,r,v,s;&#125;T[N*200];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define LT l,mid</span><br><span class="line">        #define RT mid+1,r</span><br><span class="line">        #define PT CI l=0,CI r=N-1</span><br><span class="line">        I void PU(CI x)&#123;T[x].s=T[T[x].l].s+T[T[x].r].s,T[x].v=(T[T[x].r].v+T[T[x].l].v)%p;&#125;</span><br><span class="line">    public:</span><br><span class="line">        I int S(CI p)&#123;return T[p].s;&#125; </span><br><span class="line">        I int Q(CI p)&#123;return T[p].v;&#125;;</span><br><span class="line">        I bool O(CI x,CI y,PT)&#123;if(l==r) return T[x].v&gt;T[y].v;return T[T[x].r].v==T[T[y].r].v?O(T[x].l,T[y].l,LT):O(T[x].r,T[y].r,RT);&#125;</span><br><span class="line">        I int QS(CI x,CI L,CI R,PT)&#123;if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].s;RI X=0;return L&lt;=mid&amp;&amp;(X+=QS(T[x].l,L,R,LT)),R&gt;mid&amp;&amp;(X+=QS(T[x].r,L,R,RT)),X;&#125;</span><br><span class="line">        I int F(CI x,CI v)&#123;RI l=v,r=N,X=v;W(l&lt;=r) QS(x,v,mid)&lt;=mid-v?X=mid,r=mid-1:l=mid+1;return X;&#125;</span><br><span class="line">        I void U0(int&amp; x,CI L,CI R,PT)&#123;if(T[++cnt]=T[x],x=cnt,L&lt;=l&amp;&amp;r&lt;=R) return void(x=0);L&lt;=mid&amp;&amp;(U0(T[x].l,L,R,LT),0),R&gt;mid&amp;&amp;(U0(T[x].r,L,R,RT),0),PU(x);&#125;</span><br><span class="line">        I void U1(int&amp; x,CI p,PT)&#123;if(T[++cnt]=T[x],x=cnt,l==r) return T[x].s=1,(void)(T[x].v=b[l]);p&lt;=mid?U1(T[x].l,p,LT):U1(T[x].r,p,RT),PU(x);&#125;</span><br><span class="line">        I int A(CI x,CI v)&#123;RI t=F(x,v),w=x;v^t&amp;&amp;(U0(w,v,t-1),0);U1(w,t);return w;&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">struct node&#123;int x,rt;&#125;u;</span><br><span class="line">I bool operator &lt; (Cn node&amp; A,Cn node&amp; B)&#123;return T.O(A.rt,B.rt);&#125;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">int s,t;I void Prt(CI x,CI d)&#123;x==s?writeln(d),write(x),pc(&#x27; &#x27;):(Prt(Pr[x],d+1),write(x),pc(&#x27; &#x27;));&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;base.in&quot;,&quot;r&quot;,stdin),freopen(&quot;base.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,y,z;for(read(n,m,s,t),i=1;i&lt;=m;i++) read(x,y,z),Add(x,y,z),Add(y,x,z);for(b[0]=i=1;i&lt;N;++i) b[i]=(1ll*b[i-1]&lt;&lt;1)%p;</span><br><span class="line">    q.push((node)&#123;s,rt[s]&#125;);W(!q.empty()) if(u=q.top(),q.pop(),!vis[u.x])</span><br><span class="line">        for(vis[u.x]=1,u.x==t&amp;&amp;(writeln(T.Q(rt[t])),Prt(t,1),pc(&#x27;\n&#x27;),clear(),exit(0),0),i=fir[u.x];i;i=nxt[i])</span><br><span class="line">            x=T.A(u.rt,w[i]),(!rt[to]T.O(rt[to],x))&amp;&amp;(q.push((node)&#123;to,rt[to]=x&#125;),Pr[to]=u.x);</span><br><span class="line">    return writeln(-1),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 494「斜率优化 dp」最小划分</title>
      <link href="/2022/02/13/ybtoj-494-%E3%80%8C%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-dp%E3%80%8D%E6%9C%80%E5%B0%8F%E5%88%92%E5%88%86/"/>
      <url>/2022/02/13/ybtoj-494-%E3%80%8C%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96-dp%E3%80%8D%E6%9C%80%E5%B0%8F%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/494">YbtOJ #494</a></p></blockquote><p>小 A 有一个长度为 $n$ 的序列 $a$，要求你把它划分成 $m$ 个连续段（记 $w_i$ 表示 <strong>第 $i$ 段的数之和</strong>）。</p><p>他还给定了一个参数 $p$，希望你求出 $\sum_{i&#x3D;1}^m(w_i+p)^2$ 的最小值。</p><p>$2\le m\le n\le10^5$，$1\le a_i,p\le10^3$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先拆平方，得到 $\sum_{i&#x3D;1}^m(w_i^2+2\cdot w_i\cdot p+p^2)&#x3D;\sum_{i&#x3D;1}^mw_i^2+(2p\sum_{i&#x3D;1}^na_i+mp^2)$。</p><p>后面两项是定值，也就是说只要最小化 $\sum_{i&#x3D;1}^mw_i^2$。</p><p>发现可以 WQS 二分，二分一个额外代价 $C$，然后每次转移 $f$ 的时候附加上一个 $C$，并记录 $g$ 表示最优解划分的段数。那么只要找到一个最小的 $C$ 使得 $g_n$ 小于等于 $m$ 就可以了。</p><p>先列出暴力的转移方程：（$s$表示$a$的前缀和）</p><p>$$<br>f_i&#x3D;f_j+(s_i-s_j)^2+C<br>$$</p><p>把右边的项拆开并且只保留和 $j$ 有关的项得到：</p><p>$$<br>f_j+s_j^2-2s_i\times s_j<br>$$</p><p>所以一个转移点 $j$ 优于 $k$（$j &gt; k$）的充要条件就是：</p><p>$$<br>f_j+s_j^2-2s_i\times s_j &lt; f_k+s_k^2-2s_i\times s_k\<br>(f_j+s_j^2)-(f_k+s_k^2) &lt; 2s_i\times(s_j-s_k)<br>$$</p><p>由于 $s_j-s_k$ 显然为正，因此就有：</p><p>$$<br>s_i &gt; \frac{(f_j+s_j^2)-(f_k+s_k^2)}{2(s_j-s_k)}<br>$$</p><p>那么我们只要维护一个单调队列，然后就可以轻松斜率优化了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,m,p,a[N],q[N],h,t;</span><br><span class="line">LL s[N],f[N],g[N];</span><br><span class="line">I bool chk(LL C)&#123;</span><br><span class="line">    auto A=[&amp;](CI x)-&gt;LL&#123;return f[x]+s[x]*s[x];&#125;;</span><br><span class="line">    #define S(x,y) (0.5*(A(y)-A(x))/(s[y]-s[x]))</span><br><span class="line">    RI i;for(q[h=t=1]=0,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        W(h&lt;t&amp;&amp;S(q[h],q[h+1])&lt;s[i]) ++h;</span><br><span class="line">        f[i]=f[q[h]]+1LL*(s[i]-s[q[h]])*(s[i]-s[q[h]])+C,g[i]=g[q[h]]+1;</span><br><span class="line">        W(h&lt;t&amp;&amp;S(q[t-1],q[t])&gt;S(q[t],i)) --t;q[++t]=i;</span><br><span class="line">    &#125;return g[n]&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;divide.in&quot;,&quot;r&quot;,stdin),freopen(&quot;divide.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i;for(read(n,m,p),i=1;i&lt;=n;i++) read(a[i]),s[i]=s[i-1]+a[i];</span><br><span class="line">    LL l=0,r=1e18,mid;W(l&lt;r) chk(mid=l+r&gt;&gt;1)?r=mid:l=mid+1;</span><br><span class="line">    return chk(l),writeln(f[n]+2*s[n]*p-l*m+1LL*p*p*m),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化dp </tag>
            
            <tag> WQS二分 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 971「fwt」猜拳游戏</title>
      <link href="/2022/02/12/ybtoj-971-%E3%80%8Cfwt%E3%80%8D%E7%8C%9C%E6%8B%B3%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/02/12/ybtoj-971-%E3%80%8Cfwt%E3%80%8D%E7%8C%9C%E6%8B%B3%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/971">YbtOJ #971</a></p></blockquote><p>有 $n&#x3D;3^m$ 个人（标号为 $0\sim n-1$）在玩猜拳。共有 $t$ 轮游戏，每轮游戏都会进行 $m$ 次猜拳。</p><p>把每个人的标号转化为一个三进制数，则标号为 $x$ 的人在每轮的第 $i$ 次都会使出 $x$ 从低到高第 $i$ 位数对应的手势（$0$ 对应剪刀，$1$ 对应石头，$2$ 对应布）。</p><p>小 A 设定了一个评分数组 $a_{u,v}$，记第 $i$ 轮结束后 $x$ 的分数为 $f_{i,x}$，则第 $i+1$ 轮过后 $x$ 的分数会变成 $f_{i+1,x}&#x3D;\sum_{y&#x3D;0}^{n-1}f_{i,y}\times a_{Win(x,y),Lose(x,y)}$，其中 $Win(x,y)$ 和 $Lose(x,y)$ 分别表示 $x$ 对 $y$ 赢和输的次数。</p><p>现给定所有人初始的分数，小 A 想要知道最终所有人的分数。（答案向给定 $P$ 取模）</p><p>$1\le m\le12$，$0\le t\le10^9$，$1\le P\le10^9+7$ 且保证 $P$ 不为 $3$ 的倍数，初始分数和评分数组中的值都在 $[0,P)$ 范围内。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>石头剪刀布本质即为三进制计算，考虑三进制异或。</p><p>显然两位选手的操作的三进制不退位减法的结果分别对应 平-$0$，赢-$1$，输-$2$。</p><p>所以可以处理出序列 $A$，满足 $A_i&#x3D;a[\text{popcount}_1(i)][\text{popcount}_2(i)]$。</p><p>那么与 $f_0$ 做 $t$ 次三进制异或卷积即可。</p><p>发现 $\omega_3$ 不好处理，所以可以扩域整个代数单位代替。</p><p>根据单位根的性质，注意到 $\omega_3^2+\omega_3+1&#x3D;0$，那么有 $\omega_3^2&#x3D;-\omega_3-1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=531450,M=13;</span><br><span class="line">int n,m,t,P,a[M][M];</span><br><span class="line">I int C(RI x,CI v)&#123;RI i,X=0;for(i=0;i&lt;m;i++) X+=(x%3==v),x/=3;return X;&#125;</span><br><span class="line">struct node&#123;int x,y;I node(CI a=0,CI b=0):x(a),y(b)&#123;&#125;&#125;;</span><br><span class="line">I node operator+(Cn node&amp; X,Cn node&amp; Y)&#123;return (node)&#123;(X.x+Y.x)%P,(X.y+Y.y)%P&#125;;&#125;</span><br><span class="line">I node operator-(Cn node&amp; X,Cn node&amp; Y)&#123;return (node)&#123;(X.x+P-Y.x)%P,(X.y+P-Y.y)%P&#125;;&#125;</span><br><span class="line">I node operator*(Cn node&amp; X,Cn node&amp; Y)&#123;RI o=P-1LL*X.y*Y.y%P;return (node)&#123;(1LL*X.x*Y.x+o)%P,(1LL*X.x*Y.y+1LL*X.y*Y.x+o)%P&#125;;&#125;</span><br><span class="line">struct FWT&#123;node f[N];&#125;S,A;</span><br><span class="line">I node QP(node a,RI b)&#123;node s=(node)&#123;1,0&#125;;W(b) b&amp;1&amp;&amp;(s=s*a,0),a=a*a,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I void exgcd(CI a,CI b,int&amp; x,int&amp; y)&#123;if(!b) return x=1,y=0,void();exgcd(b,a%b,y,x),y-=a/b*x;&#125;</span><br><span class="line">I void AFWT(FWT&amp; s)&#123;</span><br><span class="line">    RI i,j,k;node x,y,z;for(i=1;i^n;i*=3) for(j=0;j^n;j+=i*3) for(k=0;k^i;++k)</span><br><span class="line">        x=s.f[j+k],y=s.f[i+j+k],z=s.f[2*i+j+k],s.f[j+k]=x+y+z,s.f[i+j+k]=x+y*(node)&#123;0,1&#125;+z*(node)&#123;P-1,P-1&#125;,s.f[2*i+j+k]=x+y*(node)&#123;P-1,P-1&#125;+z*(node)&#123;0,1&#125;;</span><br><span class="line">&#125;</span><br><span class="line">I void UFWT(FWT&amp; s)&#123;</span><br><span class="line">    RI i,j,k;node x,y,z;for(i=1;i^n;i*=3) for(j=0;j^n;j+=i*3) for(k=0;k^i;++k)</span><br><span class="line">        x=s.f[j+k],y=s.f[i+j+k],z=s.f[2*i+j+k],s.f[j+k]=x+y+z,s.f[i+j+k]=x+y*(node)&#123;P-1,P-1&#125;+z*(node)&#123;0,1&#125;,s.f[2*i+j+k]=x+y*(node)&#123;0,1&#125;+z*(node)&#123;P-1,P-1&#125;;</span><br><span class="line">    RI a,b;for(exgcd(n,P,a,b),a=(a%P+P)%P,i=0;i^n;++i) s.f[i].x=1LL*s.f[i].x*a%P;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;guess.in&quot;,&quot;r&quot;,stdin),freopen(&quot;guess.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j;for(read(m,t,P),n=pow(3,m),i=0;i&lt;n;i++) read(S.f[i].x);for(i=0;i&lt;=m;i++) for(j=0;j&lt;=m-i;j++) read(a[i][j]);</span><br><span class="line">    for(i=0;i&lt;n;i++) A.f[i].x=a[C(i,1)][C(i,2)];</span><br><span class="line">    for(AFWT(S),AFWT(A),i=0;i&lt;n;i++) S.f[i]=S.f[i]*QP(A.f[i],t);</span><br><span class="line">    for(UFWT(S),i=0;i&lt;n;i++) writeln(S.f[i].x);return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 794「cdq 分治 整体二分」奇度边集</title>
      <link href="/2022/02/12/ybtoj-794-%E3%80%8Ccdq-%E5%88%86%E6%B2%BB-%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E3%80%8D%E5%A5%87%E5%BA%A6%E8%BE%B9%E9%9B%86/"/>
      <url>/2022/02/12/ybtoj-794-%E3%80%8Ccdq-%E5%88%86%E6%B2%BB-%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E3%80%8D%E5%A5%87%E5%BA%A6%E8%BE%B9%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/794">YbtOJ #794</a></p></blockquote><p>小 A 有一张 $n$ 个点的图，他会依次往里面加入 $m$ 条带权边。</p><p>每加入一条边之后，小 A 都要先判断是否存在一个边集使得所有点度数都是奇数，若存在则求出所有符合要求的边集中 <strong>最大边权</strong> 的 <strong>最小值</strong>，若不存在则输出 <code>-1</code>。</p><p>$1\le n\le10^5$，$1\le m\le 3\times10^5$，$0\leq v\leq 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>发现“所有点度数都是奇数”等价于“这个图中只存在大小为<strong>偶数</strong>的连通块”。</p><p>简单证明：</p><ul><li>必要性：假设存在一个奇数大小的连通块，由于每个点的度数都为奇数，所有度数之和也必定为奇数，而每条边对总度数贡献为 $2$，故总度数必然为偶数，与假设矛盾。所以仅存在偶数大小的连通块。</li><li>充分性：每个偶数大小的连通块，随便跑个生成树，从底往上扫一遍，如果该节点的儿子连上来的边数为偶数，就与其父亲相连，我们发现这样构造可以满足除了根以外的点限制，而又由所有点度数之和为偶数，其他节点数量为奇数，度数也为奇数，所以根的度数也为奇数。</li></ul><p>转换为题意后，考虑权值从小到大加边，如果用并查集维护一下奇连通块的个数，我们就可以完成了一个静态的题目。</p><p>下面考虑如何扩展到动态。</p><p>注意到一条边如果进入时没有进入最优边集，那么就再也不会进入。</p><p>也就是说每条边会有一个影响范围。</p><p>考虑线段树分治，每访问到一个叶子，直接后移指针，添加边，直到合法为止。显然此时就是这条边的影响范围结束位置，而每条边的出现位置显然，于是就做好了。</p><p>但我们发现这是一个边分治一边 cover 的处理过程，直接线段树分治起来可能会有点小问题，因为这个时间点上 cover 上的边不知道什么时候撤回掉。</p><p>这也很简单啊，只 cover 到当前时间减一就可以了，这个点上 cover 上的边在这个点直接撤回就完事了。</p><p>这个算法的原理也很好理解：</p><p>我们每次在叶子节点找答案，祖先节点上 cover 上的时间戳必然合法，在这个点上 cover 上的边也会因为判断而只加起始时间在当前时间点之前的边。</p><p>原本我们的时间复杂度因为每一次暴力加边而变得不可接受。</p><p>而通过计算决策的影响范围与将这些范围线段树分治，就减少了大量的重复计算。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e5+10,P=1e5+10;</span><br><span class="line">int n,m,fa[P],s[P],Ans[N],p;</span><br><span class="line">struct Edge&#123;int x,y,z,id;&#125;e[N];</span><br><span class="line">I bool cmp(Cn Edge&amp; x,Cn Edge&amp; y)&#123;return x.z&lt;y.z;&#125;</span><br><span class="line">I int GF(CI x)&#123;return x==fa[x]?x:fa[x]=GF(fa[x]);&#125;</span><br><span class="line">struct node&#123;int x,y,v;&#125;;</span><br><span class="line">vector&lt;node&gt; stk;</span><br><span class="line">#define pb push_back</span><br><span class="line">I void M(RI x,RI y)&#123;(x=GF(x))^(y=GF(y))&amp;&amp;(s[x]&lt;s[y]&amp;&amp;(swap(x,y),0),s[x]&amp;1&amp;&amp;s[y]&amp;1?n-=2,stk.pb((node)&#123;x,y,2&#125;):stk.pb((node)&#123;x,y,0&#125;),s[x]+=s[y],fa[y]=x,0);&#125;</span><br><span class="line">I void R(CI o)&#123;W(stk.size()^o) s[stk.back().x]-=s[stk.back().y],fa[stk.back().y]=stk.back().y,n+=stk.back().v,stk.pop_back();&#125;</span><br><span class="line">vector&lt;int&gt; G[N&lt;&lt;2];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=m</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        I void U(CI L,CI R,CI v,PT)&#123;if(L&gt;R) return ;if(L&lt;=l&amp;&amp;r&lt;=R) return void(G[x].pb(v));L&lt;=mid&amp;&amp;(U(L,R,v,LT),0),R&gt;mid&amp;&amp;(U(L,R,v,RT),0);&#125;</span><br><span class="line">    public:</span><br><span class="line">        I void Q(PT)&#123;</span><br><span class="line">            RI o=stk.size();for(auto i:G[x]) M(e[i].x,e[i].y);G[x].clear();</span><br><span class="line">            if(l==r)&#123;W(n&amp;&amp;p&lt;m) e[++p].id&lt;=l&amp;&amp;(M(e[p].x,e[p].y),U(e[p].id,l-1,p),0);Ans[l]=n?-1:e[p].z;&#125;</span><br><span class="line">            else Q(RT),Q(LT);R(o);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;edges.in&quot;,&quot;r&quot;,stdin),freopen(&quot;edges.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i;for(read(n,m),i=1;i&lt;=n;i++) fa[i]=i,s[i]=1;</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(e[i].x,e[i].y,e[i].z),e[i].id=i;</span><br><span class="line">    for(sort(e+1,e+m+1,cmp),T.Q(),i=1;i&lt;=m;i++) writeln(Ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树分治 </tag>
            
            <tag> 连通块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 714「点分治」染色计划</title>
      <link href="/2022/02/12/ybtoj-714-%E3%80%8C%E7%82%B9%E5%88%86%E6%B2%BB%E3%80%8D%E6%9F%93%E8%89%B2%E8%AE%A1%E5%88%92/"/>
      <url>/2022/02/12/ybtoj-714-%E3%80%8C%E7%82%B9%E5%88%86%E6%B2%BB%E3%80%8D%E6%9F%93%E8%89%B2%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/714">YbtOJ #714</a></p></blockquote><p>小 A 有一棵 $n$ 个点的无根树，其中编号为 $i$ 的节点初始颜色为 $c_i$。</p><p>一次染色操作可以将某种颜色的点 <strong>全部</strong> 染成另一种颜色。即可以选择两种颜色 $C1,C2$，令当前所有等于 $C1$ 的 $c_i$ 变成 $C2$。</p><p>求至少执行多少次染色操作，使得存在一种颜色 $C$，满足对于任意一对 $c_x&#x3D;c_y&#x3D;C$ 的点 $x,y$，树上 $x,y$ 路径中的节点的颜色都是 $C$。</p><p>$1\le n\le2\times10^5$，$1\le k\le n$，$1\le c_i\le k$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>点分治。</p><p>强制所选的连通块必含分治中心。</p><p>从与分治中心同色的所有点开始 BFS，每次将队首的父节点同色的所有点加入队列。</p><p>若在过程中出现了当前分治连通块之外的点，则这样得到的答案肯定不会比已有答案更优，直接结束 BFS。否则，就可以在 BFS 结束后更新答案。</p><p>这样一来每次 BFS 范围都在分治连通块内，复杂度正确。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e5+10,inf=2e9;</span><br><span class="line">int n,m,F[N],c[N],Ans=inf,used[N],Min,cnt,id,sz[N],vis[N];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;int&gt; G[N],cg[N],vc[N],v;</span><br><span class="line">#define pb push_back</span><br><span class="line">I void GetG(CI x,CI fa)&#123;</span><br><span class="line">    RI mx=0;sz[x]=1;for(auto i:G[x]) i^fa&amp;&amp;!vis[i]&amp;&amp;(GetG(i,x),sz[x]+=sz[i],mx=max(mx,sz[i]));</span><br><span class="line">    mx=max(mx,cnt-sz[x]),mx&lt;Min&amp;&amp;(Min=mx,id=x);</span><br><span class="line">&#125;</span><br><span class="line">I void Get(CI x,CI fa)&#123;F[x]=fa,v.pb(x);for(auto i:G[x]) i^fa&amp;&amp;!vis[i]&amp;&amp;(Get(i,x),0);&#125;</span><br><span class="line">I void Cle(CI x,CI fa)&#123;F[x]=0;for(auto i:G[x]) i^fa&amp;&amp;!vis[i]&amp;&amp;(Cle(i,x),0);&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I void Dfs(CI x)&#123;</span><br><span class="line">    RI i,j,X=0;vis[x]=1;v.clear(),Get(x,0);for(auto i:v) vc[c[i]].pb(i),used[c[i]]=0;</span><br><span class="line">    W(!q.empty()) q.pop();used[c[x]]=1,q.push(c[x]);W(!q.empty())&#123;</span><br><span class="line">        RI u=q.front();q.pop(),X++;if(cg[u].size()!=vc[u].size())&#123;X=inf;break ;&#125;</span><br><span class="line">        for(auto i:vc[u]) F[i]&amp;&amp;(!used[c[F[i]]]&amp;&amp;(q.push(c[F[i]]),used[c[F[i]]]=1));</span><br><span class="line">    &#125;Ans=min(Ans,X);for(auto i:v) vc[c[i]].clear();Cle(x,0);</span><br><span class="line">    for(auto i:G[x]) !vis[i]&amp;&amp;(cnt=sz[i],Min=inf,GetG(i,0),Dfs(id),0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;color.in&quot;,&quot;r&quot;,stdin),freopen(&quot;color.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,y;for(read(n,m),i=1;i&lt;n;i++) read(x,y),G[x].pb(y),G[y].pb(x);</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(c[i]),cg[c[i]].pb(i);Min=inf,cnt=n,GetG(1,0),Dfs(id);</span><br><span class="line">    return writeln(Ans-1),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 507「状压 dp」以线覆圆</title>
      <link href="/2022/02/11/ybtoj-507-%E3%80%8C%E7%8A%B6%E5%8E%8B-dp%E3%80%8D%E4%BB%A5%E7%BA%BF%E8%A6%86%E5%9C%86/"/>
      <url>/2022/02/11/ybtoj-507-%E3%80%8C%E7%8A%B6%E5%8E%8B-dp%E3%80%8D%E4%BB%A5%E7%BA%BF%E8%A6%86%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/507">YbtOJ #507</a></p></blockquote><p>小 A 有 $n$ 条线，长度分别为 $a_{1\sim n}$。此外，他还有一个周长为 $m$ 的圆。</p><p>现在，他想要随机将这 $n$ 条线放到圆周上（线之间可能重叠），长度为 $x$ 的线将覆盖一段长度为 $x$ 的圆弧上的所有点。</p><p>求圆上所有点都被覆盖的概率。</p><p>$2\le n\le 6$，$2\le m\le 50$，$1\le a_i &lt; m$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不妨先钦定所有左端点的小数部分，这样实际有用的点只有 $n\times m$ 个。</p><p>把最长的线段左端点作为原点，化圆为链。</p><p>设 $f_{i,j,k}$ 为处理完左端点小于等于 $i$ 的线段，最大右端点为 $j$，已用线段状压为 $k$ 的方案数。</p><p>由于我们对小数部分离散化过了，所以每一个左端点只可能有某一条线段，右端点也是唯一确定的，所以我们这样 DP 没有问题。</p><p>$$<br>f_{i+1,\min{n\times m,\max{j,i+a_x\times n}},k2^{x-1}}\texttt{+&#x3D;}f_{i,j,k}<br>$$<br>时间复杂度：$O(n^2m^2\times n!\times 2^{n-1})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=7,M=52;</span><br><span class="line">int n,m,S,a[N],b[N],cnt,rk[N],f[2][(1&lt;&lt;N-1)+5][N*M],T;</span><br><span class="line">long double Ans,A;I LL QP(LL a,RI b)&#123;LL s=1;W(b) b&amp;1&amp;&amp;(s*=a),a*=a,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;circle.in&quot;,&quot;r&quot;,stdin),freopen(&quot;circle.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,k,Mx=-1,id;for(read(n,m),S=1&lt;&lt;(n-1),i=1;i&lt;=n;i++) read(a[i]),a[i]&gt;Mx&amp;&amp;(Mx=a[id=i]);</span><br><span class="line">    for(i=1;i&lt;=n;i++) i^id&amp;&amp;(b[++cnt]=a[i],rk[cnt]=cnt);do&#123;</span><br><span class="line">        for(k=0;k&lt;=1;k++) for(i=0;i&lt;S;i++) for(j=0;j&lt;=n*m;j++) f[k][i][j]=0;</span><br><span class="line">        for(f[1][0][Mx*n]=i=1;i&lt;=n*m;i++) if(memcpy(f[i&amp;1^1],f[i&amp;1],sizeof(f[i&amp;1])),i%n) for(j=0;j&lt;S;j++)</span><br><span class="line">            if(!(j&gt;&gt;(i%n-1)&amp;1)) for(k=i;k&lt;=n*m;k++) f[i&amp;1^1][j(1&lt;&lt;(i%n-1))][max(k,min(n*m,i+b[rk[i%n]]*n))]+=f[i&amp;1][j][k];</span><br><span class="line">        Ans+=f[(n*m)&amp;1][S-1][n*m],T++;</span><br><span class="line">    &#125;W(next_permutation(rk+1,rk+cnt+1));return printf(&quot;%.15Lf\n&quot;,(A=Ans/T/QP(m,cnt))),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 986「博弈论」格子染色</title>
      <link href="/2022/02/11/ybtoj-986-%E3%80%8C%E5%8D%9A%E5%BC%88%E8%AE%BA%E3%80%8D%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2/"/>
      <url>/2022/02/11/ybtoj-986-%E3%80%8C%E5%8D%9A%E5%BC%88%E8%AE%BA%E3%80%8D%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/986">YbtOJ #986</a></p></blockquote><p>小 A 和小 B 有一张包含 $n$ 个格子的格子纸条。</p><p>总共有 $k$ 种颜色，编号为 $1\sim k$。初始有一些格子已经染上了颜色（保证初始相邻格子颜色不同）。</p><p>小 A 和小 B 对于这张纸条很感兴趣，他们决定利用这张纸条玩一个游戏：</p><ul><li>小 A 先手，小 B 后手，两人轮流操作。</li><li>轮到一个人操作时，他需要选择一个未被染色的格子，给它染上一种颜色，要求相邻格子不能被染上相同的颜色。</li><li>率先无法进行操作的人输了。</li></ul><p>现在小 A 希望你帮他判断对于给定的局面，他是否有必胜策略。</p><p>$Subtask1(15\%)$：$n\le6$。</p><p>$Subtask2(10\%)$：$n\le100$。</p><p>$Subtask3(10\%)$：$n\le10^3$。</p><p>$Subtask4(10\%)$：所有格子初始都未染色。</p><p>$Subtask5(15\%)$：$k&#x3D;1$。</p><p>$Subtask6(15\%)$：$k&#x3D;2$。</p><p>$Subtask7(10\%)$：$k&#x3D;3$。</p><p>$Subtask8(15\%)$：无特殊限制。</p><p>对于$100\%$的数据，$1\le n,k\le10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Part-Ⅰ：-k-ge-3"><a href="#Part-Ⅰ：-k-ge-3" class="headerlink" title="Part Ⅰ：$k\ge 3$"></a>Part Ⅰ：$k\ge 3$</h3><p>每个格子必然都能被染上颜色。</p><p>因此胜负情况只取决于未被染色的格子数的奇偶性，即当且仅当未被染色的格子数为奇数时先手胜。</p><h3 id="Part-Ⅱ：-k-x3D-1"><a href="#Part-Ⅱ：-k-x3D-1" class="headerlink" title="Part Ⅱ：$k&#x3D;1$"></a>Part Ⅱ：$k&#x3D;1$</h3><p>设 $sg_n$ 表示有 $n$ 个空格子的博弈 $sg$ 函数。</p><p>一种情况是选择边上的格子，后继为 $sg_{n-2}$。</p><p>另一种是选择中间某个格子，那么它以及相邻两侧共三个格子都不能再选择，后继状态为 $SG1(i)\oplus SG1(n-3-i)$。</p><p>所以有：<br>$$<br>sg_n&#x3D;\texttt{mex}{sg_{n-2},\texttt{mex}<em>{i&#x3D;0}^{n-3}{sg_i\oplus sg</em>{n-3-i}}}<br>$$<br>打表发现有循环节，于是做完了。</p><h3 id="Part-Ⅲ：-k-x3D-2"><a href="#Part-Ⅲ：-k-x3D-2" class="headerlink" title="Part Ⅲ：$k&#x3D;2$"></a>Part Ⅲ：$k&#x3D;2$</h3><p>对于一个大小为 $S$ 的区间，考虑其在 $k&#x3D;2$ 时的 $SG$ 函数。</p><p>对于两端有限制的情况，发现只有两种可能的终止态：区间两端限制颜色不同，区间大小为 $0$ 或 $1$。此外，发现当区间两端限制颜色相同时一次操作只会产生两个限制颜色都不同或都相同的区间，区间两端限制颜色不同时一次操作会产生一个限制颜色不同的区间和一个限制颜色相同的区间。于是可以猜想此时的 $SG$ 函数只与区间两端限制颜色是否相同有关，进而发现当限制颜色不同时 $SG$ 函数值为 $0$，当限制颜色相同时 $SG$ 函数值为 $1$。</p><p>对于一端有限制的情况，归纳可证大小为 $S$ 的区间 $SG$ 值就是 $S$。如果我们选择在第 $i$ 个位置（$1\le i\le S$）填上与限制颜色不同的颜色，那么后继状态是 $(i-1)\oplus 0$，即后继状态包含 $0\sim S-1$；如果我们选择在第 $i$ 个位置（$1\le i &lt; S$）填上与限制颜色相同的颜色，那么后继状态是 $(i-1)\oplus 1$，满足 $(i-1)\oplus1\le i &lt; S$。因此后继状态的 $\texttt{mex}$ 就是 $S$，即 $SG$ 值等于 $S$。</p><p>对于没有限制的情况，选择在第 $i$ 个位置上填入一个数的后继状态是 $(i-1)\oplus(n-i)$。显然，只有当 $n$ 是奇数的时候才有可能出现 $(i-1)\oplus(n-i)&#x3D;0$。又由于没有限制肯定是全局的情况，不需要求出具体的 $SG$ 值，只要判断先手是否必胜即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,k,a[N],cnt,Ans,vis[305],sg[305],sg2[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;color.in&quot;,&quot;r&quot;,stdin),freopen(&quot;color.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,lst;for(read(n,k),i=1;i&lt;=n;i++) read(a[i]),!a[i]&amp;&amp;++cnt;</span><br><span class="line">    if(k&gt;=3) return puts(cnt&amp;1?&quot;YES&quot;:&quot;NO&quot;),0;</span><br><span class="line">    if(k==1)&#123;</span><br><span class="line">        for(sg[1]=1,i=2;i&lt;=300;i++)&#123;</span><br><span class="line">            memset(vis,0,sizeof(vis));</span><br><span class="line">            vis[sg[i-2]]=1;</span><br><span class="line">            for(j=0;j&lt;=i-3;j++) vis[sg[j]^sg[i-j-3]]=1;</span><br><span class="line">            sg[i]=0;W(vis[sg[i]]) sg[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        #define GS(x) (sg[(x)&gt;100?((x)-100)%102+100:(x)])</span><br><span class="line">        for(lst=0,i=1;i&lt;=n;i++) if(a[i]) Ans^=GS(max(0,lst?i-lst-3:i-2)),lst=i;</span><br><span class="line">        Ans^=GS(max(0,lst?n-lst-1:n));</span><br><span class="line">        return puts(Ans?&quot;YES&quot;:&quot;NO&quot;),0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt==n)  return puts(n&amp;1?&quot;YES&quot;:&quot;NO&quot;);</span><br><span class="line">    #define SG(l,r) (1&lt;=l&amp;&amp;r&lt;=n?a[l]==a[r]:r-l+1)</span><br><span class="line">    for(lst=0,i=1;i&lt;=n;i++) if(a[i]) Ans^=SG(lst,i),lst=i;</span><br><span class="line">    Ans^=SG(lst,n+1);return puts(Ans?&quot;YES&quot;:&quot;NO&quot;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SG函数 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 604「强连通分量」字符变换</title>
      <link href="/2022/02/11/ybtoj-604-%E3%80%8C%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E3%80%8D%E5%AD%97%E7%AC%A6%E5%8F%98%E6%8D%A2/"/>
      <url>/2022/02/11/ybtoj-604-%E3%80%8C%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E3%80%8D%E5%AD%97%E7%AC%A6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/604">YbtOJ #604</a></p></blockquote><p>小 A 有一个长度为 $n$ 字符串 $s$，满足 $s$ 中只有 <code>A</code>,<code>B</code>,<code>C</code>,<code>D</code> 四种字符。</p><p>他还有 $m$ 个二元组，第 $i$ 个二元组可以用两个 <strong>等长</strong> 的字符串 $(a_i,b_i)$ 表示。</p><p>小 A 可以进行两种操作：</p><ol><li>任意交换字符串 $s$ 中两个不同位置上的字符。</li><li>选择一个 $i$，截取 $s$ 中一个与 $a_i$ 相同的子串，将其替换为 $b_i$。</li></ol><p>小 A 想要知道从 <strong>任意</strong> 初始字符串 $s$ 开始 <strong>连续</strong> 进行若干次变换，在这一过程中最多能得到多少种不同的字符串。</p><p>定义两个字符串不同，当且仅当它们存在至少一个位置上的字符不同。</p><p>$1\leq n\leq 30$，$1\leq m\leq 1000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑到可以任意交换字符，我们直接用三元组 $(x,y,z)$ 表示一种序列，序列中有 $x$ 个 <code>A</code>,$y$ 个 <code>B</code>,$z$ 个 <code>C</code>，那么显然就有 $(n-x-y-z)$ 个 <code>D</code></p><p>那么，如果可以到达一种序列，能得到的字符串个数可以用可重排列数计算（即 $\frac{n!}{x!\cdot y!\cdot z!\cdot (n-x-y-z)!}$）。</p><p>一种序列能通过变换方式 $(a_i,b_i)$ 变成另一种序列，要满足四种字符的个数都大于等于 $a_i$ 中这些字符的个数。</p><p>若序列 A 能变成序列 B，我们就连一条从 A 向 B 的有向边。按这种方式建图，就是要求出从一个点出发最多能到达多少种不同的点，因此 Tarjan 给强连通分量缩点后拓扑跑一下就可以了。</p><p>求可重排列数的时候由于无法直接求 $n!$，可以先把每个数质因数分解然后抵消掉再乘起来。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=35,M=1010;</span><br><span class="line">int n,m,id[N][N][N],cnt,s[N],v[N],pri[N],tot,l[M][4],r[M][4],fir[N*N*N],nxt[N*N*N*M&lt;&lt;1],son[N*N*N*M&lt;&lt;1],ttot,dfn[N*N*N],low[N*N*N],col[N*N*N],stk[N*N*N],cc,top,deg[N*N*N],ccnt;</span><br><span class="line">LL Ans,d[N*N*N],S[N*N*N],w[N*N*N];</span><br><span class="line">I void Add(CI x,CI y)&#123;x^y&amp;&amp;(nxt[++ttot]=fir[x],fir[x]=ttot,son[ttot]=y,0);&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">char sa[N],sb[N];</span><br><span class="line">I void GP()&#123;RI i,j;for(i=2;i&lt;=n;i++) for(!v[i]&amp;&amp;(pri[++tot]=i),j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;j++) if(v[i*pri[j]]=1,!(i%pri[j])) break ;&#125;</span><br><span class="line">I LL QP(LL a,LL b)&#123;LL X=1;W(b) b&amp;1&amp;&amp;(X*=a),a*=a,b&gt;&gt;=1;return X;&#125;</span><br><span class="line">I void Mark(RI x,CI v)&#123;RI i;for(i=1;i&lt;=tot;i++) W(!(x%pri[i])) s[pri[i]]+=v,x/=pri[i];&#125;</span><br><span class="line">I void Tarjan(CI x)&#123;</span><br><span class="line">    RI i;for(dfn[x]=low[x]=++ccnt,stk[++top]=x,i=fir[x];i;i=nxt[i]) if(!dfn[to]) Tarjan(to),low[x]=min(low[x],low[to]);else if(!col[to]) low[x]=min(low[x],dfn[to]);</span><br><span class="line">    if(dfn[x]==low[x])&#123;col[x]=++cc,S[cc]+=w[x];W(stk[top]^x) col[stk[top]]=cc,S[cc]+=w[stk[top]],top--;top--;&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; G[N*N*N];</span><br><span class="line">#define pb push_back</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I void Topo()&#123;</span><br><span class="line">    RI i,u;for(i=1;i&lt;=cc;i++) !deg[i]&amp;&amp;(q.push(i),d[i]=S[i]);W(!q.empty())&#123;</span><br><span class="line">        u=q.front(),q.pop();for(auto i:G[u]) d[i]=max(d[i],d[u]+S[i]),!--deg[i]&amp;&amp;(q.push(i),0);</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;character.in&quot;,&quot;r&quot;,stdin),freopen(&quot;character.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,i1,i2,i3,i4,j;LL t;for(read(n,m),GP(),i=1;i&lt;=m;i++) for(scanf(&quot;%s%s&quot;,sa+1,sb+1),t=strlen(sa+1),j=1;j&lt;=t;j++) l[i][sa[j]-&#x27;A&#x27;]++,r[i][sa[j]-&#x27;A&#x27;]--,r[i][sb[j]-&#x27;A&#x27;]++;</span><br><span class="line">    for(i1=0;i1&lt;=n;i1++) for(i2=0;i1+i2&lt;=n;i2++) for(i3=0;i1+i2+i3&lt;=n;i3++)&#123;</span><br><span class="line">        i4=n-i1-i2-i3,id[i1][i2][i3]=++cnt;for(j=1;j&lt;=n;j++) Mark(j,1);</span><br><span class="line">        for(j=1;j&lt;=i1;j++) Mark(j,-1);for(j=1;j&lt;=i2;j++) Mark(j,-1);for(j=1;j&lt;=i3;j++) Mark(j,-1);for(j=1;j&lt;=i4;j++) Mark(j,-1);</span><br><span class="line">        for(t=1,j=1;j&lt;=n;j++) t*=QP(j,s[j]),s[j]=0;w[cnt]=t;</span><br><span class="line">    &#125;for(i1=0;i1&lt;=n;i1++) for(i2=0;i1+i2&lt;=n;i2++) for(i3=0;i1+i2+i3&lt;=n;i3++) for(i4=n-i1-i2-i3,j=1;j&lt;=m;j++) i1&gt;=l[j][0]&amp;&amp;i2&gt;=l[j][1]&amp;&amp;i3&gt;=l[j][2]&amp;&amp;i4&gt;=l[j][3]&amp;&amp;(Add(id[i1][i2][i3],id[i1+r[j][0]][i2+r[j][1]][i3+r[j][2]]),0);</span><br><span class="line">    for(i=1;i&lt;=cnt;i++) !dfn[i]&amp;&amp;(Tarjan(i),0);for(i=1;i&lt;=cnt;i++) for(j=fir[i];j;j=nxt[j]) if(col[i]^col[son[j]]) G[col[i]].push_back(col[son[j]]),deg[col[son[j]]]++;</span><br><span class="line">    for(Topo(),i=1;i&lt;=cc;i++) Ans=max(Ans,d[i]);return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑 </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 强连通分量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 544「后缀自动机」子串选取</title>
      <link href="/2022/02/10/ybtoj-544-%E3%80%8C%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%8D%E5%AD%90%E4%B8%B2%E9%80%89%E5%8F%96/"/>
      <url>/2022/02/10/ybtoj-544-%E3%80%8C%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%8D%E5%AD%90%E4%B8%B2%E9%80%89%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/544">YbtOJ #544</a></p></blockquote><p>小 A 有一个长度为 $n$ 的小写字母串 $s$。</p><p>你可以从左到右依次 <strong>选出</strong> 若干个 <strong>无交</strong> 子串 $t_1,t_2,\cdots,t_m$，要求每次选出的字符串 $t_i$ 必须是前一个字符串 $t_{i-1}$ 的 <strong>真子串</strong>（即 $t_i$ 是 $t_{i-1}$ 的子串且 $t_i$ 的长度比 $t_{i-1}$ 小）。</p><p>小 A 想要知道一次最多能选出多少个子串（即选出的 $m$ 最大是多少）。</p><p>$1\le n\le5\times10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不妨把串翻转，那么就变成每次在上一个子串的基础上左右任添加字符。</p><p>容易发现答案最大只有 $\sqrt{2n}$，并且贪心地想子串的长度必然依次为 $1,2,3,\cdots,Ans$。</p><p>设 $f_i$ 表示当前答案 $Ans$ 下以 $i$ 为末尾的后缀是否可行。</p><p>按顺序枚举，转移时判断 $[i-Ans+2,i]$ 与 $[i-Ans+1,i-1]$ 的出现情况即可，注意该子串需要为 $i-Ans$ 前的。</p><p>注意到 $i-Ans$ 单调不减，所以在每次 $Ans$ 减少时加入原来 $i-Ans$ 为末尾的合法子串。</p><p>注意到任意时刻 Hash Table 中有用的字符串长度相同，所以动态维护即可。</p><p>据说单模也能过，于是我试着换成了单模结果又wa又T的。</p><p>然后这道题 SAM+线段树 也是能做的，只需要一只 $\log$，但是常数大跑得比根号还慢&#x2F;cy。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">Cn int N=5e5+10,M=sqrt(2*N);</span><br><span class="line">int n,a[N],OW[2][N],Ans,f[N];char s[N];</span><br><span class="line">struct Base&#123;int pw,md;&#125;o[2];</span><br><span class="line">struct HashX&#123;int x,y;&#125;h[N];</span><br><span class="line">I HashX operator+(Cn HashX&amp; A,CI v)&#123;return (HashX)&#123;(1LL*A.x*o[0].pw%o[0].md+v)%o[0].md,(1LL*A.y*o[1].pw%o[1].md+v)%o[1].md&#125;;&#125;</span><br><span class="line">I bool operator==(Cn HashX&amp; A,Cn HashX&amp; B)&#123;return A.x==B.x&amp;&amp;A.y==B.y;&#125;</span><br><span class="line">I HashX Hash(CI l,CI r)&#123;return (HashX)&#123;(h[r].x+o[0].md-1LL*h[l-1].x*OW[0][r-l+1]%o[0].md)%o[0].md,(h[r].y+o[1].md-1LL*h[l-1].y*OW[1][r-l+1]%o[1].md)%o[1].md&#125;;&#125;</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;PA&gt; q[N];</span><br><span class="line">#define pb push_back</span><br><span class="line">I bool operator&lt;(Cn HashX&amp; A,Cn HashX &amp;B)&#123;return A.x^B.x?A.x&lt;B.x:A.y&lt;B.y;&#125;</span><br><span class="line">map&lt;HashX,bool&gt; mp[M];</span><br><span class="line">struct HashTable&#123;</span><br><span class="line">    int fir[19260818],nxt[N*4],val[N*4],w[N*4],tot;</span><br><span class="line">    I void Add(Cn HashX&amp; z)&#123;nxt[++tot]=fir[z.x],fir[z.x]=tot,w[tot]=z.y;&#125;</span><br><span class="line">    I int Q(Cn HashX&amp; z)&#123;RI i;for(i=fir[z.x];i;i=nxt[i]) if(w[i]==z.y) return 1;return 0;&#125;</span><br><span class="line">&#125;H;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;substr.in&quot;,&quot;r&quot;,stdin),freopen(&quot;substr.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,mx,t;for(scanf(&quot;%d&quot;,&amp;n),mx=sqrt(2*n),scanf(&quot;%s&quot;,s+1),o[0]=(Base)&#123;233,19260817&#125;,o[1]=(Base)&#123;31,19260817&#125;,i=1;i&lt;=n;i++) a[i]=s[n-i+1]-&#x27;a&#x27;+1,h[i]=h[i-1]+a[i];</span><br><span class="line">    for(OW[0][0]=OW[1][0]=i=1;i&lt;=n;i++) OW[0][i]=1LL*OW[0][i-1]*o[0].pw%o[0].md,OW[1][i]=1LL*OW[1][i-1]*o[1].pw%o[1].md;for(H.Add((HashX)&#123;0,0&#125;),i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(t=f[i-1]+1;!H.Q(Hash(i-t+2,i))&amp;&amp;!H.Q(Hash(i-t+1,i-1));)&#123;</span><br><span class="line">            t--;for(j=f[i-t];j&gt;=1&amp;&amp;!H.Q(Hash(i-t-j+1,i-t));j--) H.Add(Hash(i-t-j+1,i-t));</span><br><span class="line">        &#125;Ans=max(Ans,(f[i]=t));</span><br><span class="line">    &#125;return printf(&quot;%d\n&quot;,Ans),cerr&lt;&lt;clock()&lt;&lt;&#x27;\n&#x27;,0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 卡常 </tag>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 594「费用流」大图书馆</title>
      <link href="/2022/02/10/ybtoj-594-%E3%80%8C%E8%B4%B9%E7%94%A8%E6%B5%81%E3%80%8D%E5%A4%A7%E5%9B%BE%E4%B9%A6%E9%A6%86/"/>
      <url>/2022/02/10/ybtoj-594-%E3%80%8C%E8%B4%B9%E7%94%A8%E6%B5%81%E3%80%8D%E5%A4%A7%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/594">YbtOJ #594</a></p></blockquote><p>小 A 新开了一个大图书馆（<strong>初始里面没有书</strong>）。</p><p>书的类型有 $n$ 种，其中第 $i$ 种书的价格为 $c_i$。小 A 可以在任意时刻买书。</p><p>同学们经常来图书馆借书，每天上午会来借走恰好一本书，且第 $i$ 天需要的书目类型为 $a_i$（不同天的 $a_i$ 可能会相同）。由于同学们看书速度飞快，当天傍晚即可把书返还给图书馆。</p><p>为了满足同学们的需求，当同学来借书时，必须满足 TA 所想要类型的书目存在。</p><p>然而图书馆内最多只能装 $k$ 本书，若存书数量超过了 $k$，小 A 就不得不选择一些多余的书扔掉。当一种类型的书扔掉后，想要再借出就需要重新购买。</p><p>求小 A 至少需要花费多少钱，才能满足同学们的所有需求。</p><p>$1\leq n,k\leq 1000$，$1\leq a_i\leq n$，$0\leq c_i\leq 10^6$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>强制每天都买书，每天都需要提交书。不存到下次使用的书直接当场提交了，要存到下次使用的书可以存下来在下次强制购买之前回头提交。</p><p>为了消去存下来再次使用的书的强制购买费用，考虑定义一个“卖书”操作，即如果在强制购买之前手上已经有需要的书了，可以把手上这本卖了。具体地，将花费减去 $c_i$，并将这本书提交到上一次需要这本书的那天。</p><p>因此，把每天拆成 $u_0$ 和 $u_1$，用 $u_0$ 表示上午，用 $u_1$ 表示傍晚，然后连下列几类边：</p><p>从超级源向 $u_0$ 连一条容量为 $1$，花费为 $c_{a_u}$ 的边，表示强制每天买书。</p><p>从 $u_1$ 向超级汇连一条容量为 $1$，花费为 $0$ 的边，表示强制每天都需要提交书。</p><p>从 $u_0$ 向 $u_1$ 连一条容量为 $1$，花费为 $0$ 的边，表示不存书，直接提交。</p><p>从 $u_0$ 向 $(u+1)_0$ 连一条容量为 $k-1$，花费为 $0$ 的边，表示有 $k-1$ 个位置可以用于存书（减去的 $1$ 是留给下一天的书的位置）。</p><p>从 $(u-1)<em>0$ 向 $pre[a_u]_1$ 连一条容量为 $1$，花费为 $-c</em>{a_u}$ 表示卖书（$pre[x]$ 表示上次需要第 $x$ 种书的位置）。</p><p>这样建图的点数和边数都是 $O(n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1010,M=N&lt;&lt;1,E=N*10;</span><br><span class="line">int n,k,a[N],c[N],v[N],Ans,Cost,fir[M],nxt[E],son[E],w[E],cost[E],tot=1,C[M],F[M],P[M],vis[M],S,T,inf;</span><br><span class="line">I void Add(CI x,CI y,CI z,CI c)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,cost[tot]=c,nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0,cost[tot]=-c;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">deque&lt;int&gt; q;</span><br><span class="line">#define to son[i]</span><br><span class="line">I bool Spfa()&#123;//寻找增广路</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop_front();q.push_front(S);memset(C,63,sizeof(C)),memset(vis,0,sizeof(vis));F[S]=inf=C[0];C[S]=0;W(!q.empty())</span><br><span class="line">        for(i=fir[vis[u=q.front()]=0,u],q.pop_front();i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;C[to]&gt;C[u]+cost[i]) C[to]=C[u]+cost[P[to]=i],F[to]=min(F[u],w[i]),!vis[to]&amp;&amp;(q.empty()?q.push_front(to),0:(C[to]&gt;C[q.front()]?q.push_back(to):q.push_front(to),0),vis[to]=1);</span><br><span class="line">    return C[T]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">I void MCMF()&#123;//最小费用最大流</span><br><span class="line">    RI i;W(Spfa())&#123;</span><br><span class="line">        for(i=T;i^S;i=son[P[i]^1]) w[P[i]]-=F[T],w[P[i]^1]+=F[T];</span><br><span class="line">        Ans+=F[T],Cost+=C[T]*F[T];</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;bibliotheca.in&quot;,&quot;r&quot;,stdin),freopen(&quot;bibliotheca.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i;for(read(n,k),i=1;i&lt;=n;i++) read(a[i]);for(i=1;i&lt;=n;i++) read(c[i]);</span><br><span class="line">    for(S=0,T=n&lt;&lt;11,i=1;i&lt;=n;i++) Add(S,i,1,c[a[i]]),Add(i,i+n,1,0),Add(i+n,T,1,0),i^n&amp;&amp;(Add(i,i+1,k-1,0),0),v[a[i]]&amp;&amp;(Add(i-1,v[a[i]]+n,1,-c[a[i]]),0),v[a[i]]=i;//建图，具体含义见题解</span><br><span class="line">    return MCMF(),writeln(Cost),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 976「母函数」随机减法</title>
      <link href="/2022/02/10/ybtoj-976-%E3%80%8C%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8D%E9%9A%8F%E6%9C%BA%E5%87%8F%E6%B3%95/"/>
      <url>/2022/02/10/ybtoj-976-%E3%80%8C%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8D%E9%9A%8F%E6%9C%BA%E5%87%8F%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/976">YbtOJ #976</a></p></blockquote><p>小 A 有一个长度为 $n$ 的序列 $a$ 和一个初始值为 $0$ 的计数器 $cnt$，他想要对其进行 $k$ 次操作。</p><p>每次操作，他会等概率随机选中一个 $i$，将 $a_i$ 减 $1$，并将 $cnt$ 加上 <strong>此时</strong> 除 $a_i$ 以外所有数的乘积，即 $\prod_{j\not&#x3D;i}a_j$。</p><p>现在，他希望知道 $cnt$ 在模 $10^9+7$ 意义下的期望值。</p><p>$1\le n\le5\times10^3$，$1\le k\le10^9$，$0\le a_i &lt; 10^9+7$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容易发现将 $a_i$ 减 $1$ 后，除它以外所有数的乘积恰好是 $\prod_{i&#x3D;1}^na_i$ 的变化量。</p><p>所以说，答案实际上就是原本的 $\prod_{i&#x3D;1}^na_i$ 减去修改后 $\prod_{i&#x3D;1}^na_i’$ 的期望值。</p><p>设 $f_{i,j}$ 表示前 $i$ 个数一共修改了 $j$ 次的所有方案下乘积之和，则：</p><p>$$<br>f_{i,p+q}&#x3D;\sum C_{p+q}^p\times (a_i-p)\times f_{i-1,q}<br>$$</p><p>于是：</p><p>$$<br>\frac{f_{i,p+q}}{(p+q)!}&#x3D;\sum\frac{a_i-p}{p!}\times\frac{f_{i-1,q}}{q!}<br>$$</p><p>设 $F_i(x)&#x3D;\sum_{p&#x3D;0}^{+\infty}f_{i,p}\frac{x^p}{p!},G_i(x)&#x3D;\sum_{p&#x3D;0}^{+\infty}(a_i-p)\frac{x^p}{p!}$，得到：</p><p>$$<br>F_i(x)&#x3D;F_{i-1}(x)*G_i(x)<br>$$</p><p>因此只要把 $G_{1\sim n}(x)$ 这 $n$ 个生成函数卷起来就能得到 $F_n(x)$，而它的 $k$ 次项系数就是 $\frac{f_{n,k}}{k!}$ 了。</p><p>对于 $G_i(x)$，我们把 $a_i-p$ 分开来：</p><p>$$<br>G_i(x)&#x3D;a_i\sum_{p&#x3D;0}^{+\infty}\frac{x^p}{p!}-\sum_{p&#x3D;0}^{+\infty}\frac{x^{p+1}}{p!}&#x3D;(a_i-x)e^x<br>$$</p><p>设 $A_i(x)&#x3D;a_i-x$，发现 $F_n(x)$ 就是 $A_{1\sim n}(x)$ 这 $n$ 个生成函数卷起来之后再卷上 $e^{nx}$。</p><p>很容易 $O(n^2)$ 暴力求出 $A_{1\sim n}(x)$ 卷起来后每一项的系数 $f_i$，于是：</p><p>$$<br>F_n(x)&#x3D;(\sum_{i&#x3D;0}^{+\infty}f_ix^i)*(\sum_{i&#x3D;0}^{+\infty}\frac {(nx)^i}{i!})\<br>[x^k]F_n(x)&#x3D;\sum_{i&#x3D;0}^kf_i\times\frac{n^{k-i}}{(k-i)!}<br>$$</p><p>乘上一个 $k!$ 得到了总和 $f_{n,k}$，再除以总方案数 $n^k$ 得到期望：</p><p>$$<br>E&#x3D;\sum_{i&#x3D;0}^{k}\frac{f_i\times k^{\underline i}}{n^i}<br>$$</p><p>最终答案就是$\prod_{i&#x3D;1}^na_i-E$。</p><p>注意一开始卷积直接暴力卷即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e3+10,XX=1e9+7;</span><br><span class="line">int n,k,a[N],sa[N],sb[N],ic[N],Ans;</span><br><span class="line">I int QP(RI a,RI b,CI p=XX)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">// class Poly&#123;</span><br><span class="line">//     private:</span><br><span class="line">//         int P,L,R[N&lt;&lt;2],B[N&lt;&lt;2];</span><br><span class="line">//         I void NTT(int *s,CI op)&#123;</span><br><span class="line">//             RI i,j,k,x,y,U,S;for(i=0;i&lt;P;i++) i&lt;R[i]&amp;&amp;(swap(s[i],s[R[i]]),0);</span><br><span class="line">//             for(i=1;i&lt;P;i&lt;&lt;=1) for(U=QP(QP(3,op,X),(X-1)/(i&lt;&lt;1),X),j=0;j&lt;P;j+=i&lt;&lt;1)</span><br><span class="line">//             for(S=1,k=0;k&lt;i;k++,S=1LL*S*U%X) s[j+k]=((x=s[j+k])+(y=1LL*S*s[i+j+k]%X))%X,s[i+j+k]=(x-y+X)%X;</span><br><span class="line">//         &#125;</span><br><span class="line">//     public:</span><br><span class="line">//         int X,A[N&lt;&lt;2];</span><br><span class="line">//         I void Mul(CI n,int *a,CI m,int *b)&#123;</span><br><span class="line">//             RI i,t;P=1,L=0;W(P&lt;=n+m) P&lt;&lt;=1,++L;for(i=0;i&lt;P;i++) R[i]=(R[i&gt;&gt;1]&gt;&gt;1)((i&amp;1)&lt;&lt;L-1);</span><br><span class="line">//             for(i=0;i&lt;P;i++) A[i]=B[i]=0;for(i=0;i&lt;=n;i++) A[i]=a[i];for(i=0;i&lt;=m;i++) B[i]=b[i];</span><br><span class="line">//             for(NTT(A,1),NTT(B,1),i=0;i&lt;P;i++) A[i]=1LL*A[i]*B[i]%X;</span><br><span class="line">//             for(t=QP(P,X-2,X),NTT(A,X-2),i=0;i&lt;=n+m;i++) A[i]=1LL*A[i]*t%X; </span><br><span class="line">//         &#125;</span><br><span class="line">// &#125;T[3];</span><br><span class="line">// I LL CRT(LL r1,LL p1,LL r2,LL p2,CI fg)&#123;</span><br><span class="line">//     LL k=1LL*((r2-r1)%p2+p2)*QP(p1%p2,p2-2,p2)%p2;</span><br><span class="line">//     return fg?((p1%XX)*k+r1)%XX:(p1*k+r1)%(p1*p2);</span><br><span class="line">// &#125;</span><br><span class="line">// I void Mul(CI n,int *a,CI m,int *b)&#123;</span><br><span class="line">//     RI i;for(i=0;i&lt;3;i++) T[i].Mul(n,a,m,b);</span><br><span class="line">//     for(i=0;i&lt;=n+m;i++) a[i]=CRT(CRT(T[0].A[i],T[0].X,T[1].A[i],T[1].X,0),1LL*T[0].X*T[1].X,T[2].A[i],T[2].X,1);</span><br><span class="line">// &#125;</span><br><span class="line">int T[N];</span><br><span class="line">I void Mul(CI n,int *a,CI m,int *b)&#123;</span><br><span class="line">    RI i,j;for(i=0;i&lt;=n+m;i++) T[i]=0;</span><br><span class="line">    for(i=0;i&lt;=n;i++) for(j=0;j&lt;=m;j++) T[i+j]=(1LL*a[i]*b[j]%XX+T[i+j])%XX;</span><br><span class="line">    for(i=0;i&lt;=n+m;i++) a[i]=T[i];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;calculate.in&quot;,&quot;r&quot;,stdin),freopen(&quot;calculate.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,t;for(read(n,k),Ans=i=1;i&lt;=n;i++) read(a[i]),Ans=1LL*Ans*a[i]%XX;//T[0].X=998244353,T[1].X=469762049,T[2].X=1004535809;</span><br><span class="line">    for(sa[0]=a[1],sa[1]=XX-1,i=2;i&lt;=n;i++) sb[0]=a[i],sb[1]=XX-1,Mul(i-1,sa,1,sb);</span><br><span class="line">    for(ic[n]=QP(QP(n,n),XX-2),i=n-1;~i;i--) ic[i]=1LL*ic[i+1]*n%XX;</span><br><span class="line">    for(t=1,i=0;i&lt;=n;i++) Ans=(XX-1LL*sa[i]*t%XX*ic[i]%XX+Ans)%XX,t=1LL*t*(k-i)%XX;</span><br><span class="line">    return writeln(Ans),cerr&lt;&lt;clock()&lt;&lt;&#x27;\n&#x27;,clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 组合数 </tag>
            
            <tag> 卷积 </tag>
            
            <tag> 母函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 574「二分图匹配」孤立点集</title>
      <link href="/2022/02/09/ybtoj-574-%E3%80%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%8D%E5%AD%A4%E7%AB%8B%E7%82%B9%E9%9B%86/"/>
      <url>/2022/02/09/ybtoj-574-%E3%80%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%8D%E5%AD%A4%E7%AB%8B%E7%82%B9%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/574">YbtOJ #574</a></p></blockquote><p>小 A 有一张 $n$ 个点 $m$ 条边的 DAG，他想要知道最多能选出多少个点，使得这些点中不存在某两个点满足 <strong>其中一个点能到达另一个点</strong>，并希望你给出任意一种点数最多的构造方案。</p><p>更进一步，他想要知道每个点是否 <strong>可能</strong> 出现在一种点数最多的构造方案中。</p><p>$1\le n\le100$，$1\le m\le 10^3$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由 Dilworth 定理，一个 DAG 中最长反链的大小，等于其中最小可重链覆盖大小。</p><p>最小可重链覆盖：在 DAG 中选出若干条链，经过每个点至少一次，一个点可被一条链经过多次，且链数尽量少。</p><p>考虑将每个点拆成出点和入点，对于一条边 $x\rightarrow y$，连接 $x_o$ 与 $y_i$。</p><p>那么我们就可以在这个二分图 $G&#x3D;\langle \langle V_o,V_i\rangle,E’\rangle$ 上跑最大匹配。</p><p>每匹配 $1$ 条边，链的个数就减少 $1$，则有最小链覆盖的大小等于 $n$ 减去最大匹配的大小。</p><p>继续考虑如何从二分图最大匹配中，构造出最长反链。</p><p>首先需要构造二分图最大独立集。</p><p>我们可以从右侧的非匹配点开始 DFS，右侧的点只能走<strong>非匹配边</strong>向左访问，左侧的点只能走<strong>匹配边</strong>向右访问：</p><p>取左侧被 DFS 到的点，以及右侧没被 DFS 到的点，我们可以证明这些点为一个最小点覆盖。</p><p><strong>最小点覆盖</strong>：选取最少的点，覆盖每条边，也就是说每条边的两个端点至少有一个被选中了。</p><p>最大独立集等于最小点覆盖的补集，那么只要选出左侧没被 DFS 到的点和右侧被 DFS 到的点就行了。</p><p>回到 DAG 的情况（注意到我们举的例子并不是 DAG 导出的二分图，所以这个例子不能用来解释最长反链）：</p><p>令最大独立集为 $I$，考虑选出所有 $x_o,x_i$ 都属于 $I$ 的点，记做集合 $A$，它们构成一个最长反链。</p><p>然后是第三问，这只要默认该点被选中，也就是删除这个点和与其有偏序关系的所有点后，再求一次最长反链，如果最长反链的大小只减小了 $1$，那么这个点就能在最长反链中，否则不能。</p><p>时间复杂度：$O(n^{3.5})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=105,M=1e3+10,P=N*2,E=(N*N+N*2)*2,inf=2e9;</span><br><span class="line">int n,m,fir[P],nxt[E],son[E],w[E],tot=1,S,T,cnt,cur[P],D[P],visL[N],visR[N],gT,Mk[N],Ans,r[N];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">bitset&lt;N&gt; b[N];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I bool Bfs()&#123;RI i,u;W(!q.empty()) q.pop();memset(D,-1,sizeof(D)),D[S]=0,q.push(S);W(!q.empty()) for(u=q.front(),q.pop(),i=fir[u];i;i=nxt[i]) w[i]&amp;&amp;!~D[to]&amp;&amp;(q.push(to),D[to]=D[u]+1);return ~D[T];&#125;</span><br><span class="line">I int Dfs(CI x,CI flow)&#123;if(x==T) return flow;RI now=flow,i,d;for(i=cur[x];i;i=nxt[i]) if(cur[x]=nxt[i],w[i]&amp;&amp;D[to]==D[x]+1)&#123;d=Dfs(to,min(now,w[i])),w[i]-=d,w[i^1]+=d,now-=d;if(!now) break ;&#125;return flow-now;&#125;</span><br><span class="line">I int Dinic()&#123;RI i,X=0;W(Bfs())&#123;for(i=1;i&lt;=cnt;i++) cur[i]=fir[i];X+=Dfs(S,inf);&#125;return X;&#125;</span><br><span class="line">I void DFS(CI x)&#123;RI i;for(visR[x]=1,i=1;i&lt;=n;i++) b[i][x]&amp;&amp;!visL[i]&amp;&amp;(visL[i]=1,DFS(r[i]),0);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;isolated.in&quot;,&quot;r&quot;,stdin),freopen(&quot;isolated.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,k,x,y;for(read(n,m),i=1;i&lt;=m;i++) read(x,y),b[x][y]=1;</span><br><span class="line">    for(k=1;k&lt;=n;k++) for(i=1;i&lt;=n;i++) b[i][k]&amp;&amp;(b[i]=b[k],0);</span><br><span class="line">    for(S=1,cnt=(n&lt;&lt;11),T=++cnt,i=1;i&lt;=n;i++) Add(S,i&lt;&lt;1,1),Add(i&lt;&lt;11,T,1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) b[i][j]&amp;&amp;(Add(i&lt;&lt;1,j&lt;&lt;11,1),0);</span><br><span class="line">    Ans=n-Dinic(),writeln(Ans);</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!w[i*4-2]) for(j=fir[i];j;j=nxt[j]) son[j]^S&amp;&amp;!w[j^1]&amp;&amp;(r[i]=son[j]/2);</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(w[i*4]) DFS(i);for(i=1;i&lt;=n;i++) write(!visL[i]&amp;&amp;visR[i]);pc(&#x27;\n&#x27;);</span><br><span class="line">    for(k=1;k&lt;=n;write(gT-Dinic()==Ans-1),k++)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++) Mk[i]=(k^i&amp;&amp;!b[k][i]&amp;&amp;!b[i][k]);</span><br><span class="line">        for(memset(fir,0,sizeof(fir)),tot=S=1,gT=0,cnt=(n&lt;&lt;11),T=++cnt,i=1;i&lt;=n;i++) Mk[i]&amp;&amp;(Add(S,i&lt;&lt;1,1),Add(i&lt;&lt;11,T,1),gT++);</span><br><span class="line">        for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) Mk[i]&amp;&amp;Mk[j]&amp;&amp;b[i][j]&amp;&amp;(Add(i&lt;&lt;1,j&lt;&lt;11,1),0);</span><br><span class="line">    &#125;return pc(&#x27;\n&#x27;),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dilworth定理 </tag>
            
            <tag> 二分图匹配 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 474「决策单调性优化 dp」网格选点</title>
      <link href="/2022/02/09/ybtoj-474-%E3%80%8C%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96-dp%E3%80%8D%E7%BD%91%E6%A0%BC%E9%80%89%E7%82%B9/"/>
      <url>/2022/02/09/ybtoj-474-%E3%80%8C%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E4%BC%98%E5%8C%96-dp%E3%80%8D%E7%BD%91%E6%A0%BC%E9%80%89%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/474">YbtOJ #474</a></p></blockquote><p>小 A 有一张 $T\times T$ 的网格图，左下角为 $(0,0)$，右上角为 $(T,T)$，他在其中指定了 $n$ 个关键点，保证任意两个关键点不同行且不同列。</p><p>你可以从中选出若干个关键点，但需要满足每个点都在前一个点的右上方（即横纵坐标都大于前一个点）。</p><p>要求在 <strong>选出点数尽可能多</strong> 的前提下，求出 <strong>相邻</strong> 两关键点（包括第一个关键点与 $(0,0)$，最后一个关键点与 $(T,T)$）所夹矩形面积之和的最小值。</p><p>定义两点 $(x_1,y_1),(x_2,y_2)$（$x_1\le x_2$，$y_1\le y_2$） 所夹矩形面积为 $(x_2-x_1)\times(y_2-y_1)$。</p><p>$n\le2\times10^5,T\le10^6$，保证所有 $x$ 各不相同，所有 $y$ 各不相同。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先按照横坐标排序，那么我们能选出的点的纵坐标形成一个上升子序列。</p><p>现在要求选出点数尽可能多，就是要求最长上升子序列。</p><p>我们记 $f_i$ 表示以 $i$ 为结尾的最长上升子序列长度，则根据 LIS 问题的经典理论，我们必须要对于每个 $f_i$ 选出恰好一个点 $w_{f_i}$，满足 $w_{f_i}$ 在 $w_{f_i-1}$ 的右上方。因此对于这道题我们可以分层转移。</p><p>考虑 $f_i$ 相同的若干个点，由于我们之前已经按横坐标排过序了，因此它们的纵坐标肯定递减（否则，它们之间就存在转移关系，$f_i$ 不可能相同）。</p><p>而对于 $p_i$，上一层的一个点 $p_j$ 能转移到 $p_i$，需要满足 $p_j$ 的两维坐标都小于 $p_i$，因此转移范围应该是上一层的所有点中的一段区间。</p><p>于是我们利用线段树分治，把 $p_i$ 扔到能转移到它的区间在线段树中对应的节点上，那么这个限制就被化掉了。</p><p>这样一来，所有上一层的转移点都能自由地转移到这一层的所有点，问题就简化了许多。</p><p>比较两个转移点 $p_j,p_k(j &lt; k)$，判断何时 $j$ 优于 $k$：</p><p>$$<br>f_j+(x_i-x_j)(y_i-y_j) &lt; f_k+(x_i-x_k)(y_i-y_k)<br>$$</p><p>把 $y_i,x_i$ 看成变量，移项可得：</p><p>$$<br>y_i&lt;\frac{y_j-y_k}{x_k-x_j}x_i+\frac{f_k+x_ky_k-f_j-x_jy_j}{x_k-x_j}<br>$$</p><p>即，使得 $j$ 优于 $k$ 的 $(x_i,y_i)$ 位于一条斜率为正的直线右下方的一个半平面，具有决策单调性。</p><p>但要注意，这里的决策单调性是这一层越靠后的位置，越可能选择上一层靠前的位置。</p><p>总之怎么判断是否具有决策单调性还是直接打表比较方便。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+100;Cn LL inf=1e12;</span><br><span class="line">int n,Tt,f[N],Ans;LL ans=inf,dp[N];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA a[N];</span><br><span class="line">vector&lt;int&gt; v[N],G[N];</span><br><span class="line">#define pb push_back</span><br><span class="line">class BIT&#123;</span><br><span class="line">    private:</span><br><span class="line">        int T[N];</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI v)&#123;RI i;for(i=p+1;i&lt;=Tt+1;i+=i&amp;-i) T[i]=max(T[i],v);&#125;</span><br><span class="line">        I int Q(CI p)&#123;RI i,S=0;for(i=p+1;i;i-=i&amp;-i) S=max(S,T[i]);return S;&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">#define mid (l+r&gt;&gt;1)</span><br><span class="line">I void Sol(CI L,CI R,CI l,CI r,CI x,CI d)&#123;</span><br><span class="line">    if(l&gt;r) return ;RI i,id=0;LL Mn=inf;</span><br><span class="line">    for(i=L;i&lt;=R;i++) dp[v[d-1][i]]+1LL*(a[G[x][mid]].fi-a[v[d-1][i]].fi)*(a[G[x][mid]].se-a[v[d-1][i]].se)&lt;Mn&amp;&amp;</span><br><span class="line">        (Mn=dp[v[d-1][i]]+1LL*(a[G[x][mid]].fi-a[v[d-1][i]].fi)*(a[G[x][mid]].se-a[v[d-1][i]].se),id=i);</span><br><span class="line">    dp[G[x][mid]]=min(dp[G[x][mid]],Mn);</span><br><span class="line">    Sol(id,R,l,mid-1,x,d),Sol(L,id,mid+1,r,x,d);</span><br><span class="line">&#125;</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        #define PT CI x,CI l,CI r</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI d,PT)&#123;</span><br><span class="line">            #define chk(o) (a[o].fi&lt;a[p].fi&amp;&amp;a[o].se&lt;a[p].se)</span><br><span class="line">            if(a[v[d-1][l]].fi&gt;a[p].fia[v[d-1][r]].se&gt;a[p].se) return ;if(chk(v[d-1][l])&amp;&amp;chk(v[d-1][r])) return void(G[x].pb(p));U(p,d,LT),U(p,d,RT);</span><br><span class="line">        &#125;I void Q(CI d,PT)&#123;if(Sol(l,r,0,G[x].size()-1,x,d),G[x].clear(),l==r) return ;Q(d,LT),Q(d,RT);&#125;</span><br><span class="line">&#125;S;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;grid.in&quot;,&quot;r&quot;,stdin),freopen(&quot;grid.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i;for(read(n,Tt),i=1;i&lt;=n;i++) read(a[i].fi,a[i].se);a[++n]=MP(0,0),a[++n]=MP(Tt,Tt);for(sort(a+1,a+n+1),i=1;i&lt;=n;i++) f[i]=T.Q(a[i].se)+1,T.U(a[i].se,f[i]),v[f[i]].pb(i);</span><br><span class="line">    for(i=1;i&lt;=n;i++) Ans=max(Ans,f[i]),dp[i]=f[i]&gt;1?inf:0LL;for(i=2;i&lt;=Ans;S.Q(i,1,0,v[i-1].size()-1),i++) for(auto j:v[i]) S.U(j,i,1,0,v[i-1].size()-1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) f[i]==Ans&amp;&amp;(ans=min(ans,dp[i]));return writeln(ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 决策单调性优化dp </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 784「莫队算法」序列计数</title>
      <link href="/2022/02/09/ybtoj-784-%E3%80%8C%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E3%80%8D%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/"/>
      <url>/2022/02/09/ybtoj-784-%E3%80%8C%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E3%80%8D%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/784">YbtOJ #784</a></p></blockquote><p>小 A 正在研究单调上升序列。</p><p>他打算进行若干组询问，每次给定三个整数 $l,r,x$，希望求出有多少个序列 $A$ 满足：</p><ul><li>序列的长度 $m$ 是 $l\sim r$ 中的一个整数。</li><li>$1\le A_1 &lt; A_2 &lt; A_3 &lt; \cdots &lt; A_m \le x$。</li></ul><p>你只需要输出答案向 $998244353$ 取模的结果。</p><p>$T\le 2\times10^5$，$1\le l\le r\le x\le 2\times10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>记 $S(n,m)&#x3D;\sum_{i&#x3D;0}^mC_n^i$，则题目中要求的就是 $\sum_{i&#x3D;l}^rC_x^i&#x3D;S(n,r)-S(n,l-1)$。</p><p>于是题意转化为给定 $2T$ 组 $x,y$，询问 $S(x,y)$ 的值。</p><p>然后发现这东西实际上可以用莫队做：</p><ul><li>$y$ 加 $1$：直接加上 $C_x^{y+1}$。</li><li>$y$ 减 $1$：直接减去 $C_x^y$。</li><li>$x$ 加 $1$：考虑 $S(x+1,y)&#x3D;C_{x+1}^0+\sum_{i&#x3D;1}^yC_{x+1}^i&#x3D;C_x^0+\sum_{i&#x3D;1}^y(C_x^i+C_x^{i-1})&#x3D;2S(x,y)-C_x^y$。</li><li>$x$ 减 $1$：将上面的式子变个形，就得到 $S(x-1,y)&#x3D;\frac{S(x,y)+C_{x-1}^y}2$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=4e5+10,p=998244353,Inv2=(p+1)/2;</span><br><span class="line">int n,S,bl[N],fac[N],ifac[N],l,r,cnt;LL ans[N],Ans;</span><br><span class="line">struct node&#123;int l,r,id;&#125;q[N];</span><br><span class="line">struct Que&#123;int l,r,x,id;&#125;Q[N];</span><br><span class="line">I int C(CI n,CI m)&#123;return 1LL*fac[n]*ifac[m]%p*ifac[n-m]%p;&#125;</span><br><span class="line">I int QP(RI a,RI b)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I bool cmp(Cn node&amp; x,Cn node&amp; y)&#123;return bl[x.l]^bl[y.l]?x.l&lt;y.l:bl[x.l]&amp;1?x.r&lt;y.r:x.r&gt;y.r;&#125;</span><br><span class="line">I void add(LL&amp; x,CI y)&#123;(x+=y)&gt;=p&amp;&amp;(x-=p);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n),i=1;i&lt;=n;i++) read(Q[i].l,Q[i].r,Q[i].x),q[++cnt]=(node)&#123;Q[i].x,Q[i].r,i&#125;,q[++cnt]=(node)&#123;Q[i].x,Q[i].l-1,-i&#125;;</span><br><span class="line">    for(S=sqrt(cnt),i=1;i&lt;=cnt;i++) bl[i]=(i-1)/S+1;for(fac[0]=1,i=1;i&lt;N;i++) fac[i]=1LL*fac[i-1]*i%p;for(ifac[N-1]=QP(fac[N-1],p-2),i=N-2;~i;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%p;</span><br><span class="line">    #define abs(x) ((x)&lt;0?-(x):(x))</span><br><span class="line">    for(sort(q+1,q+cnt+1,cmp),Ans=l=1,r=0,i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        W(l&lt;q[i].l) Ans=(2LL*Ans%p-C(l,r)+p)%p,l++;W(r&gt;q[i].r) add(Ans,p-C(l,r)),r--;</span><br><span class="line">        W(l&gt;q[i].l) Ans=(1LL*Inv2*(Ans+C(l-1,r))%p)%p,l--;W(r&lt;q[i].r) add(Ans,C(l,r+1)),r++;</span><br><span class="line">        add(ans[abs(q[i].id)],q[i].id&lt;0?p-Ans:Ans);</span><br><span class="line">    &#125;for(i=1;i&lt;=n;i++) writeln((ans[i]+p)%p);return cerr&lt;&lt;clock()&lt;&lt;&#x27;\n&#x27;,clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 772「分块算法」密码破译</title>
      <link href="/2022/02/09/ybtoj-772-%E3%80%8C%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95%E3%80%8D%E5%AF%86%E7%A0%81%E7%A0%B4%E8%AF%91/"/>
      <url>/2022/02/09/ybtoj-772-%E3%80%8C%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95%E3%80%8D%E5%AF%86%E7%A0%81%E7%A0%B4%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/772">YbtOJ #772</a></p></blockquote><p>你有一个 $n$ 列，无穷行的表格，每个格子上都有一个正整数，第 $i$ 行第 $j$ 列的数为 $a_{i,j}$。我们通过如下方法来构造这个表格：</p><ul><li>$a_{1,i}$ 在输入中直接给出。</li><li>$\forall i&gt;1,j\in [1,n],a_{i,j}&#x3D;\sum_{k&#x3D;1}^j[a_{i-1,k}&#x3D;a_{i-1,j}]$。</li></ul><p>你需要依次执行 $m$ 个操作，操作有以下两种形式：</p><ul><li><code>1 v i</code>：将 $a_{1,i}$ 的值改为 $v$，并将表格重新构造。</li><li><code>2 x y</code>：询问 $a_{x,y}$ 的值。</li></ul><p>对于每个询问，你需要输出对应的结果。</p><p>$1\leq n,m\leq 10^5,1\leq a_{1,i},v\leq 10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>被 fxt 拉来写分块&#x2F;cy。</p><p>很容易注意到偶数行全部相同，奇数行除了第 $1$ 行都相同。</p><p>先考虑偶数行怎么做，先序列分块。设 $s[i][j]$ 表示前 $i$ 块数 $j$ 的出现次数。</p><p>修改的时候暴力修改 $k\sim tot$ 块，查询的时候整块直接查，散块暴力即可。</p><p>显然这东西很好维护，时间复杂度 $O(S)$。</p><p>再考虑奇数行，注意到偶数行每种 $a_i$ 对应的位置上数字为 $1,2,3,\cdots,x$。</p><p>我们可以设 $c[i][j]$ 表示前 $i$ 块，出现次数超过 $j$ 的数的种类。</p><p>修改的时候同样暴力修改，只需要关注恰好到达 $j$ 的位置即可。</p><p>查询的时候整块直接查，散块暴力，时间复杂度 $O(S)$。</p><p>显然修改的常数会很大，所以可以把块长略微调大。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=1e4+10,BM=sqrt(N)+5;</span><br><span class="line">int n,m,S,a[N],tot,bl[N],L[BM],R[BM],s[BM][M],c[BM][N],cp[M];</span><br><span class="line">I void U(CI p,CI v)&#123;if(a[p]==v) return ;RI i;for(i=bl[p];i&lt;=tot;i++) --c[i][s[i][a[p]]--],++c[i][++s[i][v]];a[p]=v;&#125;</span><br><span class="line">I int Q1(CI x)&#123;RI i,X=s[bl[x]-1][a[x]];for(i=L[bl[x]];i&lt;=x;i++) X+=(a[i]==a[x]);return X;&#125;</span><br><span class="line">I int Q2(CI x)&#123;RI i,t=Q1(x),X=c[bl[x]-1][t];for(i=L[bl[x]];i&lt;=x;i++) X+=((++cp[a[i]])+s[bl[x]-1][a[i]]==t);for(i=L[bl[x]];i&lt;=x;i++) --cp[a[i]];return X;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;password.in&quot;,&quot;r&quot;,stdin),freopen(&quot;password.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,o,x,y;for(read(n),S=min((int)sqrt(n)*3,n),i=1;i&lt;=n;i++) read(a[i]),!((i-1)%S)&amp;&amp;(R[tot]=i-1,L[++tot]=i),bl[i]=tot;R[tot]=n;</span><br><span class="line">    for(i=1;i&lt;=tot;i++)&#123;for(j=0;j&lt;M;j++) s[i][j]=s[i-1][j];for(j=0;j&lt;=n;j++) c[i][j]=c[i-1][j];for(j=L[i];j&lt;=R[i];j++) ++c[i][++s[i][a[j]]];&#125;</span><br><span class="line">    for(read(m);m--;) read(o,x,y),o&amp;1?U(y,x):writeln(x^1?x&amp;1?Q2(y):Q1(y):a[y]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 卡常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 582「网络流」大收藏家</title>
      <link href="/2022/02/08/ybtoj-582-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E5%A4%A7%E6%94%B6%E8%97%8F%E5%AE%B6/"/>
      <url>/2022/02/08/ybtoj-582-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E5%A4%A7%E6%94%B6%E8%97%8F%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/582">YbtOJ #582</a></p></blockquote><p>小 C 是在收藏界颇负盛名的大收藏家。</p><p>这天，他带着他的藏品去参加收藏家大会，与大家交换藏品。</p><p>共有 $n$ 名收藏家参加了这次大会，每个人都带了一种与众不同的藏品来，其中第 $i$ 个收藏家带了 $a_i$ 个自己类型的藏品。</p><p>因为小 C 很强，所以他是第 $1$ 个收藏家。大会上会依次进行 $m$ 次交换活动，每次会指定两个不同的收藏家 $x_i$，$y_i$，这两个收藏家可以各自选择自己当前持有的一个藏品与对方交换。每次活动至多进行一次交换，可以不进行交换。</p><p>小 C 想知道，大会结束后，自己最多持有多少种不同的藏品。</p><p>$T\leq 10,1\leq n,m,a_i\leq 3000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不妨假设每个人只有第一个收藏品时有用的，其他只是作为一个交换的空位。</p><p>那么 $S$ 向每个人连流量为 $1$ 的边，第 $1$ 个向 $T$ 连流量为 $a_1$ 的边。</p><p>按照时间建点，把每个点拆成 $m$ 个点，拆出的每个点 $x_i$ 向 $x_{i+1}$ 连容量为 $a_i$ 的边。</p><p>每次操作，对应人对应时间点连流量为 $1$ 的双向边。</p><p>发现不是所有点都有用，每个人只需要拆除与自己相关的点即可。</p><p>点数边数为 $O(n)$ 的，流量不会超过 $n$，所以能跑。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3010,inf=2e9;</span><br><span class="line">int Tt,n,m,a[N],v[N],cnt,fir[N*3],nxt[N*10],w[N*10],son[N*10],tot,cur[N*3],S,T,d[N*3];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I bool Bfs()&#123;W(!q.empty()) q.pop();RI u,i;memset(d,-1,sizeof(d));d[S]=0;q.push(S);W(!q.empty()) for(u=q.front(),q.pop(),i=fir[u];i;i=nxt[i]) w[i]&amp;&amp;!~d[to]&amp;&amp;(q.push(to),d[to]=d[u]+1);return ~d[T];&#125;</span><br><span class="line">I int Dfs(CI x,CI flow)&#123;if(x==T) return flow;RI i,t,now=flow;for(i=cur[x];i;i=nxt[i]) if(cur[x]=nxt[i],w[i]&amp;&amp;d[to]==d[x]+1)&#123;t=Dfs(to,min(now,w[i])),w[i]-=t,w[i^1]+=t,now-=t;if(!now) break ;&#125;return flow-now;&#125;</span><br><span class="line">I int Dinic()&#123;RI i,Ans=0;W(Bfs())&#123;for(i=1;i&lt;=cnt;i++) cur[i]=fir[i];Ans+=Dfs(S,inf);&#125;return Ans;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;collection.in&quot;,&quot;r&quot;,stdin),freopen(&quot;collection.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,y,X,Y;read(Tt);W(Tt--)&#123;</span><br><span class="line">        for(memset(fir,0,sizeof(fir)),tot=1,read(n,m),S=cnt=1,T=++cnt,i=1;i&lt;=n;i++) read(a[i]),Add(S,v[i]=++cnt,1);</span><br><span class="line">        for(i=1;i&lt;=m;i++) read(x,y),X=++cnt,Y=++cnt,Add(v[x],v[y],1),Add(v[y],v[x],1),Add(v[x],X,a[x]),Add(v[y],Y,a[y]),v[x]=X,v[y]=Y;</span><br><span class="line">        Add(v[1],T,a[1]),writeln(Dinic());</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 774「分块算法」奇妙的树</title>
      <link href="/2022/02/08/ybtoj-774-%E3%80%8C%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95%E3%80%8D%E5%A5%87%E5%A6%99%E7%9A%84%E6%A0%91/"/>
      <url>/2022/02/08/ybtoj-774-%E3%80%8C%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95%E3%80%8D%E5%A5%87%E5%A6%99%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/774">YbtOJ #774</a></p></blockquote><p>小 A 有一棵 $n$ 个点的有根树，以 $1$ 号点为根。$i$ 号点的点权为 $a_i$。</p><p>假设 $i$ 号点的父节点为 $f_i$（方便起见认为 $f_1&#x3D;0$），小 A 发现这棵树非常奇妙，它满足一个特殊的性质：对于任意整数 $i\in[2,n]$，满足 $f_{i-1}\le f_i &lt; i$。</p><p>小 A 将会进行 $q$ 次询问，第 $i$ 次询问给出一个区间 $[l_i,r_i]$，求：</p><p>$$<br>(\sum_{x&#x3D;l_i}^{r_i}\sum_{y&#x3D;l_i}^{r_i}[l_i\le \operatorname{LCA}(x,y)\le r_i]\cdot a_x\cdot a_y)\mod998244353<br>$$</p><p><strong>强制在线</strong>。</p><p>$1\le n,q\le2.5\times10^5$，$0\le a_i &lt; 998244353$，$1\le l_i\le r_i\le n$。保证对于任意整数 $i\in[2,n]$，满足 $f_{i-1}\le f_i &lt; i$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>容易通过归纳证明如下几个性质：</p><ul><li>性质一：$x$ 的祖先标号必然小于 $x$。</li><li>性质二：$dep_i$ 随着 $i$ 的增大不降。</li><li>性质三：设 $g_i$ 为 满足 $f_j &lt; i$ 的最大 $j$，则 $i$ 和 $g_i$ 的深度至多相差 $1$。</li><li>性质四：标号在 $[l,r]$ 范围内的点构成以 $[l,\min{r,g_l}]$ 中的点为根的若干无交连通子树。</li></ul><p>则，对于一个询问 $[l,r]$，如果我们只保留 $[l,r]$ 范围内的点，根据性质四，它将构成以 $[l,\min{r,g_l}]$ 中的点为根的若干无交连通子树。</p><p>显然，当且仅当选择的点对 $(x,y)$ 位于同一棵子树中，$\operatorname{LCA}(x,y)$ 会在 $[l,r]$ 范围内。</p><p>而要在一棵子树 $T$ 中选择两个点，它们的乘积和为：<br>$$<br>\sum_{x\in T}\sum_{y\in T}a_xa_y&#x3D;(\sum_{x\in T}a_x)(\sum_{y\in T}a_y)&#x3D;(\sum_{x\in T}a_x)^2<br>$$</p><p>即 $T$ 中所有点权和的平方。</p><p>综上，我们要求出的就是仅保留 $[l,r]$ 中的点时， 这些子树点权和的平方和。</p><p>据性质一，$[1,l)$ 中的点不可能出现在 $[l,r]$ 中的点的子树里，因此我们实际上可以不用只保留 $[l,r]$ 中的点，而是保留 $[1,r]$ 中的所有点。</p><p>于是假设可以离线，把询问按照右端点排序，然后就能把节点一个个加入来扩展右端点了。加入的过程需要更新所有祖先的子树点权和的平方，询问时就是对 $[l,\min{r,g_i}]$ 区间求和。</p><p>但这样时间复杂度未免过于浪费，考虑把这个过程分块一下，即每加入 $S$ 个点就重构一次（遍历整棵树统计所有点的子树点权和，并对其平方做前缀和方便区间查询），不满 $S$ 个点根据具体询问，直接求出这个点在谁的子树中更新对应子树点权和并更新答案即可。</p><p>至于如何判断一个点 $x$ 在谁的子树中，根据性质三，$[l,\min{r,g_i}]$ 最多只有两种不同的深度，我们求出 $x$ 深度为 $dep_l+1$ 的祖先 $t$（可以使用 $O(n\log n)$ 预处理+$O(1)$ 查询的长链剖分求 $k$ 级祖先算法），如果 $t\le g_i$ 说明 $x$ 在 $t$ 的子树中，否则说明 $x$ 在 $f_t$ 的子树中。</p><p>然后发现我们实际上没有必要离线，可以事先预处理出这些信息存下来在线做。</p><p>即对于所有 $i&#x3D;1\sim\lceil\frac nS\rceil$，记录下仅保留标号在 $1\sim (i-1)\times S$ 范围内的点时，所有点的子树点权和 $w_{i,x}$，及其平方的前缀和 $s_{i,x}$。</p><p>假设询问的是 $[l,r]$，按照先前的方式，我们在加入 $1\sim (\lceil\frac rS\rceil-1)\times S$ 中的所有点的基础上，枚举 $(\lceil\frac rS\rceil-1)\times S+1\sim r$ 中的点，求出它在谁的子树中更新对应子树点权和并更新答案。</p><p>PS: 卡常。本人长链被卡，重链剖分与倍增择选复杂度优的跑然后调了调块长才过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=250002,M=510+2,p=998244353;</span><br><span class="line">int n,q,sz,a[N],f[N],S[M][N],SS[M][N],fa[N],dep[N],g[N],bl[N],mx[N],dfn[N],bk[N],cnt,top[N],st[N][20],wei[N],lg[N];</span><br><span class="line">int fir[N],nxt[N],son[N],tot;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">I void addup(int&amp; x,CI y)&#123;(x+=y)&gt;=p&amp;&amp;(x-=p);&#125;</span><br><span class="line">I int add(CI x,CI y)&#123;return (x+y)-(x+y&gt;=p?p:0);&#125;</span><br><span class="line">I void DFS1(CI x)&#123;bl[x]=1;for(RI i=fir[x];i;i=nxt[i]) dep[son[i]]=dep[x]+1,DFS1(son[i]),bl[x]+=bl[son[i]],bl[mx[x]]&lt;bl[son[i]]&amp;&amp;(mx[x]=son[i]);&#125;</span><br><span class="line">I void DFS2(CI x)&#123;if(bk[dfn[x]=++cnt]=x,mx[x]) top[mx[x]]=top[x],wei[mx[x]]=wei[x],DFS2(mx[x]);for(RI i=fir[x];i;i=nxt[i]) son[i]^mx[x]&amp;&amp;(top[son[i]]=son[i],wei[son[i]]=wei[x]+1,DFS2(son[i]),0);&#125;</span><br><span class="line">I int Jump1(RI x,RI k)&#123;W(k&gt;=dfn[x]-dfn[top[x]]+1&amp;&amp;x!=1) k-=(dfn[x]-dfn[top[x]]+1),x=f[top[x]];return bk[dfn[x]-k];&#125;</span><br><span class="line">I int Jump2(RI x,CI k)&#123;for(RI i=lg[k];~i;i--) k&gt;&gt;i&amp;1&amp;&amp;(x=st[x][i]);return x;&#125;</span><br><span class="line">I int Jump(CI x,CI k)&#123;return wei[x]&lt;lg[k]?Jump1(x,k):Jump2(x,k);&#125;</span><br><span class="line">I int Q(CI l,CI r)&#123;</span><br><span class="line">    RI i,t,X=add(SS[bl[r]][g[l]],p-SS[bl[r]][l-1]);</span><br><span class="line">    for(i=max(l,(bl[r]-1)*sz+1);i&lt;=r;i++) t=Jump(i,max(0,dep[i]-dep[l]-1)),t&gt;g[l]&amp;&amp;(t=f[t]),fa[i]=t,addup(X,p-1LL*S[bl[r]][t]*S[bl[r]][t]%p),addup(S[bl[r]][t],a[i]),addup(X,1LL*S[bl[r]][t]*S[bl[r]][t]%p);</span><br><span class="line">    for(i=max(l,(bl[r]-1)*sz+1);i&lt;=r;i++) addup(S[bl[r]][fa[i]],p-a[i]);return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;slight.in&quot;,&quot;r&quot;,stdin),freopen(&quot;slight.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,lst=0,l,r;for(read(n,q),lg[0]=-1,i=1;i&lt;=n;i++) read(a[i]),lg[i]=lg[i/2]+1;</span><br><span class="line">    for(dep[1]=j=1,i=2;i&lt;=n;i++)&#123;read(f[i]),Add(f[i],i),dep[i]=dep[st[i][0]=f[i]]+1;W(j&lt;=f[i]) g[j++]=i-1;&#125;W(j&lt;=n) g[j++]=n;</span><br><span class="line">    for(j=1;j&lt;=lg[n];j++) for(i=1;i&lt;=n;i++) st[i][j]=st[st[i][j-1]][j-1];</span><br><span class="line">    for(DFS1(1),DFS2(wei[1]=1),sz=n/M+2,i=1;i&lt;=n;i++) bl[i]=(i-1)/sz+1;for(i=1;i&lt;=bl[n];i++)&#123;</span><br><span class="line">        for(j=1;j&lt;=(i-1)*sz;j++) S[i][j]=a[j];for(j=n;j;j--) addup(S[i][f[j]],S[i][j]);for(j=1;j&lt;=n;j++) SS[i][j]=add(SS[i][j-1],1LL*S[i][j]*S[i][j]%p);</span><br><span class="line">    &#125;W(q--) read(l,r),writeln(lst=Q(l^lst,r^lst));return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 卡常 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 重链剖分 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 884「线性基」连通的图</title>
      <link href="/2022/02/08/ybtoj-884-%E3%80%8C%E7%BA%BF%E6%80%A7%E5%9F%BA%E3%80%8D%E8%BF%9E%E9%80%9A%E7%9A%84%E5%9B%BE/"/>
      <url>/2022/02/08/ybtoj-884-%E3%80%8C%E7%BA%BF%E6%80%A7%E5%9F%BA%E3%80%8D%E8%BF%9E%E9%80%9A%E7%9A%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/884">YbtOJ #884</a></p></blockquote><p>小 A 有一张 $n$ 个点，$n+k-1$ 条边的无向连通图。</p><p>他想知道有多少种方案删去图中若干条边（包括一条边都不删），满足剩下的图依然连通。</p><p>由于方案数可能很大，你只需输出答案对 $998244353$ 取模的结果。</p><p>$1\le n\le 10^5$，$1\le k\le10$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较神奇的题。</p><p>任意找出一棵生成树，给每条非树边设置一个单独的权值 $2^i$。</p><p>对所有树边，规定它的权值为所有覆盖它的非树边的权值异或和。要实现这一过程，只需利用树上差分给每条非树边覆盖的树边打上异或标记，最后 dfs 遍历一遍做个子树异或和即可求出所有树边的权值。</p><p>发现一张图不连通，充要于 **删去的边集中存在一个子集异或和为 $0$**。</p><p>要判断加入一个数后是否存在子集异或和为 $0$，只要判断能否插入线性基即可。（不能说明线性基内若干数异或和与它相同，则异或上它之后就得到了 $0$）</p><p>现在我们求出了每条边的权值，由于这里同种权值的边并没有区分，且不可能同时加入（显然两个相同权值异或为 $0$），我们可以直接用桶存下每种权值的边数。</p><p>然后就是暴搜，枚举每种权值的边选或不选即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,p=998244353;</span><br><span class="line">int n,k,g[N],C[(1&lt;&lt;11)+5];</span><br><span class="line">vector&lt;int&gt; G[N],v;</span><br><span class="line">#define pb push_back</span><br><span class="line">I void DFS(CI x,CI fa)&#123;for(auto i:G[x]) i^fa&amp;&amp;(DFS(i,x),g[x]^=g[i]);x&gt;1&amp;&amp;++C[g[x]];&#125;</span><br><span class="line">struct LineBasic&#123;</span><br><span class="line">    int d[13];I int Add(LL x)&#123;</span><br><span class="line">        RI i,flg=0;for(i=10;~i;i--) if(x&gt;&gt;i&amp;1)</span><br><span class="line">            if(d[i]) x^=d[i];else return d[i]=x;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[13];</span><br><span class="line">I int dfs(CI x,CI nw)&#123;if(x&gt;=v.size()) return 1;RI S=dfs(x+1,nw);if(A[nw+1]=A[nw],A[nw+1].Add(v[x])) S+=1LL*C[v[x]]*dfs(x+1,nw+1)%p,S%=p;return S;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;connected.in&quot;,&quot;r&quot;,stdin),freopen(&quot;connected.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,y;for(read(n,k),i=1;i&lt;=n+k-1;i++) read(x,y),i&lt;n?G[x].pb(y),G[y].pb(x),0:(++C[1&lt;&lt;i-n],g[x]^=(1&lt;&lt;i-n),g[y]^=(1&lt;&lt;i-n),0);</span><br><span class="line">    for(DFS(1,0),i=1;i&lt;(1&lt;&lt;k);i++) C[i]&amp;&amp;(v.pb(i),0);return printf(&quot;%d\n&quot;,dfs(0,0)),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 825「计算几何初探」三角查找</title>
      <link href="/2022/02/08/ybtoj-825-%E3%80%8C%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%8E%A2%E3%80%8D%E4%B8%89%E8%A7%92%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/02/08/ybtoj-825-%E3%80%8C%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%8E%A2%E3%80%8D%E4%B8%89%E8%A7%92%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/825">YbtOJ #825</a></p></blockquote><p>小 A 有一张二维平面，其中有 $n$ 个点 $(x_i,y_i)$。</p><p>他想要知道，是否存在三个点 $(x_A,y_A),(x_B,y_B),(x_C,y_C)$，满足它们构成的三角形的面积 <strong>恰好</strong> 为 $m$。</p><p>若存在，请给出任意一组符合条件的三个点。</p><p>$3\le n\le2\times10^3$，$1\le m\le2\times10^{18}$，$-10^9\le x_i,y_i\le 10^9$，保证不存在三点共线。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>暴力枚举每条连线作为三角形的底，然后只需要判断是否存在一个点到这条连线的距离恰好等于 $\frac{2m}{l}$ 。</p><p>将这条线段旋成直角坐标系的纵轴，若能让所有点横坐标有序，就可以直接二分。于是问题就变成了如何维护点的顺序。</p><p>发现若将所有点两两之间的连线按斜率排遍序，按照斜率从小到大枚举，则任意两点的横坐标大小关系只会变化恰好一次。</p><p>初始所有点按原横坐标大小顺序排序，枚举连线的过程中每次交换两端点，再在连线两边分别二分查找即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e3+10;</span><br><span class="line">int n,m,cnt,id[N],r[N];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA a[N];</span><br><span class="line">struct Line&#123;int u,v;PA d;&#125;l[N*N];</span><br><span class="line">I bool operator &lt; (Cn Line&amp; x,Cn Line&amp; y)&#123;return x.d.fi*y.d.se-x.d.se*y.d.fi&gt;0;&#125;</span><br><span class="line">I void G(RI tl,RI tr,Line u)&#123;</span><br><span class="line">    auto S=[&amp;](PA p)-&gt;int&#123;return abs(p.fi*u.d.se-p.se*u.d.fi);&#125;;</span><br><span class="line">    RI mid;W(tl&lt;=tr) mid=tl+tr&gt;&gt;1,S(MP(a[id[mid]].fi-a[u.u].fi,a[id[mid]].se-a[u.u].se))==m&amp;&amp;(printf(&quot;Yes\n%d %d\n%d %d\n%d %d\n&quot;,a[u.u].fi,a[u.u].se,a[u.v].fi,a[u.v].se,a[id[mid]].fi,a[id[mid]].se),exit(0),0),S(MP(a[id[mid]].fi-a[u.u].fi,a[id[mid]].se-a[u.u].se))&lt;m?tr=mid-1:tl=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    freopen(&quot;triangle.in&quot;,&quot;r&quot;,stdin),freopen(&quot;triangle.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j;for(read(n,m),m*=2,i=1;i&lt;=n;i++) read(a[i].fi,a[i].se);for(sort(a+1,a+n+1),i=1;i&lt;=n;i++) for(id[r[i]=i]=i,j=1;j&lt;i;j++) l[++cnt]=(Line)&#123;i,j,MP(a[i].fi-a[j].fi,a[i].se-a[j].se)&#125;;</span><br><span class="line">    for(sort(l+1,l+cnt+1),i=1;i&lt;=cnt;i++) r[l[i].u]&gt;r[l[i].v]&amp;&amp;(swap(l[i].u,l[i].v),0),G(1,r[l[i].u]-1,l[i]),swap(r[l[i].u],r[l[i].v]),swap(id[r[l[i].u]],id[r[l[i].v]]);</span><br><span class="line">    return puts(&quot;No&quot;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 581「网络流」图上旅行</title>
      <link href="/2022/02/07/ybtoj-581-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E5%9B%BE%E4%B8%8A%E6%97%85%E8%A1%8C/"/>
      <url>/2022/02/07/ybtoj-581-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E5%9B%BE%E4%B8%8A%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/581">YbtOJ #581</a></p></blockquote><p>小 C 来到了 F 国，小 C 想好好地参观 F 国。F 国可以看一个有 $n$ 个点 $m$ 条边的有向无环图，小 C 刚开始站在 $1$ 号点。</p><p>假设现在小 C 站在 $x$ 号点：</p><ol><li>点 $x$ 没有出边，结束旅游。</li><li>点 $x$ 有 条出边，小 C 等概率地选一条边走过去。</li></ol><p>小 J 是小 C 的好朋友，小 J 可以使用魔法让一些边消失，但是有一些限制 $(x,y)$：第 $y$ 条边如果被删掉了，那么第 $x$ 条边也会受到影响，导致 $x$ 条边被删掉。</p><p>现在小 J 想知道，如何删边使得小 C 所经过的边数期望最大。</p><p>$n\leq 50,m\leq 500,k\leq 2000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不妨设 $f_i$ 表示从 $i$ 走到终点的期望步数，显然有：<br>$$<br>f_u &#x3D; 1 + \frac{\sum_{&lt;u,v&gt;}f_v}{d_u}<br>$$<br>要使 $f_u$ 最大，则 $\frac{\sum_{&lt;u,v&gt;}f_v}{d_u}$ 最大，也就是平均数最大。</p><p>我们很容易可以想到使用分数规划。</p><p>二分答案 $mid$，将所有 $f$ 减去 $mid$ 后跑一遍最大权闭合子图，判断是否大于 $0$，如果大于 $0$ 则平均值大于 $mid$，反之亦然。</p><p>题目比较清新简单，数据比较卡精度，本人卡了快两个小时。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//题出的很好，下次别出了。</span><br><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=550,M=2010,K=2010;long double inf=1e12;</span><br><span class="line">int n,m,k,d[N],fir[N],nxt[M],son[M],tot,fr[M],r[M],S,T,cnt,p[M];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fr[tot]=x,fir[x]=tot,son[tot]=y,d[x]++;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;PA&gt; v[N]; </span><br><span class="line">#define pb push_back</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">#define eps 1e-7</span><br><span class="line">long double f[N];</span><br><span class="line">namespace Flow&#123;</span><br><span class="line">    int fir[M],nxt[M&lt;&lt;2],son[M&lt;&lt;2],tot,cur[M],dis[M];long double w[M&lt;&lt;2];</span><br><span class="line">    I void Add(CI x,CI y,long double z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0;&#125;</span><br><span class="line">    #define to son[i]</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    I bool bfs()&#123;W(!q.empty()) q.pop();q.push(S);memset(dis,-1,sizeof(dis));dis[S]=0;W(!q.empty())&#123;RI u=q.front(),i;q.pop();for(i=fir[u];i;i=nxt[i]) if(w[i]&gt;eps&amp;&amp;dis[to]==-1) dis[to]=dis[u]+1,q.push(to);&#125;return ~dis[T];&#125;</span><br><span class="line">    I long double dfs(CI x,long double flow)&#123;if(x==T) return flow;RI i;long double d,now=flow;for(i=cur[x];i;i=nxt[i]) if(cur[x]=nxt[i],w[i]&gt;eps&amp;&amp;dis[to]==dis[x]+1)&#123;d=dfs(to,min(w[i],now));d&gt;eps&amp;&amp;(w[i]-=d,w[i^1]+=d,now-=d,0);if(now&lt;=eps) break ;&#125;return flow-now;&#125;</span><br><span class="line">    I long double F()&#123;RI i;long double Ans=0;W(bfs())&#123;for(i=1;i&lt;=cnt;i++) cur[i]=fir[i];Ans+=dfs(S,inf);&#125;return Ans;&#125;</span><br><span class="line">    I void C()&#123;memset(fir,0,sizeof(fir)),tot=1;&#125;</span><br><span class="line">&#125;</span><br><span class="line">I bool chk(CI x,long double mid)&#123;</span><br><span class="line">    RI i,t;long double X=0;for(Flow::C(),i=1;i&lt;=cnt-2;i++) r[p[i]]=i,f[t=son[p[i]]]-mid&gt;0?X+=f[t]-mid,Flow::Add(S,i,f[t]-mid):Flow::Add(i,T,mid-f[t]);</span><br><span class="line">    for(auto i:v[x]) Flow::Add(r[i.fi],r[i.se],inf);</span><br><span class="line">    return X-Flow::F()&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;trip.in&quot;,&quot;r&quot;,stdin),freopen(&quot;trip.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    long double l,r,mid;RI i,x,y,u;for(read(n,m,k),i=1;i&lt;=m;i++) read(x,y),Add(x,y),G[y].pb(x);for(i=1;i&lt;=k;i++) read(x,y),v[fr[x]].pb(MP(x,y));for(i=1;i&lt;=n;i++) !d[i]&amp;&amp;(q.push(i),0);W(!q.empty())&#123;</span><br><span class="line">        u=q.front(),q.pop();for(auto i:G[u]) !--d[i]&amp;&amp;(q.push(i),0);for(cnt=0,i=fir[u];i;i=nxt[i]) p[++cnt]=i;if(!cnt) continue ;S=++cnt,T=++cnt,l=0,r=n;</span><br><span class="line">        W(r-l&gt;eps) mid=(l+r)/2.0,chk(u,mid)?l=mid:r=mid;f[u]=l+1;</span><br><span class="line">    &#125;return printf(&quot;%.14Lf\n&quot;,f[1]),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 概率 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 期望 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 最大权闭合子图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 735「动态树」毒瘤染色</title>
      <link href="/2022/02/07/ybtoj-735-%E3%80%8C%E5%8A%A8%E6%80%81%E6%A0%91%E3%80%8D%E6%AF%92%E7%98%A4%E6%9F%93%E8%89%B2/"/>
      <url>/2022/02/07/ybtoj-735-%E3%80%8C%E5%8A%A8%E6%80%81%E6%A0%91%E3%80%8D%E6%AF%92%E7%98%A4%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/735">YbtOJ #735</a></p></blockquote><p>对于一个无向图，若图中的每条边 <strong>至多处于一个无向环中</strong>，则称这个图为一个 <strong>毒瘤图</strong>。</p><p>小 A 有一个图 $G$，初始包含 $n$ 个点，没有边。显然它是一个毒瘤图。</p><p>接下来小 A 会进行 $q$ 次操作，每次操作给出两个正整数 $x,y$，要求判断往 $G$ 中加入 $(x,y)$ 后该图是否仍然是毒瘤图，若是则加入这条边，否则不加入。</p><p>在所有操作进行前，小 A 会确定一个非负整数 $k$。在每次操作后，小 A 都会针对当前图进行询问：假设初始所有点为白色，进行 $k$ 次染色，每次等概率随机选择一个点将它染成黑色（一个点可能被重复选择多次），求 $k$ 次染色后图中 <strong>仅保留白点时的连通块个数+仅保留黑点时的连通块个数</strong> 的 <strong>期望值</strong>（向 $998244353$ 取模）。</p><p>为了让你有更多的得分空间，小 A 还会给定一个辅助变量 $\omega$。若 $\omega&#x3D;1$，你需要回答上述询问。若 $\omega&#x3D;0$，对于每次询问你只需要求出 <strong>仅保留白点时的连通块个数</strong> 的 <strong>期望值</strong>。</p><p>因为一些奇怪的原因，本题 <strong>强制在线</strong>。</p><p>$1\le n\le10^5$，$1\le q\le 3\times10^5$，$0\le k\le 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>在仙人掌中，连通块个数&#x3D;点数-边数+环数</p><p>由于期望的线性性，E(连通块个数)&#x3D;E(点数)-E(边数)+E(环数)</p><p>所以将权值为 $0$ 的点与 $1$ 的点分开求期望即可。</p><p>下面不妨称权值为 $0$ 为白点，$1$ 为黑点。</p><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>一个点为白点概率为 $(\frac{n-1}n)^k$。</p><p>一个点为黑点概率为 $1-(\frac{n-1}n)^k$。</p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>一条边为白边的概率为 $(\frac{n-2}n)^k$。</p><p>一条边为黑边的概率为 $1-Pr(x \text{为白点})-Pr(y \text{为白点})+Pr(x \text{为白点且}y\text{为白点})&#x3D;1-2(\frac{n-1}n)^k+(\frac{n-2}n)^k$。</p><h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>一个大小为 $m$ 的白环的概率为 $(\frac{n-m}n)^k$。</p><p>一个大小为 $m$ 的黑环的概率有两种做法：</p><p><strong>法一：分治 NTT</strong></p><p>设 $f_i$ 表示大小为 $i$ 的环在 $k$ 次操作后全黑的概率，$g_i$ 表示包含 $i$ 个点的集合在 $k$ 次操作后全白的概率。</p><p>显然有 $g_i&#x3D;(\frac{n-i}n)^k$。<br>$$<br>f_i&#x3D;1-Pr(\text{不是全黑})&#x3D;1-\sum_{j&#x3D;0}^{i-1}f_jg_{i-j}\binom ij<br>$$</p><p>直接分治 NTT 就可以 $O(n\log^2n)$ 求出 $f_i$。</p><p><strong>法二：容斥</strong></p><p>$$<br>f_m&#x3D;\sum_{i&#x3D;0}^m(-1)^i\binom mi(\frac{n-i}n)^k<br>$$</p><p>其中 $i$ 枚举的是环中至少有 $i$ 个白点，由于所有环只算一次，于是这部分复杂度为 $O(\sum m\log k)&#x3D;O(n\log k)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e3+10;</span><br><span class="line">int T,p,n,Ans,fac[N],ifac[N],g[N],f[N],s[N];</span><br><span class="line">I int QP(RI a,RI b)&#123;if(b&lt;0) return 0;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I int C(CI n,CI m)&#123;return n&lt;m?0:1LL*fac[n]*ifac[n-m]%p*ifac[m]%p;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;forest.in&quot;,&quot;r&quot;,stdin),freopen(&quot;forest.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,o;read(T,p);for(fac[0]=1,i=1;i&lt;N;i++) fac[i]=1LL*fac[i-1]*i%p;for(ifac[N-1]=QP(fac[N-1],p-2),i=N-2;~i;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%p;</span><br><span class="line">    for(f[1]=1,i=2;i&lt;N;i++) f[i]=QP(i,i-2)%p;</span><br><span class="line">    for(g[0]=1,i=1;i&lt;N;i++) for(j=1;j&lt;=i;j++) g[i]+=1LL*C(i-1,j-1)*g[i-j]%p*f[j]%p,g[i]%=p;</span><br><span class="line">    for(i=2;i&lt;N;i++) for(o=1,j=i-1;j;j--) s[i]+=1LL*C(i-2,j-1)*o%p*j%p*j%p,s[i]%=p,o=1LL*o*(i-1)%p;W(T--)&#123;</span><br><span class="line">        for(read(n),Ans=0,i=1;i&lt;=n;i++) Ans+=1LL*C(n-1,i-1)*g[n-i]%p*s[i]%p,Ans%=p;</span><br><span class="line">        writeln(1LL*Ans*n%p);</span><br><span class="line">    &#125;return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 期望 </tag>
            
            <tag> 仙人掌 </tag>
            
            <tag> 分治NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 584「网络流」欧拉回路</title>
      <link href="/2022/02/07/ybtoj-584-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
      <url>/2022/02/07/ybtoj-584-%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%8D%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/584">YbtOJ #584</a></p></blockquote><p>小 A 有一张 $n$ 个点 $m$ 条边的图，每条边正走与逆走有着不同的边权。</p><p>定义一张图的欧拉回路为经过图中每条边恰好一次，且起点与终点相同的一条路径。（注意，尽管本题中每条边正走与逆走有不同的边权，但 <strong>仍然是一条边</strong>，即正走与逆走次数之和应恰好为 $1$）</p><p>小 A 想要知道所有欧拉回路中 <strong>所经最大边权</strong> 的最小值，并希望你给出任意一条所经最大边权最小的欧拉回路。</p><p>$2\leq n\leq 1000$，$1\leq m\leq 2000$，$1\le$边权$\le10^3$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很容易想到二分答案 $mid$。</p><p>如果正反向<strong>仅有一个</strong> 边权 $\ge mid$，则直接连上，如果两个都 $\ge mid$，则先随便定个向。</p><p>统计每个点 $\Delta i &#x3D;$ 入读 $-$ 出度，如果是欧拉回路的充要条件是 $\forall i,\Delta i &#x3D;0$。</p><p>一开始随便定向的边可以翻转，会导致 $\Delta x ,\Delta y$ 减小 $2$，增大 $2$。</p><p>于是我们可以让所有 $\Delta i &gt; 0$ 的点连着超级源，$\Delta i &lt;0$ 连超级汇，如果一条边能反向则连一条容量为 $1$ 的边。</p><p>只需要跑一次网络流，如果满流则存在欧拉回路。</p><p>方案输出只需要根据网络流满流情况定个向然后随便跑一下就行了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">#define FS 100000</span><br><span class="line">#define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">#define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e3+10,M=2e4+10,inf=2e9;</span><br><span class="line">int n,m,in[N],out[N],S,T,vis[M],cnt,g[N];</span><br><span class="line">struct Edge&#123;int x,y,v1,v2;&#125;e[M];</span><br><span class="line">namespace Flow&#123;</span><br><span class="line">int fir[N],nxt[(M+N)&lt;&lt;1],son[(M+N)&lt;&lt;1],w[(M+N)&lt;&lt;1],tot,cur[N],dis[N];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I bool bfs()&#123;W(!q.empty()) q.pop();q.push(S);memset(dis,-1,sizeof(dis));dis[S]=0;W(!q.empty())&#123;RI u=q.front(),i;q.pop();for(i=fir[u];i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;dis[to]==-1) dis[to]=dis[u]+1,q.push(to);&#125;return ~dis[T];&#125;</span><br><span class="line">I int dfs(CI x,CI flow)&#123;if(x==T) return flow;RI i,d,now=flow;for(i=cur[x];i;i=nxt[i]) if(cur[x]=nxt[i],w[i]&gt;0&amp;&amp;dis[to]==dis[x]+1)&#123;d=dfs(to,min(w[i],now));w[i]-=d,w[i^1]+=d,now-=d;if(!now) break ;&#125;return flow-now;&#125;</span><br><span class="line">I int F()&#123;RI i,Ans=0;W(bfs())&#123;for(i=1;i&lt;=cnt;i++) cur[i]=fir[i];Ans+=dfs(S,inf);&#125;return Ans;&#125;</span><br><span class="line">I void C()&#123;memset(fir,0,sizeof(fir)),tot=1;&#125;</span><br><span class="line">&#125;</span><br><span class="line">I bool chk(CI x)&#123;</span><br><span class="line">memset(in,0,sizeof(in)),memset(out,0,sizeof(out)),Flow::C(),cnt=n,S=++cnt,T=++cnt;RI i,X=0;for(i=1;i&lt;=m;i++) max(e[i].v1,e[i].v2)&lt;=x?out[e[i].x]++,in[e[i].y]++,Flow::Add(e[i].y,e[i].x,1),0:e[i].v1&lt;=x?out[e[i].x]++,in[e[i].y]++:e[i].v2&lt;=x&amp;&amp;(out[e[i].y]++,in[e[i].x]++);</span><br><span class="line">for(i=1;i&lt;=n;i++) if(abs(in[i]-out[i])&amp;1) return 0;else in[i]&gt;out[i]&amp;&amp;(Flow::Add(S,i,abs(in[i]-out[i])&gt;&gt;1),X+=abs(in[i]-out[i])&gt;&gt;1),in[i]&lt;out[i]&amp;&amp;(Flow::Add(i,T,abs(in[i]-out[i])&gt;&gt;1),0);return Flow::F()==X;</span><br><span class="line">&#125;</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;PA&gt; G[N];</span><br><span class="line">vector&lt;int&gt; stk;</span><br><span class="line">#define pb push_back</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;G[x].pb(MP(y,z));&#125;</span><br><span class="line">I void DFS(CI x)&#123;PA i;for(RI j=0;j&lt;G[x].size();j=max(j+1,g[x])) if(i=G[x][j],!vis[i.se]) vis[i.se]=1,g[x]=j+1,DFS(i.fi),stk.pb(i.se);&#125;</span><br><span class="line">I void Prt(CI X)&#123;RI i,j;for(assert(chk(X)),i=1,j=2;i&lt;=m;i++) max(e[i].v1,e[i].v2)&lt;=X?(Flow::w[j]?Add(e[i].x,e[i].y,i):Add(e[i].y,e[i].x,i),j+=2):e[i].v1&lt;=X?Add(e[i].x,e[i].y,i),0:(e[i].v2&lt;=X&amp;&amp;(Add(e[i].y,e[i].x,i),0));for(i=1;i&lt;=n;i++) sort(G[i].begin(),G[i].end());DFS(1);&#125;</span><br><span class="line">I void Out()&#123;reverse(stk.begin(),stk.end());for(auto i:stk) write(i),pc(&#x27; &#x27;);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;euler.in&quot;,&quot;r&quot;,stdin),freopen(&quot;euler.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">RI i,l=0,r=1000,mid,X=2e9;for(srand(time(NULL)),srand(rand()),srand(rand()),read(n,m),i=1;i&lt;=m;i++) read(e[i].x,e[i].y,e[i].v1,e[i].v2),l=max(l,min(e[i].v1,e[i].v2)),r=max(r,max(e[i].v1,e[i].v2));</span><br><span class="line">W(l&lt;=r) chk(mid=l+r&gt;&gt;1)?X=mid,r=mid-1:l=mid+1;return X&gt;=2e9?puts(&quot;NIE&quot;):(writeln(X),Prt(X),Out(),0),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 欧拉回路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 981「prufer编码」森林之和</title>
      <link href="/2022/02/07/ybtoj-981-%E3%80%8Cprufer%E7%BC%96%E7%A0%81%E3%80%8D%E6%A3%AE%E6%9E%97%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/02/07/ybtoj-981-%E3%80%8Cprufer%E7%BC%96%E7%A0%81%E3%80%8D%E6%A3%AE%E6%9E%97%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/981">YbtOJ #981</a></p></blockquote><p>对于一个森林，定义其价值为 <strong>图中所有节点度数的平方和</strong>。</p><p>小 A 想要对所有由 $n$ 个有标号点构成的森林，求出它们的价值之和。(答案向给定的质数 $P$ 取模）</p><p>$T\le5\times10^3$，$1\le n\le5\times 10^3$，$2 \le P &lt; 2^{30}$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先看到度数，容易想到 prufer 序列，其有两个重要结论：</p><ul><li>一棵 $n$ 个点的树和一个长度为 $n-2$、值域为 $1\sim n$ 的整数序列（prufer 序列）一一对应。</li><li>度数为 $d_i$ 的节点会在 prufer 序列中出现 $d_i-1$ 次。</li></ul><p>首先，我们发现每种标号的点对于答案的贡献肯定是一样的，因此我们可以只考虑 $1$ 号点的贡献，然后把这乘个 $n$ 就是答案了。</p><p>设 $f_n$ 表示 $n$ 个点的树的个数，根据 prufer 序列的性质可知，因为共有 $n^{n-2}$ 种序列，也就共有 $n^{n-2}$ 种树，即：</p><p>$$<br>f_n&#x3D;n^{n-2}<br>$$</p><p>然后设 $g_n$ 表示 $n$ 个点的森林个数，有一种对于图的基本递推套路，即枚举 $1$ 号点所在连通块大小 $i$，得到：</p><p>$$<br>g_n&#x3D;\sum_{i&#x3D;1}^nC_{n-1}^{i-1}g_{n-i}\times f_i<br>$$</p><p>接着考虑设 $s_n$ 表示在所有 $n$ 个点的树中 $1$ 号点度数的平方和，那我们就枚举 $1$ 号点的每种度数 $i$ 去计算相应的方案数。</p><p>由于 $1$ 会在 prufer 序列中出现 $i-1$ 次，而剩余的 $(n-2)-(i-1)&#x3D;n-i-1$ 个位置可以任填 $2\sim n$ 中的数，因此递推式就是：</p><p>$$<br>s_n&#x3D;\sum_{i&#x3D;1}^{n-1}C_{n-2}^{i-1}\times (n-1)^{n-1-i}\times i^2<br>$$</p><p>最后设 $w_n$ 表示在所有 $n$ 个点的森林中 $1$ 号点度数的平方和，和 $g_n$ 类似，有递推式：</p><p>$$<br>w_n&#x3D;\sum_{i&#x3D;1}^nC_{n-1}^{i-1}g_{n-i}\times s_i<br>$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e3+10;</span><br><span class="line">int T,p,n,Ans,fac[N],ifac[N],g[N],f[N],s[N];</span><br><span class="line">I int QP(RI a,RI b)&#123;if(b&lt;0) return 0;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">I int C(CI n,CI m)&#123;return n&lt;m?0:1LL*fac[n]*ifac[n-m]%p*ifac[m]%p;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;forest.in&quot;,&quot;r&quot;,stdin),freopen(&quot;forest.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,o;read(T,p);for(fac[0]=1,i=1;i&lt;N;i++) fac[i]=1LL*fac[i-1]*i%p;for(ifac[N-1]=QP(fac[N-1],p-2),i=N-2;~i;i--) ifac[i]=1LL*ifac[i+1]*(i+1)%p;</span><br><span class="line">    for(f[1]=1,i=2;i&lt;N;i++) f[i]=QP(i,i-2)%p;</span><br><span class="line">    for(g[0]=1,i=1;i&lt;N;i++) for(j=1;j&lt;=i;j++) g[i]+=1LL*C(i-1,j-1)*g[i-j]%p*f[j]%p,g[i]%=p;</span><br><span class="line">    for(i=2;i&lt;N;i++) for(o=1,j=i-1;j;j--) s[i]+=1LL*C(i-2,j-1)*o%p*j%p*j%p,s[i]%=p,o=1LL*o*(i-1)%p;W(T--)&#123;</span><br><span class="line">        for(read(n),Ans=0,i=1;i&lt;=n;i++) Ans+=1LL*C(n-1,i-1)*g[n-i]%p*s[i]%p,Ans%=p;</span><br><span class="line">        writeln(1LL*Ans*n%p);</span><br><span class="line">    &#125;return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数 </tag>
            
            <tag> prufer序列 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 891「高斯消元」生日礼物</title>
      <link href="/2022/02/06/ybtoj-891-%E3%80%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E3%80%8D%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/"/>
      <url>/2022/02/06/ybtoj-891-%E3%80%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E3%80%8D%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/891">YbtOJ #891</a></p></blockquote><p>给定一个 $n\times m$ 的矩阵，矩阵的每个位置上有一个灯泡，每个灯泡上有一个开关，一旦按下了位于 $(x_0,y_0)$ 的灯泡的开关， 以及满足 $x-x_0&#x3D;1,y-y_0&#x3D;2$ 或 $x-x_0&#x3D;2,y-y_0&#x3D;1$ 的位置上的灯泡的开关状态都会改变。</p><p>一开始，所有位置上的灯泡都是灭的。</p><p>请你求出有多少种方案将所有灯泡都点亮。</p><p>由于一个灯泡的开关按两次，本质上是没有按这个开关，因此我们规定每个开关最多按一次。并且按开关的顺序不会影响最终的状态。因此我们规定，两种方案不同，当且仅当存在一个开关，在其中一种方案中被按下，但在另一种方案中没有被按下。</p><p>$1\leq n,m\leq 600$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>不妨设 $a_{x,y}$ 表示 $(x,y)$ 是否按开关。显然每个灯泡的亮暗同本身与八个方向的开关有关。</p><p>也就是说，$a_{x,y}$ 与周围八个方向灯泡的 $a$ 异或和为 $1$。</p><p>对于每个灯泡，我们可以列出这样一个方程组，那么我们就可以得到包含 $n\times m$ 个变量的异或方程组，直接高斯消元后，若自由元个数为 $t$，则答案为 $2^t$。</p><p>具体过程可以用 bitset 优化，可以做到 $O(\frac {n^3m^3}{64})$。</p><h3 id="删除多余元"><a href="#删除多余元" class="headerlink" title="删除多余元"></a>删除多余元</h3><p>目前影响时间复杂度的主要问题在于无用变量过多。这种经典开关问题很显然可以缩减变量规模：</p><p><img src="https://s2.loli.net/2022/02/06/b2Y1PeGMKnVscJo.png" alt="image.png"></p><p>如果我们确定了前两行与最左边一行，那么我们按顺序从上到下从左往右枚举每一个格子 $(i,j)$，都会因 $(i-2,j-1)$ 格的影响而 <strong>唯一确定该格点的开关情况</strong>。所以真正未知的元个数为 $2m+n-2$。（$O(n)$ 级别）</p><p>由于最后两行与最后一列没有格子为其灵活变动，是必须固定亮的，所以我们可以对于这些格点列异或方程组，恰与变量个数相同，同样用 bitset 优化即可。</p><p>时间复杂度：$O(\frac{(n+m)^3}{64})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=610,M=N*3,dx[]=&#123;1,1,-1,-1,2,2,-2,-2&#125;,dy[]=&#123;2,-2,2,-2,1,-1,-1,1&#125;,P=123456789;</span><br><span class="line">int n,m,cnt,tot,Ans=1,vis[M];</span><br><span class="line">bitset&lt;M&gt; a[N][N],f[M];</span><br><span class="line">I void G()&#123;RI i,j,p;for(i=1;i&lt;=cnt;i++)&#123;for(p=0,j=1;j&lt;=cnt;j++) if(f[j][i]&amp;&amp;!vis[j])&#123;p=j;break ;&#125;if(!p) Ans=2LL*Ans%P;else for(vis[p]=1,j=1;j&lt;=cnt;j++) !vis[j]&amp;&amp;f[j][i]&amp;&amp;(f[j]^=f[p],0);&#125;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;present.in&quot;,&quot;r&quot;,stdin),freopen(&quot;present.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,k;for(read(n,m),i=1;i&lt;=min(2,n);i++) for(j=1;j&lt;=m;j++) a[i][j][++cnt]=1;for(i=3;i&lt;=n;i++) a[i][1][++cnt]=1;</span><br><span class="line">    for(i=3;i&lt;=n;i++) for(j=2;j&lt;=m;j++) for(a[i][j]=a[i-2][j-1],k=0;k&lt;8;k++)</span><br><span class="line">        i-2+dx[k]&gt;=1&amp;&amp;i-2+dx[k]&lt;=n&amp;&amp;j-1+dy[k]&gt;=1&amp;&amp;j-1+dy[k]&lt;=m&amp;&amp;(i-2+dx[k]!=ij-1+dy[k]!=j)&amp;&amp;(a[i][j]^=a[i-2+dx[k]][j-1+dy[k]],0);</span><br><span class="line">    for(i=max(1,n-1);i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(f[++tot]=a[i][j],k=0;k&lt;8;k++) i+dx[k]&gt;=1&amp;&amp;i+dx[k]&lt;=n&amp;&amp;j+dy[k]&gt;=1&amp;&amp;j+dy[k]&lt;=m&amp;&amp;(f[tot]^=a[i+dx[k]][j+dy[k]],0);</span><br><span class="line">    for(i=max(0,n-2);i;i--) for(f[++tot]=a[i][m],k=0;k&lt;8;k++) i+dx[k]&gt;=1&amp;&amp;i+dx[k]&lt;=n&amp;&amp;m+dy[k]&gt;=1&amp;&amp;m+dy[k]&lt;=m&amp;&amp;(f[tot]^=a[i+dx[k]][m+dy[k]],0);</span><br><span class="line">    return G(),writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
            <tag> bitset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 894「高斯消元」高维寻点</title>
      <link href="/2022/02/06/ybtoj-894-%E3%80%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E3%80%8D%E9%AB%98%E7%BB%B4%E5%AF%BB%E7%82%B9/"/>
      <url>/2022/02/06/ybtoj-894-%E3%80%8C%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E3%80%8D%E9%AB%98%E7%BB%B4%E5%AF%BB%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/894">YbtOJ #894</a></p></blockquote><p>小 A 有一个 $m$ 维空间。在这个空间中有 $n$ 个特殊点，其中第 $i$ 个特殊点 $p_i$ 的坐标为 $(x_{i,1},x_{i,2},\cdots,x_{i,m})$。</p><p>他希望找到这个 $m$ 维空间中的一个点 $P$，使得 $\max_{i&#x3D;1}^n\operatorname{dist}(P,p_{i})$ 最小。</p><p>提示：$m$ 维空间中的两点 $(A_1,A_2,\cdots,A_m),(B_1,B_2,\cdots,B_m)$ 间的距离为 $\sqrt{\sum_{i&#x3D;1}^m(A_i-B_i)^2}$。</p><p>$1\le n\le 20000$，$1\le m\le5$，$0\le$ 所有坐标 $\le10^4$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先二维最小覆盖圆的求法：</p><p>首先我们枚举一个点 $p_i$，如果它不在原本前 $i-1$ 个点的最小覆盖圆内，就必然在当前前 $i$ 个点的最小覆盖圆上。因此我们重构最小覆盖圆，由于初始只能确定这一个点在最小覆盖圆上，所以令此时的最小覆盖圆的圆心为当前点，半径为$0$。</p><p>然后我们再在 $[1,i)$ 中枚举点 $p_j$，如果它不在当前的最小覆盖圆内，同理我们可以确定它在新的最小覆盖圆上，那么我们就能确定两个点。所以令此时的最小覆盖圆的圆心为这两个点构成线段的中点，半径就是这两点间距离的一半。</p><p>同理继续在 $[1,j)$ 中枚举点 $p_k$，如果它不在当前的最小覆盖圆内，就令新的最小覆盖圆为这三个点的最小外接圆（其实之前两种情况也都是特殊的最小外接圆）。</p><p>这个做法看似暴力，但实际上可以利用 <strong>随机增量法</strong> 来使复杂度正确。即将数据随机打乱。</p><p>可以证明是 $O(N)$ 的。</p><p>那么高维的只需要解决如何求最小外接圆。</p><p>令 $\vec Q_i&#x3D;q_i-q_t$，设圆心 $O&#x3D;q_t+\sum_{i&#x3D;1}^{t-1}\lambda_i\vec Q_i$。</p><p>由于 $\text{dist}(A,B)&#x3D;\sqrt{(A-B)^2}$（这里的平方指自己与自己做点乘），因此可以对于每个 $k\in[1,t)$ 列出方程：</p><p>$$<br>(\sum_{i&#x3D;1}^{t-1}\lambda_i\vec Q_i)^2&#x3D;(\sum_{i&#x3D;1}^{t-1}\lambda_i\vec Q_i-\vec Q_k)^2<br>$$</p><p>拆平方移个项即可得到：</p><p>$$<br>\sum_{i&#x3D;1}^{t-1}2(\vec Q_i\cdot \vec Q_k)\lambda_i&#x3D;(\vec Q_k)^2<br>$$</p><p>用高斯消元解个方程即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">Cn int N=2e4+10,M=6;</span><br><span class="line">int n,m;</span><br><span class="line">double A[M][M],b[M];</span><br><span class="line">#define P valarray&lt;double&gt;</span><br><span class="line">P a[N];</span><br><span class="line">vector&lt;P&gt; v,t;</span><br><span class="line">#define pb push_back</span><br><span class="line">struct C&#123;P O;double R;&#125;Ans;</span><br><span class="line">I bool IC(Cn C&amp; x,Cn P&amp; p)&#123;return ((x.O-p)*(x.O-p)).sum()&lt;=x.R;&#125;</span><br><span class="line">C G()&#123;</span><br><span class="line">    RI i,j,k,sz=v.size();for(t=v,memset(A,0,sizeof(A)),i=0;i&lt;sz-1;i++) t[i]-=t.back();for(i=0;i&lt;sz-1;i++) for(A[i][sz-1]=(t[i]*t[i]).sum(),j=0;j&lt;sz-1;j++) A[i][j]=2*(t[i]*t[j]).sum();</span><br><span class="line">    for(i=0;i&lt;sz-1;i++)&#123;for(j=i;j&lt;sz-1;j++) if(fabs(A[j][i])&gt;fabs(A[i][i])) swap(A[i],A[j]);for(j=sz-1;j&gt;=i;j--) A[i][j]/=A[i][i];for(j=0;j&lt;sz-1;j++) if(i^j)&#123;double t=A[j][i]/A[i][i];for(k=0;k&lt;sz;k++) A[j][k]-=A[i][k]*t;&#125;&#125;</span><br><span class="line">    P S;S.resize(m);for(i=0;i&lt;sz-1;i++) S=S+A[i][sz-1]*t[i];return (C)&#123;t[sz-1]+S,(S*S).sum()&#125;;</span><br><span class="line">&#125;</span><br><span class="line">I C Sol(CI x)&#123;C t;t.O.resize(m),t.R=0,v.size()&amp;&amp;(t=G(),0);RI i;for(i=1;i&lt;=x;i++) !IC(t,a[i])&amp;&amp;(v.pb(a[i]),t=Sol(i-1),v.pop_back(),0);return t;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;dimension.in&quot;,&quot;r&quot;,stdin),freopen(&quot;dimension.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j;double x;for(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),i=1;i&lt;=n;i++) for(a[i]=P(m),j=0;j&lt;m;j++) scanf(&quot;%lf&quot;,&amp;x),a[i][j]=x;</span><br><span class="line">    for(Ans=Sol(n),i=0;i&lt;m;i++) printf(&quot;%.10lf &quot;,Ans.O[i]);return printf(&quot;\n&quot;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
            <tag> 随机化 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 最小覆盖圆 </tag>
            
            <tag> 随机增量法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 644「平衡树」模糊序列</title>
      <link href="/2022/02/06/ybtoj-644-%E3%80%8C%E5%B9%B3%E8%A1%A1%E6%A0%91%E3%80%8D%E6%A8%A1%E7%B3%8A%E5%BA%8F%E5%88%97/"/>
      <url>/2022/02/06/ybtoj-644-%E3%80%8C%E5%B9%B3%E8%A1%A1%E6%A0%91%E3%80%8D%E6%A8%A1%E7%B3%8A%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/644">YbtOJ #644</a></p></blockquote><p>小 A 有一个长度为 $n$ 的正整数序列 $a_{1\sim n}$，但其中所有的值都已经模糊不清了，只知道每个数的取值范围。</p><p>即，对于每个 $i\in[1,n]$，给出两个正整数 $l_i,r_i$，表示 $a_i\in[l_i,r_i]$。</p><p>对于所有可能的序列，他想要求出 <strong>最长严格上升子序列长度</strong> 的最大值。</p><p>$1\le n\le3\times10^5$，$1\le l_i\le r_i\le10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f_i$ 表示长度为 $i$ 的严格上升子序列最后一位的最小值。显然随着 $i$ 的增大，$f_i$ 必递增。</p><p>那么我们可以针对每次新增的数 $x\in[l,r]$ 分类讨论转移。<br>$$<br>f_{i-1}&lt;l-1,f_i&#x3D;\min {f_i, l}\\<br>l-1\leq f_{i-1}\leq r-1, f_i &#x3D; \min { f_i,f_{i-1}+1 }<br>$$<br>发现等价于在第 $p$ 位插入一个新数 $l$，将原本的 $[p,q]$ 部分右移一位并加 $1$，删去原本的第 $q+1$ 位。</p><p>可以用平衡树实现这一过程。最终的答案就是平衡树的大小。</p><p>时间复杂度：$O(n\log n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e5+10,inf=2e9;</span><br><span class="line">int n,Ans,rt;</span><br><span class="line">class Treap&#123;</span><br><span class="line">    private:</span><br><span class="line">        int cnt;struct node&#123;int v,tg,rd,l,r;&#125;T[N&lt;&lt;1];</span><br><span class="line">        #define AP(x,sv) (T[x].tg+=sv,T[x].v+=sv)</span><br><span class="line">        I void PD(CI x)&#123;T[x].l&amp;&amp;(AP(T[x].l,T[x].tg),0),T[x].r&amp;&amp;(AP(T[x].r,T[x].tg),0),T[x].tg=0;&#125;</span><br><span class="line">    public:</span><br><span class="line">        I int NW(CI x)&#123;return T[++cnt]=(node)&#123;x,0,rand(),0,0&#125;,cnt;&#125;</span><br><span class="line">        I int M(CI x,CI y)&#123;if(!x!y) return x+y;if(T[x].rd&gt;T[y].rd) return PD(x),T[x].r=M(T[x].r,y),x;else return PD(y),T[y].l=M(x,T[y].l),y;&#125;</span><br><span class="line">        I void S(RI z,CI v,int&amp; x,int&amp; y)&#123;if(!z) return void(x=y=0);if(PD(z),T[z].v&lt;=v) x=z,S(T[z].r,v,T[z].r,y);else y=z,S(T[z].l,v,x,T[z].l);&#125;</span><br><span class="line">        I int C(RI x)&#123;if(!x) return 0;if(PD(x),!T[x].l)&#123;RI o=T[x].r;T[x].r=0;return o;&#125;return T[x].l=C(T[x].l),x;&#125;</span><br><span class="line">        I void F(CI x)&#123;if(!x) return ;if(T[x].v&lt;inf) Ans++;PD(x),F(T[x].l),F(T[x].r);&#125;</span><br><span class="line">        I void A(CI x)&#123;AP(x,1);&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;vague.in&quot;,&quot;r&quot;,stdin),freopen(&quot;vague.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,o,x,y,z,l,r;for(srand(19260817),read(n),rt=T.NW(0),i=1;i&lt;=n+1;i++) T.M(rt,T.NW(inf));</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(l,r),T.S(rt,l-1,x,y),T.S(y,r-1,y,z),o=T.NW(l),y&amp;&amp;(T.A(y),0),z=T.C(z),rt=T.M(T.M(x,o),T.M(y,z));</span><br><span class="line">    return T.F(rt),writeln(Ans-1),clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 数据结构优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 454「概率期望 dp」期望旅行</title>
      <link href="/2022/02/06/ybtoj-454-%E3%80%8C%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B-dp%E3%80%8D%E6%9C%9F%E6%9C%9B%E6%97%85%E8%A1%8C/"/>
      <url>/2022/02/06/ybtoj-454-%E3%80%8C%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B-dp%E3%80%8D%E6%9C%9F%E6%9C%9B%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/454">YbtOJ #454</a></p></blockquote><p>小 A 有一张 $n$ 个点的有向图。</p><p>已知图中 $x\rightarrow y$ 的有向边每天有 $a_{x,y}$ 的概率存在。保证 $\forall x,a_{x,x}&#x3D;1$，即所有自环肯定存在。</p><p>小 A 从 $1$ 号点出发，每天需要选择当前所在点一条 <strong>存在</strong> 的出边，走到对应的点。</p><p>求采取最优策略时，从 $1$ 号点走到 $n$ 号点的期望天数。</p><p>$1\le n\le 3\times10^3$，$0\le a_{i,j}\le 1$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $E(x)$ 表示 <strong>采取最优策略时，从 $x$ 走到 $n$ 的期望步数</strong>。</p><p>假设对于一个点 $x$，已知有 $k$ 个点 $y_1,y_2,…,y_k$ 满足 $E(y_1)\le E(y_2)\le…\le E(y_k)\le E(x)$。</p><p>显然贪心地去考虑，必然是尽可能走到 $y_1$，次优是走到 $y_2$，以此类推。</p><p>所以我们可以倒着做，记 $s_x&#x3D;\sum_{i&#x3D;1}^k(E(y_i)+1)\times a_{x,y_i}\times\prod_{j&#x3D;1}^{i-1}(1-a_{x,y_j})$，表示 <strong>离开</strong> $x$ 到 $n$ 的期望天数。</p><p>记 $p_x&#x3D;\prod_ik(1-a_{x,y_i})$，表示 <strong>不会离开</strong> $x$ 的概率。</p><p>那么 $E(x)$ 的计算就很简单了，只需分是否离开两种情况，得到 $E(x)&#x3D;p_x(E(x)+1)+s_x$，化简即 $E(x)&#x3D;\frac{s_x+p_x}{1-p_x}$。</p><p>直接暴力类似 Dijkstra 转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">Cn int N=3e3+10;</span><br><span class="line">int n,vis[N];</span><br><span class="line">double a[N][N],s[N],e[N],E[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;trip.in&quot;,&quot;r&quot;,stdin),freopen(&quot;trip.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,u;for(scanf(&quot;%d&quot;,&amp;n),i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) scanf(&quot;%lf&quot;,&amp;a[i][j]);</span><br><span class="line">    auto CL=[&amp;]() -&gt; void&#123;RI i;for(i=1;i&lt;=n;i++) !vis[i]&amp;&amp;(e[i]=0.0,s[i]=1.0);&#125;;</span><br><span class="line">    auto CT=[&amp;](CI x) -&gt; void&#123;RI i;for(i=1;i&lt;=n;i++) !vis[i]&amp;&amp;(e[i]+=(E[x]+1)*a[i][x]*s[i],s[i]*=1.0-a[i][x]);&#125;;</span><br><span class="line">    auto CP=[&amp;]() -&gt; void&#123;RI i;for(E[u=0]=2e9,i=1;i&lt;=n;i++) !vis[i]&amp;&amp;(E[i]=(s[i]+e[i])/(1.0-s[i]),E[i]&lt;E[u]&amp;&amp;(u=i));&#125;;</span><br><span class="line">    CL(),u=n;W(u) vis[u]=1,CT(u),CP();return printf(&quot;%.8lf\n&quot;,E[1]),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 概率 </tag>
            
            <tag> dijkstra </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 535「后缀数组」相似子串</title>
      <link href="/2022/02/06/ybtoj-535-%E3%80%8C%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E3%80%8D%E7%9B%B8%E4%BC%BC%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/02/06/ybtoj-535-%E3%80%8C%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E3%80%8D%E7%9B%B8%E4%BC%BC%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/535">YbtOJ #535</a></p></blockquote><p>小 A 有一个长度为 $n$ 的数字串 $s$，下标为 $1\sim n$。</p><p>对于两个 <strong>长度相等</strong> 的字符串 $A,B$，设它们的长度为 $len$，则定义 $A,B$ <strong>相似</strong> 当且仅当对 $\forall 1\le i,j\le len$，$[A_i&#x3D;A_j]&#x3D;[B_i&#x3D;B_j]$（即 $A_i$ 与 $A_j$ 相等充要于 $B_i$ 与 $B_j$ 相等）。</p><p>接下来小 A 会进行 $q$ 次询问，每次询问 $s$ 中有多少个子串与 $s[l_i : r_i]$ 相似（包括 $s[l_i : r_i]$ 自身）。这里的 $s[l_i : r_i]$ 意为由 $s$ 中第 $l_i\sim r_i$ 个字符依次拼接得到的字符串。</p><p><strong>强制在线</strong>。</p><p>$1\le n\le 10^5$，$1\le q\le 5\times10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于字符串 $S$，可以将每种字符的上一次出现位置与此位置作差，作为本位置的值。</p><p>这样转化后如果两个字符串相似则转化后的数组完全相同。</p><p>那么也就可以转化为 $[l1:]$ 与 $[l2:]$ 的 $\text{LCP}$ 长度超过区间长度 $L$ 。</p><p>注意到后缀转化后的数组同原串转化后的数组最多只会相差 $10$ 位（每种字符第一次出现的位置有差异）。</p><p>于是我们以这 $10$ 个位置为关键点，分段进行比较。</p><p>所以我们先对原串转化成的数组建立后缀数组，这样一来若要求解两个后缀转化成的数组的 $\text{LCP}$，就可以直接 <strong>按关键点划分成若干段</strong>，将每一部分依次比较。</p><p>既然能够求出 $\text{LCP}$，那么只要比较 $\text{LCP}$ 的后一位就能比较两个不同后缀转化成的数组的字典序，也就可以将所有后缀转化成的数组做一遍排序。</p><p>然后，预先求出排名相邻的后缀的 $\text{LCP}$（类似于一般后缀数组中的 Height 数组）。</p><p>询问时在这个 “Height 数组” 上分别向左向右二分一下即可。</p><p>发现其实也并不需要使用后缀数组，求 $\text{LCP}$ 直接 Hash+二分 也行，就是复杂度上多了只 $\log$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">超！还卡哈希！</span><br><span class="line">*/</span><br><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,base=13,base2=17,P=998244353;</span><br><span class="line">int n,q,a[N],rk[N],p[N],F[N][25],H[N][11],lg[N],v[N],pw[N],hsh[N],hsh2[N],pw2[N];</span><br><span class="line">char s[N];vector&lt;int&gt; G[N];</span><br><span class="line">#define pb push_back</span><br><span class="line"></span><br><span class="line">struct ST&#123;</span><br><span class="line">    int dp[600010][51];</span><br><span class="line">    void get(int *s,int n)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][0]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=(log(n)/log(2))+1;j++)&#123;</span><br><span class="line">            for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)&#123;</span><br><span class="line">                dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ask(int x,int y)&#123;</span><br><span class="line">        int p=(log(y-x+1)/log(2));</span><br><span class="line">        int Min=min(dp[x][p],dp[y-(1&lt;&lt;p)+1][p]);</span><br><span class="line">        return Min;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;st;</span><br><span class="line">struct SA &#123;</span><br><span class="line">    int rnk[N],sa[N],tme[N],sec[N],height[N],n,sigma;</span><br><span class="line">    void Sort() &#123;</span><br><span class="line">        for(int i=0; i&lt;=sigma; i++)tme[i]=0;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)tme[rnk[i]]++;</span><br><span class="line">        for(int i=1; i&lt;=sigma; i++)tme[i]+=tme[i-1];</span><br><span class="line">        for(int i=n; i&gt;=1; i--)sa[tme[rnk[sec[i]]]--]=sec[i];</span><br><span class="line">        memset(sec,0,sizeof(sec));</span><br><span class="line">    &#125;</span><br><span class="line">    void GetSa(int *s) &#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)rnk[i]=s[i],sec[i]=i;</span><br><span class="line">        Sort();</span><br><span class="line">        for(int w=1,p=0; w&lt;=n&amp;&amp;p&lt;n; w&lt;&lt;=1,sigma=p) &#123;</span><br><span class="line">            p=0;</span><br><span class="line">            for(int i=n-w+1; i&lt;=n; i++)sec[++p]=i;</span><br><span class="line">            for(int i=1; i&lt;=n; i++)if(sa[i]&gt;w)sec[++p]=sa[i]-w;</span><br><span class="line">            Sort();</span><br><span class="line">            swap(sec,rnk);</span><br><span class="line">            rnk[sa[1]]=p=1;</span><br><span class="line">            for(int i=2; i&lt;=n; i++) &#123;</span><br><span class="line">                rnk[sa[i]]=(sec[sa[i-1]]==sec[sa[i]]&amp;&amp;sec[sa[i-1]+w]==sec[sa[i]+w])?  p:++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void GetHeight(int *s) &#123;</span><br><span class="line">        int k=0;</span><br><span class="line">        for(int i=1; i&lt;=n; i++) &#123;</span><br><span class="line">            if(k)k--;</span><br><span class="line">            int j=sa[rnk[i]-1];</span><br><span class="line">            while(s[i+k]==s[j+k])k++;</span><br><span class="line">            height[rnk[i]]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLcp(int l,int r)&#123;</span><br><span class="line">        if(l&gt;r)&#123;</span><br><span class="line">            int t=r;</span><br><span class="line">            r=l;</span><br><span class="line">            l=t;</span><br><span class="line">        &#125;</span><br><span class="line">        int x=min(rnk[l],rnk[r]);</span><br><span class="line">        int y=max(rnk[l],rnk[r]);</span><br><span class="line">        //cout&lt;&lt;x+1&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">        return st.ask(x+1,y);</span><br><span class="line">    &#125;</span><br><span class="line">    int init(int *s,int len) &#123;</span><br><span class="line">        sigma=N-5;</span><br><span class="line">        n=len;</span><br><span class="line">        GetSa(s);</span><br><span class="line">        GetHeight(s);</span><br><span class="line">        st.get(height,n);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sa;</span><br><span class="line">/*————————————————</span><br><span class="line">版权声明：本文为CSDN博主「YuckXi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/tomyking2005/article/details/90105343</span><br><span class="line">————————————————*/</span><br><span class="line"></span><br><span class="line">I int Q(CI l,CI r)&#123;if(l&gt;r) return 2e9;RI k=lg[r-l+1];return min(F[l][k],F[r-(1&lt;&lt;k)+1][k]);&#125;</span><br><span class="line">I int GetL(CI x,CI L)&#123;RI l=1,r=x,mid,X=x;W(l&lt;=r) Q((mid=l+r&gt;&gt;1)+1,x)&gt;=L?X=mid,r=mid-1:l=mid+1;return X;&#125;</span><br><span class="line">I int GetR(CI x,CI L)&#123;RI l=x,r=n,mid,X=x;W(l&lt;=r) Q(x+1,mid=l+r&gt;&gt;1)&gt;=L?X=mid,l=mid+1:r=mid-1;return X;&#125;</span><br><span class="line">I bool chk(RI x,RI y,CI mid)&#123;return (hsh[x]-1LL*hsh[x+mid]*pw[mid]%P+P)%P==(hsh[y]-1LL*hsh[y+mid]*pw[mid]%P+P)%P&amp;&amp;(hsh2[x]-1LL*hsh2[x+mid]*pw2[mid]%P+P)%P==(hsh2[y]-1LL*hsh2[y+mid]*pw2[mid]%P+P)%P;&#125;</span><br><span class="line">I int LCP(CI x,CI y)&#123;if(!x!ya[x]^a[y]) return 0;RI l=0,r=n-max(x,y)+1,mid,X=1;W(l&lt;=r) chk(x,y,mid=l+r&gt;&gt;1)?X=mid,l=mid+1:r=mid-1;return X;&#125;</span><br><span class="line">I int Get(CI x,CI y)&#123;RI i=0,xi,yi,tx,ty,t,A=0;for(xi=x,yi=y;xi&lt;=n&amp;&amp;yi&lt;=n;++A,i++,xi=tx+1,yi=ty+1) if(tx=i&lt;G[x].size()?G[x][i]:n+1,ty=i&lt;G[y].size()?G[y][i]:n+1,t=sa.getLcp(xi,yi),t&lt;min(tx-xi,ty-yi)) return A+t;else if(A+=min(tx-xi,ty-yi),(ty-yi)^(tx-xi)tx&gt;nty&gt;n) return A;return A;&#125;</span><br><span class="line">I bool cmp(CI x,CI y)&#123;RI i,t=Get(x,y),tx=x+t&lt;=n?a[x+t]:-1,ty=y+t&lt;=n?a[y+t]:-1;for(auto i:G[x]) i==x+t&amp;&amp;(tx=0);for(auto i:G[y]) i==y+t&amp;&amp;(ty=0);return tx&lt;ty;&#125;</span><br><span class="line">I int Qry(RI x,CI L)&#123;return GetR(p[x],L)-GetL(p[x],L)+1;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;similar.in&quot;,&quot;r&quot;,stdin),freopen(&quot;similar.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,x,y,lst=0;for(read(n,q),scanf(&quot;%s&quot;,s+1),pw[0]=pw2[0]=i=1;i&lt;=n;i++) a[i]=v[s[i]-&#x27;0&#x27;]?i-v[s[i]-&#x27;0&#x27;]:0,v[s[i]-&#x27;0&#x27;]=i,pw[i]=1LL*pw[i-1]*base%P,pw2[i]=1LL*pw2[i-1]*base2%P;</span><br><span class="line">    for(i=n;i;i--) hsh[i]=(1LL*hsh[i+1]*base%P+a[i])%P,hsh2[i]=(1LL*hsh2[i+1]*base2%P+a[i])%P;for(i=n;i;i--)&#123;for(j=0;j&lt;=9;j++) H[i][j]=H[i+1][j];H[i][s[i]-&#x27;0&#x27;]=i;for(j=0;j&lt;=9;j++) H[i][j]&amp;&amp;(G[i].pb(H[i][j]),0);sort(G[i].begin(),G[i].end());&#125;</span><br><span class="line"></span><br><span class="line">    sa.init(a,n);</span><br><span class="line"></span><br><span class="line">    for(i=1;i&lt;=n;i++) rk[i]=i;for(stable_sort(rk+1,rk+n+1,cmp),i=1;i&lt;=n;i++) p[rk[i]]=i;</span><br><span class="line">    for(lg[0]=-1,i=1;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;1]+1,F[i][0]=Get(rk[i-1],rk[i]);for(j=1;(1&lt;&lt;j)&lt;=n;j++) for(i=2;i+(1&lt;&lt;j)-1&lt;=n;i++) F[i][j]=min(F[i][j-1],F[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">    W(q--) read(x,y),x^=lst,y^=lst,writeln(lst=Qry(x,y-x+1));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> hash </tag>
            
            <tag> LCP </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 504「插头 dp」方格填写</title>
      <link href="/2022/02/06/ybtoj-504-%E3%80%8C%E6%8F%92%E5%A4%B4-dp%E3%80%8D%E6%96%B9%E6%A0%BC%E5%A1%AB%E5%86%99/"/>
      <url>/2022/02/06/ybtoj-504-%E3%80%8C%E6%8F%92%E5%A4%B4-dp%E3%80%8D%E6%96%B9%E6%A0%BC%E5%A1%AB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/504">YbtOJ #504</a></p></blockquote><p>小 A 有一个 $n\times m$ 的网格图，其中一些格子中填有 $0\sim 4$ 中的某个数字，其余格子填着 $-1$。</p><p>定义一种方格填写方案 $X$ 为 <strong>将所有 $-1$ 分别替换为 $0\sim 4$ 中的某个数</strong>。两种填写方案不同当且仅当存在至少一个格子填入的数不同。</p><p>然后，定义一种填写方案 $X$ 的权值 $f(X)$ 为 <strong>在相邻网格（上、下、左、右）之间连边（一对网格之间至多连一条边），使得每个网格连出的边数与其中填写的数字恰好相同</strong> 的连边方案数。</p><p>小 A 希望你对于所有可能的填写方案 $X$，求出 $f(X)^2$ 的总和。（向 $998244353$ 取模）</p><p>$T&#x3D;10$，$1\le n\le70$，$1\le m\le 6$。</p><p><strong>空间限制：</strong>$\texttt{32MB}$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于 $f(X)^2$ 的计数问题有一个常见转化。</p><p>$f(X)^2$ 可以视作 $f(X)\times f(X)$，也就是在所有 <strong>填写方案相同</strong> 的情况中，依次选出 <strong>两种连边方案的</strong> 方案数。</p><p>所以只要求出 <strong>同时考虑两种连边方案，满足它们的填写方案相同</strong> 的方案数。</p><p>考虑插头 DP。</p><p>$f_{i,j,p,q}$ 表示DP 到格子 $(i,j)$，两种连边方案的状压表示分别为 $p,q$ 的方案数。</p><p>对于一种连边方案，它的状压表示包括 <strong>最后 $m$ 个格子中每个格子是否向下连边</strong> 以及 <strong>这个格子是否向右连边</strong>，共 $m+1$ 位信息。</p><p>转移时先枚举前一个格子的状态，然后枚举这一位填写的数。</p><p>最好预处理一些信息优化转移，例如对每种连边方案预处理出在当前格子填每种数时可能的后继状态。</p><p>另外，注意数组要滚存。</p><p><img src="https://s2.loli.net/2022/02/06/M42CZs5FRNXjIar.png" alt="1.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;RI f=1;W(!isdigit(oc=tc())) f=oc^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x);W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=75,M=8,P=998244353;</span><br><span class="line">int T,n,m,a[N][M],Ans,dp[2][(1&lt;&lt;7)+5][(1&lt;&lt;7)+5],C;</span><br><span class="line">I void go(int&amp; x,CI y)&#123;(x+=y)&gt;=P&amp;&amp;(x-=P,0);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;grid.in&quot;,&quot;r&quot;,stdin),freopen(&quot;grid.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,k,s1,s2,t1,t2,o1,o2,p,S=0;read(T);W(T--)&#123;</span><br><span class="line">        for(read(n,m),C=(1&lt;&lt;m+1),i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) read(a[i][j]);</span><br><span class="line">        for(memset(dp,0,sizeof(dp)),dp[S=0][0][0]=1,i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) for(S^=1,memset(dp[S],0,sizeof(dp[S])),k=(~a[i][j]?a[i][j]:0);k&lt;=(~a[i][j]?a[i][j]:4);k++)</span><br><span class="line">        for(s1=0;s1&lt;C;s1++) if(p=k-(s1&amp;1)-(s1&gt;&gt;j&amp;1),0&lt;=p&amp;&amp;p&lt;=2) for(t1=t2=s1&amp;(C-2)&amp;(C-(1&lt;&lt;j)-1),!p?t2=C:p&amp;1?t1^=1,t2^=1&lt;&lt;j:(t1^=1+(1&lt;&lt;j),t2=C),s2=0;s2&lt;C;s2++) if(j&gt;1(!(s1&amp;1)&amp;&amp;!(s2&amp;1)))</span><br><span class="line">        if(p=k-(s2&amp;1)-(s2&gt;&gt;j&amp;1),0&lt;=p&amp;&amp;p&lt;=2) o1=o2=s2&amp;(C-2)&amp;(C-(1&lt;&lt;j)-1),!p?o2=C:p&amp;1?o1^=1,o2^=1&lt;&lt;j:(o1^=1+(1&lt;&lt;j),o2=C),t1&lt;C&amp;&amp;o1&lt;C&amp;&amp;(go(dp[S][t1][o1],dp[S^1][s1][s2]),0),t1&lt;C&amp;&amp;o2&lt;C&amp;&amp;(go(dp[S][t1][o2],dp[S^1][s1][s2]),0),t2&lt;C&amp;&amp;o1&lt;C&amp;&amp;(go(dp[S][t2][o1],dp[S^1][s1][s2]),0),t2&lt;C&amp;&amp;o2&lt;C&amp;&amp;(go(dp[S][t2][o2],dp[S^1][s1][s2]),0);</span><br><span class="line">        writeln(dp[S][0][0]);</span><br><span class="line">    &#125;return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 插头dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 755「分治」变量观测</title>
      <link href="/2022/02/06/ybtoj-755-%E3%80%8C%E5%88%86%E6%B2%BB%E3%80%8D%E5%8F%98%E9%87%8F%E8%A7%82%E6%B5%8B/"/>
      <url>/2022/02/06/ybtoj-755-%E3%80%8C%E5%88%86%E6%B2%BB%E3%80%8D%E5%8F%98%E9%87%8F%E8%A7%82%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/problem/755">YbtOJ #755</a></p></blockquote><p>小 A 有 $n$ 个变量，分别为 $x_{1\sim n}$。</p><p>接下来依次发生了 $q$ 次事件，分为两种形式：</p><ul><li><code>1 t k q[1] q[2] ... q[k]</code>：假设这是第 $p$ 次 $1$ 操作，则设置一个编号为 $p$ 的观测员，直到 $x_{q_1},x_{q_2},\cdots x_{q_k}$ 与当前相比变化总值大于等于 $t$ 时结束观测。（保证同一个观测员的 $q_{1\sim k}$ 各不相同）</li><li><code>2 i v</code>：给 $x_i$ 加上 $v$。你需要输出所有在这次操作结束观测的观测员编号。</li></ul><p><strong>强制在线</strong>。</p><p>$n,m \le 2\times10^5$，$1\le k\le3$，$1\le t,v\le10^6$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑将每个人观测时间分为 $k$ 份，每份 $\lceil \frac tk \rceil$，丢到每个变量对应的 set 里。</p><p>显然变化量大于等于 $t$ 的必要条件是需要有一个变量的变化值超过 $\lceil \frac tk \rceil$。</p><p>这样每个变量增加的时候不断从 set 里取出，然后扫一遍其他变量的变化值，如果达到则从 set 中删去，如果没达到则在此基础上重新计算一遍重新分一遍。</p><p>由于 $k\leq 3$，那么某一份到达则剩余值不超过原先值得 $\frac 23$。</p><p>那么每个观察员最多进行 $\log_{1.5}V$ 次操作。</p><p>时间复杂度看着就能过反正。</p><p>反正人傻常数大，跑的最慢。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e5+10;</span><br><span class="line">int n,q,cp,b[N],g[N][4];</span><br><span class="line">struct node&#123;vector&lt;int&gt; q;int t;&#125;a[N];</span><br><span class="line">vector&lt;int&gt; A;</span><br><span class="line">#define pb push_back</span><br><span class="line">struct PA&#123;int v,p;&#125;;</span><br><span class="line">I bool operator &lt; (Cn PA&amp; A,Cn PA&amp; B)&#123;return A.v^B.v?A.v&lt;B.v:A.p&lt;B.p;&#125;</span><br><span class="line">#define MP(x,y) ((PA)&#123;x,y&#125;)</span><br><span class="line">multiset&lt;PA&gt; s[N];</span><br><span class="line">#define div(x,y) ((x)/(y)+((x)%(y)&gt;0))</span><br><span class="line">I void Add(CI id,CI t,CI k,CI p)&#123;</span><br><span class="line">    RI i,x;for(a[id].q.clear(),i=1;i&lt;=k;i++) read(x),x^=p,a[id].q.pb(x);a[id].t=t;</span><br><span class="line">    for(i=1;i&lt;=k;i++) s[a[id].q[i-1]].insert(MP(div(t,k)+(g[id][i]=b[a[id].q[i-1]]),id));</span><br><span class="line">&#125;</span><br><span class="line">I int Sol(CI i,CI v)&#123;</span><br><span class="line">    A.clear(),b[i]+=v;W(!s[i].empty()&amp;&amp;(*s[i].begin()).v&lt;=b[i])&#123;</span><br><span class="line">        PA u=*s[i].begin();RI S=0;</span><br><span class="line">        for(RI sz=a[u.p].q.size(),j=0;j&lt;sz;j++) S+=b[a[u.p].q[j]]-g[u.p][j+1],assert(b[a[u.p].q[j]]&gt;=g[u.p][j+1]),s[a[u.p].q[j]].erase(s[a[u.p].q[j]].find(MP(div(a[u.p].t,sz)+g[u.p][j+1],u.p)));</span><br><span class="line">        if(S&gt;=a[u.p].t)&#123;A.pb(u.p);continue ;&#125;a[u.p].t-=S;</span><br><span class="line">        for(RI sz=a[u.p].q.size(),j=0;j&lt;sz;j++) s[a[u.p].q[j]].insert(MP(div(a[u.p].t,sz)+(g[u.p][j+1]=b[a[u.p].q[j]]),u.p));</span><br><span class="line">    &#125;write(A.size()),pc(&#x27; &#x27;),sort(A.begin(),A.end());for(auto i:A) write(i),pc(&#x27; &#x27;);pc(&#x27;\n&#x27;);return A.size();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;obs.in&quot;,&quot;r&quot;,stdin),freopen(&quot;obs.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,op,x,y,p=0;for(read(n,q),i=1;i&lt;=q;i++) read(op,x,y),x^=p,op&amp;1?Add(++cp,x,y,p):(y^=p,p=Sol(x,y),void());return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ</title>
      <link href="/2022/01/29/uoj-671-%E3%80%90unr-5%E3%80%91%E8%AF%A1%E5%BC%82%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/01/29/uoj-671-%E3%80%90unr-5%E3%80%91%E8%AF%A1%E5%BC%82%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://uoj.ac/problem/671">UOJ #671</a></p></blockquote><p>给定一个长度为 $n$ 的序列 $a_{1\sim n}$，有 $q$ 个操作：</p><ul><li><code>1 l r v</code>，将区间 $[l,r]$ 每个元素 $\lfloor \frac {a_i} v \rfloor $，这里保证 $v_i\ge 1$。</li><li><code>2 l r v</code>，将区间 $[l,r]$ 每个元素 $a_i \&amp; v$。</li><li><code>3 l r</code>，求 $\sum\limits_{i&#x3D;l}^r a_i$。</li></ul><p>$n\leq 3\times 10^5,q\leq 2\times 10^5,0\leq v_i,a_i\leq 2^{128}$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="1-朴素做法"><a href="#1-朴素做法" class="headerlink" title="1 朴素做法"></a>1 朴素做法</h3><p>容易发现操作 $1,2$ 只会使 $a_i$ 变小，若忽略掉操作 $1$ 中 $v&#x3D;1$ 的操作，在 $O(\log a_i)$ 次除法操作后即变为 $0$。</p><p>区间与操作，每一位分别维护，$v$ 为 $0$ 的位全部清零。</p><p>时间复杂度：$O(n\log ^2 V+q\log n\log V)$。</p><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2 优化"></a>2 优化</h3><p>朴素做法在线段树的节点上维护的是每一位的 $1$ 的个数，显然其权值若看作二进制数，位数不超过 $\log n$。</p><p>那么我们可以将其反转一下，转为维护每一位答案在二进制下第 $i$ 位的值，这样每个数维护的即为自身，不需要 $O(\log V)$ 的时间来自我分解，另外维护的为 $O(\log n)$ 个变量，比 $O(\log V)$ 少，询问的时候只需要求 $\sum s_i\times 2^i$ 即可。</p><p>时间复杂度：$O(n\log V+q\log^2 n)$。</p><p>合并上传信息的时候只需要手动模拟一下二进制加法即可。</p><h3 id="3-吐槽"><a href="#3-吐槽" class="headerlink" title="3 吐槽"></a>3 吐槽</h3><p>卡常卡半天，加了个 Ofast 就跑过去了》</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">Cn int N=6e5+10;</span><br><span class="line">int n,m,q; </span><br><span class="line">typedef __uint128_t u128;</span><br><span class="line">u128 a[N];</span><br><span class="line">inline u128 read() &#123;</span><br><span class="line">    static char buf[100];</span><br><span class="line">    scanf(&quot;%s&quot;, buf);</span><br><span class="line">    u128 res = 0;for(int i = 0;buf[i];++i) res = res &lt;&lt; 4  (buf[i] &lt;= &#x27;9&#x27; ? buf[i] - &#x27;0&#x27; : buf[i] - &#x27;a&#x27; + 10);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">inline void output(u128 res) &#123;</span><br><span class="line">    if(res &gt;= 16) output(res / 16);</span><br><span class="line">    putchar(res % 16 &gt;= 10 ? &#x27;a&#x27; + res % 16 - 10 : &#x27;0&#x27; + res % 16);</span><br><span class="line">&#125;</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        vector&lt;u128&gt; T[N&lt;&lt;2];</span><br><span class="line">        #define pb push_back</span><br><span class="line">        u128 tg[N&lt;&lt;2];bool v[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        I void PU(CI x)&#123;</span><br><span class="line">            v[x]=v[x&lt;&lt;1]v[x&lt;&lt;11];u128 tmp=0;RI i,lg;for(i=0,lg=T[x&lt;&lt;1].size();i&lt;lg;i++) T[x][i]=T[x&lt;&lt;1][i]^T[x&lt;&lt;11][i]^tmp,</span><br><span class="line">            tmp=(T[x&lt;&lt;1][i]&amp;T[x&lt;&lt;11][i])(T[x&lt;&lt;1][i]&amp;tmp)(T[x&lt;&lt;11][i]&amp;tmp);T[x][lg]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        I void C(CI x,u128 v)&#123;for(auto &amp;i:T[x]) i&amp;=v;tg[x]&amp;=v;&#125;</span><br><span class="line">        I void PD(CI x)&#123;~tg[x]&amp;&amp;(C(x&lt;&lt;1,tg[x]),C(x&lt;&lt;11,tg[x]),tg[x]=~0);&#125;</span><br><span class="line">        I u128 G(CI x)&#123;u128 S=0;for(RI i=0,lg=T[x].size();i&lt;lg;i++) S+=T[x][i]&lt;&lt;i;return S;&#125;</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(tg[x]=~0,l==r) return T[x].pb(a[l]),v[x]=a[l]&gt;0,void();</span><br><span class="line">            B(LT),B(RT),T[x].resize(T[x&lt;&lt;1].size()+1),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void A(CI L,CI R,u128 tv,PT)&#123;</span><br><span class="line">            if(!v[x]) return ;if(L&lt;=l&amp;&amp;r&lt;=R) return C(x,tv);</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(A(L,R,tv,LT),0),R&gt;mid&amp;&amp;(A(L,R,tv,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void D(CI L,CI R,u128 tv,PT)&#123;</span><br><span class="line">            if(!v[x]) return ;if(l==r) return v[x]=(T[x][0]/=tv)&gt;0,void();</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(D(L,R,tv,LT),0),R&gt;mid&amp;&amp;(D(L,R,tv,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I u128 Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return G(x);</span><br><span class="line">            u128 S=0;return PD(x),L&lt;=mid&amp;&amp;(S+=Q(L,R,LT),0),R&gt;mid&amp;&amp;(S+=Q(L,R,RT),0),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">    u128 v;RI i,op,l,r;for(scanf(&quot;%d%d&quot;,&amp;n,&amp;q),i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    for(m=n,n=1;n&lt;m;n&lt;&lt;=1);for(T.B(),i=1;i&lt;=q;i++) scanf(&quot;%d%d%d&quot;,&amp;op,&amp;l,&amp;r),op^3&amp;&amp;(v=read(),0),op==1&amp;&amp;v&gt;1&amp;&amp;(T.D(l,r,v),0),</span><br><span class="line">    op==2?T.A(l,r,v),0:op==3&amp;&amp;(output(T.Q(l,r)),pc(&#x27;\n&#x27;),0);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1129D Isolation</title>
      <link href="/2022/01/29/cf1129d-isolation/"/>
      <url>/2022/01/29/cf1129d-isolation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/contest/1129/problem/D">CF1129D</a></p></blockquote><p>给定一个长度为 $n$ 的序列 $a_{1\sim n}$，把它分割成若干段，使得每段出现过<strong>恰好一次</strong>的元素个数 $\leq k$，求方案数对 $998244353$ 取模的结果。</p><p>$1\leq k\leq n \leq 10^5,1\leq a_i\leq n$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="1-朴素-DP"><a href="#1-朴素-DP" class="headerlink" title="1 朴素 DP"></a>1 朴素 DP</h3><p>不妨设 $f_i$ 表示前 $i$ 个数的答案，设 $s_j$ 为 $a[j+1\dots i]$ 出现过<strong>恰好一次</strong>的元素个数，显然有：<br>$$<br>f_i&#x3D;\sum_{s_j\leq k} f_j<br>$$<br>时间复杂度 $O(n^2)$，显然不能接受。</p><h3 id="2-分块优化"><a href="#2-分块优化" class="headerlink" title="2 分块优化"></a>2 分块优化</h3><p>考虑按顺序加入每个数字，会使 $\forall j\in[p_{p_i},p_i-1]$ 所有 $s_j$ 减 $1$，$\forall j \in [p_i,i-1]$ 所有 $s_j$ 加 $1$。</p><p>那么我们现在的问题就转化为两类操作：</p><ol><li>区间 $\pm 1$</li><li>求所有权值 $\leq k$ 的 $f$ 值之和。</li><li>单点修改 $f$ 值。</li></ol><p>显然这个东西不太可能做到 $\text{polylog}$，那么考虑分块。</p><p>只需要每个块开个桶记录一下每个 $s$ 的 $f$ 之和，操作 $1$ 只需要打个 $tag$ 然后维护一下答案即可。</p><p>时间复杂度 $O(n\sqrt n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=sqrt(N)+10,X=998244353;</span><br><span class="line">int n,S,K,p[N],v[N],bl[N],L[N],R[N],tot,s[N],tg[M],f[N],g[M][N&lt;&lt;1],Ans;</span><br><span class="line">I void cL(CI k)&#123;RI i;for(i=L[k];i&lt;=R[k];i++) g[k][s[i]+N]=0,s[i]+tg[k]&lt;=K&amp;&amp;(Ans-=f[i],Ans%=X);&#125;</span><br><span class="line">I void rB(CI k)&#123;RI i;for(i=L[k];i&lt;=R[k];i++) (g[k][s[i]+N]+=f[i])%=X,s[i]+tg[k]&lt;=K&amp;&amp;(Ans+=f[i],Ans%=X);&#125;</span><br><span class="line">I void UF(CI l,CI r,CI v)&#123;RI i;cL(bl[l]);for(i=l;i&lt;=r;i++) s[i]+=v;rB(bl[l]);&#125;</span><br><span class="line">I void UB(CI l,CI r,CI v)&#123;RI i;for(i=l;i&lt;=r;i++) v&lt;0?Ans+=g[i][K+1-tg[i]+N]:Ans-=g[i][K-tg[i]+N],Ans%=X,tg[i]+=v;&#125;</span><br><span class="line">I void U(CI l,CI r,CI v)&#123;RI bL=bl[l],bR=bl[r];if(bL==bR) return UF(l,r,v);return bL+1&lt;=bR-1&amp;&amp;(UB(bL+1,bR-1,v),0),UF(l,R[bL],v),UF(L[bR],r,v);&#125;</span><br><span class="line">I void A(CI p,CI v)&#123;if(f[p]=Ans,Ans+=f[p],Ans%=X,R[bl[p]]==p) cL(bl[p]),rB(bl[p]);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x;for(read(n,K),S=sqrt(n),i=1;i&lt;=n;i++) bl[i]=(i-1)/S+1,!((i-1)%S)&amp;&amp;(R[tot]=i-1,L[++tot]=i);R[tot]=n;</span><br><span class="line">    for(f[0]=Ans=1,i=1;i&lt;=n;i++) read(x),p[i]=v[x],p[i]&lt;=i-1&amp;&amp;(U(p[i],i-1,1),p[p[i]]&lt;=p[i]-1&amp;&amp;(U(p[p[i]],p[i]-1,-1),0)),v[x]=i,A(i,Ans);</span><br><span class="line">    return writeln((f[n]+X)%X),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二项式系数 Binomial Coefficients</title>
      <link href="/2021/12/02/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0-binomial-coefficients/"/>
      <url>/2021/12/02/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0-binomial-coefficients/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-基本恒等式-Basic-Identities"><a href="#1-1-基本恒等式-Basic-Identities" class="headerlink" title="1.1 基本恒等式 Basic Identities"></a>1.1 基本恒等式 Basic Identities</h2><h3 id="1-1-1-定义-Definition"><a href="#1-1-1-定义-Definition" class="headerlink" title="1.1.1 定义 Definition"></a>1.1.1 定义 Definition</h3><p>$\binom nk$ 表示二项式系数，其中 $n$ 称作上指标 (upper index)，而称 $k$ 为下指标 (lower index)。</p><p>$$<br>\binom rk&#x3D;<br>\begin{cases}<br>\frac{r^{\underline{k}}}{k!} ,&amp; k\ge0\\<br>0, &amp; k&lt;0<br>\end{cases}</p><p>\quad (k\in \Z)<br>$$</p><h3 id="1-1-2-对称恒等式-Symmetric-Identity"><a href="#1-1-2-对称恒等式-Symmetric-Identity" class="headerlink" title="1.1.2 对称恒等式 Symmetric Identity"></a>1.1.2 对称恒等式 Symmetric Identity</h3><p>$$<br>\binom nk&#x3D;\binom n{n-k}\quad n\in \N<br>$$</p><p>证明：<br>$$<br>\binom nk&#x3D;\frac{n!}{k!(n-k)!}&#x3D;\frac{n!}{(n-(n-k))!(n-k)!}&#x3D;\binom n{n-k}<br>$$</p><h3 id="1-1-3-吸收恒等式-Absorption-Identity"><a href="#1-1-3-吸收恒等式-Absorption-Identity" class="headerlink" title="1.1.3 吸收恒等式 Absorption Identity"></a>1.1.3 吸收恒等式 Absorption Identity</h3><p>$$<br>\binom rk&#x3D;\frac rk\binom {r-1}{k-1}<br>$$</p><p>证明：</p><ol><li>$k&gt; 0$<br>$$<br>\binom rk&#x3D;\frac{r^{\underline k}}{k!}&#x3D;\frac{r{(r-1)}^{\underline {k-1}}}{k(k-1)!}&#x3D;\frac rk\binom {r-1}{k-1}<br>$$</li><li>$k&lt;0$</li></ol><p>$$<br>\binom rk &#x3D; 0 &#x3D; \binom {r-1}{k-1}<br>$$</p><h3 id="1-1-3-相伴恒等式-Companion-Identity"><a href="#1-1-3-相伴恒等式-Companion-Identity" class="headerlink" title="1.1.3+ 相伴恒等式 Companion Identity"></a>1.1.3+ 相伴恒等式 Companion Identity</h3><p>$$<br>(r-k)\binom rk&#x3D;r\binom {r-1}k<br>$$</p><p>证明：<br>$$<br>\begin{aligned}<br>(r-k)\binom rk &amp; &#x3D;(r-k)\binom r {r-k}\\<br>&amp; &#x3D; r\binom {r-1}{r-k-1}\\<br>&amp; &#x3D; r\binom {r-1}k<br>\end{aligned}<br>$$<br>容易发现上述证明过程仅当 $r\in \Z$ 时成立，但其实相伴恒等式对于所有 $r\in \R$ 均成立。具体证明需要用到多项式推理法。</p><h3 id="1-1-4-加法公式-Addition-Formula"><a href="#1-1-4-加法公式-Addition-Formula" class="headerlink" title="1.1.4 加法公式 Addition Formula"></a>1.1.4 加法公式 Addition Formula</h3><p>$$<br>\binom rk &#x3D; \binom {r-1}k+\binom {r-1}{k-1}<br>$$</p><p>证明：<br>$$<br>r\binom rk&#x3D;(r-k)\binom rk +k\binom rk&#x3D;r\binom {r-1}k+r\binom {r-1}{k-1}<br>$$</p><h3 id="1-1-5-上指标求和-Summation-of-Upper-Indicators"><a href="#1-1-5-上指标求和-Summation-of-Upper-Indicators" class="headerlink" title="1.1.5 上指标求和 Summation of Upper Indicators"></a>1.1.5 上指标求和 Summation of Upper Indicators</h3><p>$$<br>\begin{align}<br>\sum_{0\leq k\leq n}\binom km &#x3D;\binom{n+1}{m+1}\quad m,n\in \N \tag1<br>\end{align}<br>$$</p><p>证明：</p><p>利用数学归纳法。</p><p>$n&#x3D;0$ 时，左边 $&#x3D;\binom 0m&#x3D;[m&#x3D;0]&#x3D;\binom 1{m+1}&#x3D;$ 右边</p><p>设 $n&#x3D;N \ (N\in \N_+)$ 时 $(1)$ 成立，那么 $n&#x3D;N+1$ 时，<br>$$<br>\begin{aligned}<br>\sum_{0\leq k\leq n+1}\binom km &amp; &#x3D;\sum_{0\leq k\leq n}\binom km+\binom {n+1}m\\<br>&amp; &#x3D; \binom {n+1}{m+1} +\binom {n+1}m\\<br>&amp; &#x3D; \binom {n+2}{m+1}<br>\end{aligned}<br>$$</p><p>所以对一切 $n\in \N$，$(1)$ 成立。</p><h3 id="1-1-6-平行求和法-Parallel-Summation"><a href="#1-1-6-平行求和法-Parallel-Summation" class="headerlink" title="1.1.6 平行求和法 Parallel Summation"></a>1.1.6 平行求和法 Parallel Summation</h3><p>$$<br>\sum_{k\leq n}\binom {r+k}k&#x3D;\binom{r+n+1}n \quad n\in \Z<br>$$</p><p>证明：<br>$$<br>\begin{aligned}<br>\sum_{k\leq n}\binom {m+k}k &amp; &#x3D;\sum_{-m\leq k\leq n}\binom {m+k}k\\<br>&amp; &#x3D; \sum_{-m\leq k\leq n}\binom {m+k}m\\<br>&amp; &#x3D; \sum_{0\leq k\leq m+n}\binom km\\<br>&amp; &#x3D; \binom {m+n+1}{m+1}<br>\end{aligned}<br>$$</p><p>注意到以上证明当且仅当 $m+k\ge 0$ 才可以这么做（第二行运用到对称法则），因此我们在第一步去掉了 $k&lt;-m$ 的项。</p><h3 id="1-1-7-上指标反转-Upper-Negation"><a href="#1-1-7-上指标反转-Upper-Negation" class="headerlink" title="1.1.7 上指标反转 Upper Negation"></a>1.1.7 上指标反转 Upper Negation</h3><p>$$<br>\binom rk&#x3D;(-1)^k \binom {k-r-1}k \quad k\in \Z<br>$$</p><p>证明：</p><ol><li>$k\ge 0$<br>$$<br>\binom rk&#x3D;\frac{r^{\underline k}}{k!}&#x3D;\frac{(-1)^k (-r)(1-r)\cdots (k-1-r)}{k!}&#x3D;\frac {(-1)^k(k-r-1)^{\underline k}}{k!}&#x3D;(-1)^k\binom {k-r-1}k<br>$$</li><li>$k&lt;0$</li></ol><p>$$<br>\binom rk &#x3D; 0 &#x3D; (-1)^k\binom {k-r-1}k<br>$$</p><h3 id="1-1-8-三项式版恒等式-Trinomial-Version-of-Identity"><a href="#1-1-8-三项式版恒等式-Trinomial-Version-of-Identity" class="headerlink" title="1.1.8 三项式版恒等式 Trinomial Version of Identity"></a>1.1.8 三项式版恒等式 Trinomial Version of Identity</h3><p>$$<br>\binom rm\binom mk&#x3D;\binom rk\binom {r-k}{m-k} \quad m,k\in \Z<br>$$</p><p>证明：</p><p>若 $r\ge m\ge k\ge 0$，<br>$$<br>\begin{aligned}<br>\binom rm\binom mk &amp; &#x3D; \frac{r!}{m!(r-m)!}\frac{m!}{k!(m-k)!} \\<br>&amp; &#x3D; \frac{r!}{k!(m-k)!(r-m)!}\\<br>&amp; &#x3D; \frac{r!}{k!(r-k)!}\frac{(r-k)!}{(m-k)!(r-m)!}\\<br>&amp; &#x3D; \binom rk \binom {r-k}{m-k}<br>\end{aligned}<br>$$</p><p>若 $m&lt;k$ 或 $k&lt;0$ 等式两边都是 $0$。</p><h3 id="1-1-9-范德蒙德卷积-Vandermonde-Convolution"><a href="#1-1-9-范德蒙德卷积-Vandermonde-Convolution" class="headerlink" title="1.1.9 范德蒙德卷积 Vandermonde Convolution"></a>1.1.9 范德蒙德卷积 Vandermonde Convolution</h3><p>$$<br>\sum_k \binom r{m+k}\binom s{n-k}&#x3D;\binom {r+s}{m+n} \quad m,n\in \Z<br>$$</p><p>证明：</p><p>这里可以暂时通过组合意义来简单证明：</p><p>先从 $r$ 个球中取 $m+k$ 个，再从 $s$ 个球中取 $n-k$ 个，就相当于在 $r+s$ 个球中取 $m+n$ 个。</p><p>具体严谨证明见下文——生成函数。</p><h3 id="1-1-10-二项式定理-Binomial-Theorem"><a href="#1-1-10-二项式定理-Binomial-Theorem" class="headerlink" title="1.1.10 二项式定理 Binomial Theorem"></a>1.1.10 二项式定理 Binomial Theorem</h3><p>$$<br>(x+y)^n&#x3D;\sum_{k&#x3D;0}^n\binom nky^kx^{n-k}\quad n\in Z_+<br>$$</p><p>特别地，</p><p>$$<br>(1+x)^n&#x3D;\sum_{k&#x3D;0}^n\binom nkx^k\quad n\in Z_+<br>$$</p><h3 id="1-1-11-其他基本组合恒等式-Other-Basic-Combination-Identities"><a href="#1-1-11-其他基本组合恒等式-Other-Basic-Combination-Identities" class="headerlink" title="1.1.11 其他基本组合恒等式 Other Basic Combination Identities"></a>1.1.11 其他基本组合恒等式 Other Basic Combination Identities</h3><p>$$<br>\sum_{k&#x3D;0}^n \binom nk&#x3D;2^n \tag 1<br>$$</p><p>$$<br>\sum_{k&#x3D;0}^n (-1)^k\binom nk&#x3D;0 \tag 2<br>$$</p><h2 id="1-2-生成函数-Generating-Function"><a href="#1-2-生成函数-Generating-Function" class="headerlink" title="1.2 生成函数 Generating Function"></a>1.2 生成函数 Generating Function</h2><h3 id="1-2-1-卷积-Convolution"><a href="#1-2-1-卷积-Convolution" class="headerlink" title="1.2.1 卷积 Convolution"></a>1.2.1 卷积 Convolution</h3><p>$$<br>c_n&#x3D;\sum_{k&#x3D;0}^na_kb_{n-k} \tag1<br>$$</p><p>由 $(1)$ 所定义的序列 $\langle c_n\rangle$ 称为序列 $\langle a_n\rangle$ 和 $\langle b_n \rangle$ 的卷积。</p><h3 id="1-2-2-二项式定理与生成函数-Binomial-Theorem-and-Generating-Function"><a href="#1-2-2-二项式定理与生成函数-Binomial-Theorem-and-Generating-Function" class="headerlink" title="1.2.2 二项式定理与生成函数 Binomial Theorem and Generating Function"></a>1.2.2 二项式定理与生成函数 Binomial Theorem and Generating Function</h3><p>$$<br>(1+z)^r&#x3D;\sum_{k\ge 0}\binom rkz^k \tag1<br>$$</p><p>类似地，</p><p>$$<br>(1+z)^s&#x3D;\sum_{k\ge 0}\binom skz^k \tag2<br>$$</p><p>将 $(1)(2)$ 相乘，我们可以得到另外一个生成函数：</p><p>$$<br>(1+z)^r(1+z)^s&#x3D;(1+z)^{r+s}<br>$$</p><p>让这个等式两边 $z^n$ 的系数相等就给出：</p><p>$$<br>\sum_{k&#x3D;0}^n\binom rk\binom s{n-k}&#x3D;\binom {r+s}n<br>$$</p><p>我们就发现了范德蒙德卷积。</p><p>此外我们还有一系列重要的恒等式：</p><p>$$<br>(1-z)^r&#x3D;\sum_{k\ge 0}(-1)^k\binom rk\tag 3<br>$$</p><p>$$<br>\frac 1{(1-z)^{n+1}}&#x3D;\sum_{k\ge 0}\binom {n+k}nz^k \quad n\in \N \tag 4<br>$$</p><p>当 $n&#x3D;0$ 时，我们就得到了 $(4)$ 的特例，即几何级数：</p><p>$$<br>\frac 1{1-z}&#x3D;1+z+z^2+z^3+\cdots &#x3D;\sum_{k\ge 0}z^k<br>$$</p><p>这就是序列 $\langle 1,1,1,\cdots \rangle$ 的生成函数。</p><h2 id="1-3-基本练习-Basic-Practice"><a href="#1-3-基本练习-Basic-Practice" class="headerlink" title="1.3 基本练习 Basic Practice"></a>1.3 基本练习 Basic Practice</h2><h3 id="1-3-1-利用基本组合恒等式-Use-Basic-Combinatorial-Identities"><a href="#1-3-1-利用基本组合恒等式-Use-Basic-Combinatorial-Identities" class="headerlink" title="1.3.1 利用基本组合恒等式 Use Basic Combinatorial Identities"></a>1.3.1 利用基本组合恒等式 Use Basic Combinatorial Identities</h3><ol><li>证明：$\sum_{k&#x3D;1}^n (-1)^{k-1}k\binom nk&#x3D;0 \ (n\ge2)$</li></ol><p>$$<br>\begin{aligned}<br>LHS &amp; &#x3D; \sum_{k&#x3D;1}^n(-1)^{k-1}n\binom {n-1}{k-1} \\<br>&amp; &#x3D; n\sum_{k}(-1)^k\binom nk\\<br>&amp; &#x3D; n\binom 0n\\<br>&amp; &#x3D; n[n&#x3D;0]\\<br>&amp; &#x3D; 0 &#x3D; RHS<br>\end{aligned}<br>$$</p><ol start="2"><li>证明：$\sum_{k&#x3D;p}^n\binom nk\binom kp&#x3D;\binom np2^{n-p}$</li></ol><p>$$<br>\begin{aligned}<br>LHS &amp; &#x3D; \sum_{k&#x3D;p}^n\binom np\binom {n-k}{k-p}\\<br>&amp; &#x3D; \binom np\sum_{k&#x3D;0}^{n-p}\binom {n-p-k}k\\<br>&amp; &#x3D; \binom np 2^{n-p} &#x3D; RHS<br>\end{aligned}<br>$$</p><h3 id="1-3-2-利用生成函数-Use-Generating-Functions"><a href="#1-3-2-利用生成函数-Use-Generating-Functions" class="headerlink" title="1.3.2 利用生成函数 Use Generating Functions"></a>1.3.2 利用生成函数 Use Generating Functions</h3><ol><li>证明：</li><li>$\sum_{k&#x3D;0}^n{\binom nk}^2&#x3D;\binom n{2n}$</li><li>$\sum_{k&#x3D;1}^{2n-1}\binom {2n}k[2 (k-1)]&#x3D;\frac 12{\binom {4n}{2n}+(-1)^{n-1}\binom {2n}n}$</li></ol><p>[collapse title&#x3D;”解答”] 1. 首先有： $$ \begin{aligned} [z^n](1+z)^{2n} &amp; &#x3D;\sum_{k&#x3D;0}^{2n}\binom {2n}kz^k\\ &amp; &#x3D;\binom {2n}n \end{aligned} $$ 注意到： $$ \begin{aligned} [z^n](1+z)^{2n} &amp; &#x3D;[z^n]((1+z)^n)^2\\ &amp; &#x3D; [z^n](\sum_{i&#x3D;0}^n\binom niz^i)\cdot (\sum_{j&#x3D;0}n\binom njz^j)\\ &amp; &#x3D;\sum_{k&#x3D;0}^n\binom nk\binom n{n-k}\\ &amp; &#x3D;\sum_{k&#x3D;0}^n{\binom nk}^2 \end{aligned} $$ 因此： $$ \sum_{k&#x3D;0}^n{\binom nk}^2&#x3D;\binom {2n}n $$ 2. 由小题 $1$ 得： $$ \sum_{k&#x3D;0}^{2n}\binom {2n}k^2&#x3D;\binom {4n}{2n}\tag1 $$ 其次： $$ \begin{aligned} [z^{2n}](1-z^2)^{2n} &amp; &#x3D;[z^{2n}]\sum_{k&#x3D;0}^{2n}(-1)^k\binom {2n}kz^{2k}\\ &amp; &#x3D;(-1)^n\binom {2n}n \end{aligned} $$ 注意到： $$ \begin{aligned} [z^{2n}](1-z^2)^{2n} &amp; &#x3D;(1-z)^{2n}(1+z)^{2n}\\ &amp; &#x3D; [z^{2n}](\sum_{k&#x3D;0}^{2n}(-1)^k\binom {2n}kz^k)(\sum_{j&#x3D;0}^{2n}\binom {2n}jz^j)\\ &amp; &#x3D; \sum_{k&#x3D;0}^{2n}(-1)^k\binom {2n}k\binom {2n}{2n-k}\\ &amp; &#x3D; \sum_{k&#x3D;0}^{2n}(-1)^k\binom {2n}k^2 \end{aligned} $$ 所以有： $$ (-1)^n\binom {2n}n&#x3D;\sum_{k&#x3D;0}^{2n}(-1)^k\binom {2n}k^2 \tag 2 $$ 由 $((1)-(2))\div 2$ 得： $$ \sum_{k&#x3D;1}^n\binom {2n}{2k-1}^2&#x3D;\frac 12\{\binom {4n}{2n}+(-1)^{n-1}\binom {2n}n\} $$ [&#x2F;collapse]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卷积 </tag>
            
            <tag> 二项式定理 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ List</title>
      <link href="/2021/11/23/poj-list/"/>
      <url>/2021/11/23/poj-list/</url>
      
        <content type="html"><![CDATA[<p>为了不再被虐，我力争学会…</p><p>助你早日成为信息学奥赛<strong>斗</strong>士</p><p> <a href="https://github.com/" title="Github">GitHub</a></p><p><a href="https://github.com/yzxoi/POJ">yzxoi&#x2F;POJ</a></p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF377D Developing Game</title>
      <link href="/2021/11/12/cf377d-developing-game/"/>
      <url>/2021/11/12/cf377d-developing-game/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/CF377D">题目链接</a></p></blockquote><p>有 $n$ 个工人，第 $i$ 个工人的能力是 $v_i$,他只与能力在 $l_i$ ​到 $r_i$ 之间的人在一起工作，问最多能选出多少人一起工作并输出方案。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>如果我们选了一个集合 $\mathcal{S}$ 合法，则必有：</p><p>$$<br>\max_{i\in \mathcal{S}}l_i\le \min_{i\in \mathcal{S}}v_i\le\max_{i\in \mathcal{S}}v_i\le\min_{i\in \mathcal{S}}r_i<br>$$<br>$\max\limits_{i\in \mathcal{S}} l_i\leq \min\limits_{i\in \mathcal{S}} v_i$，可以看做是所有 $[l_i,v_i]$ 的线段有共同覆盖的地方。对 $\max\limits_{i\in \mathcal{S}} v_i\leq \min\limits_{i\in \mathcal{S}} r_i$ 也是同理。因此，我们把一个工人 $l_i,v_i,r_i$，看作是一个矩形，左下角为 $(l_i,v_i)$ 右上角为 $(v_i,r_i)$，那么上式就可以看做是这 $\mathcal{S}$ 个矩形有公共部分。</p><p>对于一个矩形，我们可以通过差分在 $x&#x3D;l_i$ 时将 $[v_i,r_i]$ 的次数加一，在 $x&#x3D;v_i+1$ 时将 $[v_i,r_i]$ 覆盖次数减一，开一个线段树维护最大值即可。</p><p>至于输出方案，我们线段树能找到一个点 $(x,y)$ 使其覆盖次数最大，那么把所有 $l_i\le x \le v_i \le y\le r_i$ 的工人输出就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,V=3e5;</span><br><span class="line">int n,id;</span><br><span class="line">struct node&#123;int x,yl,yr;&#125;a[N],Ans,tmp;</span><br><span class="line">I bool operator&lt;(Cn node&amp; x,Cn node&amp; y)&#123;return x.x&lt;y.x;&#125;</span><br><span class="line">vector&lt;node&gt; G[V+5];</span><br><span class="line">#define pb push_back</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">private:</span><br><span class="line">node T[(V+5)&lt;&lt;2];int tg[(V+5)&lt;&lt;2];</span><br><span class="line">#define mid (l+r&gt;&gt;1)</span><br><span class="line">#define PT CI x=1,CI l=1,CI r=V</span><br><span class="line">#define LT x&lt;&lt;1,l,mid</span><br><span class="line">#define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">#define PU(x) (T[x]=max(T[x&lt;&lt;1],T[x&lt;&lt;11]))</span><br><span class="line">I void AP(CI x,CI v)&#123;T[x].x+=v,tg[x]+=v;&#125;</span><br><span class="line">I void PD(CI x)&#123;tg[x]&amp;&amp;(AP(x&lt;&lt;1,tg[x]),AP(x&lt;&lt;11,tg[x]),tg[x]=0);&#125;</span><br><span class="line">public:</span><br><span class="line">I void B(PT)&#123;if(l==r) return T[x]=(node)&#123;0,l,l&#125;,void();B(LT),B(RT),PU(x);&#125; </span><br><span class="line">I void U(CI L,CI R,CI v,PT)&#123;if(L&lt;=l&amp;&amp;r&lt;=R) return AP(x,v),void();PD(x),L&lt;=mid&amp;&amp;(U(L,R,v,LT),0),R&gt;mid&amp;&amp;(U(L,R,v,RT),0),PU(x);&#125;</span><br><span class="line">I node Q(CI L,CI R,PT)&#123;if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];PD(x);if(R&lt;=mid) return Q(L,R,LT);if(L&gt;mid) return Q(L,R,RT);return max(Q(L,R,LT),Q(L,R,RT));&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,l,v,r;for(read(n),i=1;i&lt;=n;i++) read(l,v,r),G[l].pb((node)&#123;1,v,r&#125;),G[v+1].pb((node)&#123;-1,v,r&#125;),a[i]=(node)&#123;v,l,r&#125;;</span><br><span class="line">for(T.B(),i=1;i&lt;=V;i++)&#123;for(auto j:G[i]) T.U(j.yl,j.yr,j.x);Ans&lt;(tmp=T.Q(1,V))&amp;&amp;(Ans=tmp,id=i);&#125;</span><br><span class="line">for(writeln(Ans.x),i=1;i&lt;=n;i++) a[i].yl&lt;=id&amp;&amp;id&lt;=a[i].x&amp;&amp;a[i].x&lt;=Ans.yl&amp;&amp;Ans.yl&lt;=a[i].yr&amp;&amp;(write(i),pc(&#x27; &#x27;),0);return pc(&#x27;\n&#x27;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF878E Numbers on the blackboard</title>
      <link href="/2021/09/08/cf878e-numbers-on-the-blackboard/"/>
      <url>/2021/09/08/cf878e-numbers-on-the-blackboard/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="http://codeforces.com/problemset/problem/878/E">CF878E</a></p></blockquote><p>给出 $n$ 个数字，每次询问一个区间 $[l,r]$，对这个区间内部的点进行操作。 每次操作可以合并相邻两个数 $x,y$ 其中 $x$ before $y$，将它们变成 $x+2y$ 对于每次询问输出当最后只剩下一个数字时，这个数字的最大值。 询问互相独立，答案对 $10^9+7$ 取模。</p><p>$1\leq n,q\leq 10^5,-10^9\leq a_i\leq10^9$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>一开始没看到 $x$ before $y$ 和指导胡扯了好久</p><p>显然一定是从左到右，如果当前数为非负数，一定将该数与上一块进行合并；如果当前数为非负数，一定是给它单独新开一个块。</p><p>如果合并后导致原来一个贡献为负的块贡献变为正了，则继续向前合并，显然这样贡献最大。</p><p>最后一定是从后往前依次将每个块合并。</p><p>显然最后每个数的贡献一定是 $2$ 的幂，可以提前预处理。</p><p>然后把询问离线下来，按照 $r$ 端点排个序然后每次考虑插点合并块即可。</p><p>然后左端点所在的块会拆开，但是显然这拆开的部分一定不会与后面合并（这样肯定不优）。</p><p>最后有个小细节，合并如何判断正负（在取模之后）？显然如果一个块内的权值之和已经超过了 $10^{14}$ 则一定能把之前的所有块都合并了，于是只需要每个块单独的和先用 long long 存即可。</p><p>时间复杂度 $\mathcal O(N\log N)$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,p=1e9+7,Inv2=500000004;</span><br><span class="line">Cn LL inf=1e15;</span><br><span class="line">int n,q,a[N],inv[N],pw[N],stk[N],top;</span><br><span class="line">LL s[N],S[N],SS[N],Ans[N];</span><br><span class="line">struct Que&#123;int l,r,id;&#125;Q[N];</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">#define pb push_back</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,t;for(read(n,q),pw[0]=inv[0]=1,i=1;i&lt;=n;i++) read(a[i]),s[i]=(s[i-1]+1LL*(pw[i]=2LL*pw[i-1]%p)*a[i]%p)%p,inv[i]=1LL*inv[i-1]*Inv2%p;</span><br><span class="line">    for(i=1;i&lt;=q;i++) read(Q[i].l,Q[i].r),Q[i].id=i,v[Q[i].r].pb(i);</span><br><span class="line">    for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        stk[++top]=i,S[top]=a[i];</span><br><span class="line">        W(top&amp;&amp;S[top]&gt;0) (1LL&lt;&lt;stk[top]-stk[top-1])&gt;(inf-S[top-1])/S[top]?S[top-1]=inf:S[top-1]+=(1&lt;&lt;stk[top]-stk[top-1])*S[top],top--;</span><br><span class="line">        SS[top]=S[top]&lt;inf?(SS[top-1]+S[top])%p:s[i];for(auto j:v[i])&#123;</span><br><span class="line">            stk[top+1]=Q[j].r+1,t=upper_bound(stk+1,stk+top+2,Q[j].l)-stk;</span><br><span class="line">            Ans[Q[j].id]=((2LL*(SS[top]-SS[t-1]+p)%p+1LL*(s[stk[t]-1]-s[Q[j].l-1]+p)*inv[Q[j].l]%p)%p+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;for(i=1;i&lt;=q;i++) writeln(Ans[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1179D Fedor Runs for President</title>
      <link href="/2021/08/30/cf1179d-fedor-runs-for-president/"/>
      <url>/2021/08/30/cf1179d-fedor-runs-for-president/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/problemset/problem/1179/D">CF1179D</a></p></blockquote><p>给一棵 $n$ 个点的树，求加入一条边后，最多有多少条无向简单路径。</p><p>简单路径定义为任意一个点最多经过一次的路径。</p><p>$n\leq 5\times 10^5$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>考虑原来的树显然任意两点之间都能抵达，答案为 $\frac{n(n-1)}2$。</p><p>然后加入一条边 $(x,y)$ 就可以把 $x$ 到 $y$ 之间的路径拉出来，显然路径上不同子树间点互相访问的简单路径多了一条，那么答案就增加了 $\sum (n-sz_i)\times sz_i$，那么题目就转化为了求 $\sum sz_i^2$ 最小。</p><p>然后这个东西显然不断向叶节点扩展是更优的，考虑先以 $1$ 为根，找到一个最优解，然后再以这个最优解为根，再跑一遍。接下来就是证明：</p><p>考虑 $\forall x,y\in[1,n],x\not &#x3D; y$ 且 $x$ 为以 $1$ 为根时的最优解，显然 $x,y$ 为两个叶子节点，令 $t&#x3D;\operatorname{lca}(x,y)$。</p><ul><li>若 $z\in$ 以 $t$ 为根子树，那么可以先不考虑 $t$ 到 $1$ 的贡献，由已知条件可得 $(sz_t-sz_x)\times sz_x&lt;(sz_t-sz_y)\times sz_y$，那么可得 $sz_x&lt;sz_y$，那么显然若 $z$ 与 $x,y$ 均不属于 $t$ 的同一棵子树内，显然 $(x,z)$ 比 $(y,z)$ 更优，$(sz_t-sz_z)\times sz_z+(sz_x-s_t)\times sz_t&lt;(sz_t-sz_z)\times sz_z+(sz_y-s_t)\times sz_t$。</li><li>若 $z\not\in$ 以 $t$ 为根子树，那么同理也可以通过拆贡献的方式得出 $(x,z)$ 比 $(y,z)$ 更优。</li></ul><p>然后就类似于求树的直径的方式，两次 DFS 就可以求出答案了，时间复杂度 $\mathcal O(N)$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e5+10;</span><br><span class="line">int n,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,sz[N];</span><br><span class="line">LL Ans[N];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void G(CI x,CI fa)&#123;</span><br><span class="line">    RI i;for(sz[x]=1,i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(G(to,x),sz[x]+=sz[to]);</span><br><span class="line">&#125;</span><br><span class="line">I void DFS(CI x,CI fa)&#123;</span><br><span class="line">    RI i;for(i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(Ans[to]=Ans[x]+1LL*(sz[x]-sz[to])*sz[to],DFS(to,x),0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y,Mx;for(read(n),i=1;i&lt;n;i++) read(x,y),Add(x,y),Add(y,x);</span><br><span class="line">    for(G(1,0),Ans[Mx=1]=1LL*n*(n-1)&gt;&gt;1,DFS(1,0),i=1;i&lt;=n;i++) Ans[Mx]&lt;Ans[i]&amp;&amp;(Mx=i);</span><br><span class="line">    for(G(Mx,0),Ans[Mx]=1LL*n*(n-1)&gt;&gt;1,DFS(Mx,0),i=1;i&lt;=n;i++) Ans[Mx]&lt;Ans[i]&amp;&amp;(Mx=i);</span><br><span class="line">    return writeln(Ans[Mx]),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P6072 『MdOI R1』Path</title>
      <link href="/2021/08/28/p6072-%E3%80%8Emdoi-r1%E3%80%8Fpath/"/>
      <url>/2021/08/28/p6072-%E3%80%8Emdoi-r1%E3%80%8Fpath/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P6072">P6072</a></p></blockquote><p>给定一棵 $n$ 个节点的无根树，从中选择两个不交路径，求边权异或和之和最大值。</p><p>$n\leq 3\times 10^4$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>这里具体讲讲一只 $\log$ 的做法（在此感谢 <a href="https://www.luogu.com.cn/discuss/show/347250">神仙lwy</a>）。</p><p>考虑这种题首先套路地枚举分界点 $x$，使两条路径一条在节点 $x$ 的子树内，另一条在子树外。</p><p>然后就很自然地想到了 $\mathcal O(n\log n\log w)$ 的 DSU+Trie 的做法处理子树内的部分，子树外的部分可以先利用 Trie 求出任意一对全局的异或和最大的点对 $(X,Y)$，那么显然所有不在 $X$ 到根和 $Y$ 到根的路径上的点的子树外的答案都是 $(X,Y)$ 间的异或和。考虑 $X$ 到根以及 $Y$ 到根的路径就直接从根节点出发，每次将点插入 Trie 中，维护出异或值最大即可，由于每个点只会被插一次，所以总复杂度为 $\mathcal O(n\log w)$。</p><p>然后考虑如何做到完全的一只 $\log$。还是先求出全局的异或和最大的 $(X,Y)$，然后把这条 $X$ 到 $Y$ 的链提取出来。</p><ul><li>如果分界点不在这条链上，显然子树外的答案取这个链的答案最优，子树内的答案直接求解与这条链相邻的子树内的答案即可，显然如果子树内的最优答案必然包含在与这条链相邻的子树内，这样每个点只会被插一次。</li><li>如果分界点在这条链上，考虑先钦定 $X$ 为根，从 $Y$ 向上扫一遍，不断插入点，求出其异或和最大值即为当前点的子树内答案。类似的，钦定 $Y$ 为根，从 $X$ 向上扫一遍，不断插点，同样也能求出其子树外的答案。</li></ul><p>由于每个点只会被插一次，所以这样的话总时间复杂度为 $\mathcal O(n\log w)$。</p><p>有一点点小细节，写的时候注意一下就好了。然后就跑的比两只 $\log$ 还慢。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e4+10;</span><br><span class="line">int n,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],w[N&lt;&lt;1],tot,F[N],Mx=-1,idx,idy,vis[N],G[N],P[N],dfn[N],bk[N],cnt,sz[N],Ans,in[N],out[N];</span><br><span class="line">I void Add(CI x,CI y,CI z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void DFS(CI x,CI fa)&#123;RI i;for(i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(F[to]=F[x]^w[i],DFS(to,x),0);&#125;</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">class Trie&#123;</span><br><span class="line">    private:</span><br><span class="line">        int ch[N*31][2],id[N*31],cnt;</span><br><span class="line">    public:</span><br><span class="line">        I void C()&#123;RI i;for(i=0;i&lt;=cnt;i++) ch[i][0]=ch[i][1]=id[i]=0;cnt=0;&#125;</span><br><span class="line">        I void U(CI x,CI dd)&#123;RI i,u=0;for(i=30;~i;i--) ch[u][x&gt;&gt;i&amp;1]?u=ch[u][x&gt;&gt;i&amp;1]:u=ch[u][x&gt;&gt;i&amp;1]=++cnt;id[u]=dd;&#125;</span><br><span class="line">        I PA Q(CI x)&#123;RI i,u=0,X=0;for(i=30;~i;i--) ch[u][x&gt;&gt;i&amp;1^1]?u=ch[u][x&gt;&gt;i&amp;1^1],X=1&lt;&lt;i:u=ch[u][x&gt;&gt;i&amp;1];return MP(X,id[u]);&#125;</span><br><span class="line">&#125;T;//Trie 树维护异或和最大值</span><br><span class="line">I void dfs(CI x,CI fa)&#123;RI i;for(P[x]=fa,bk[dfn[x]=++cnt]=x,sz[x]=1,i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(F[to]=F[x]^w[i],dfs(to,x),sz[x]+=sz[to],0);&#125;</span><br><span class="line">I void GT(CI x)&#123;RI i,j;PA t;for(i=fir[x];i;i=nxt[i]) if(!vis[to])&#123;for(j=dfn[to];j&lt;=dfn[to]+sz[to]-1;j++) t=T.Q(F[bk[j]]),Ans=max(Ans,Mx+t.first),T.U(F[bk[j]],bk[j]);T.C();&#125;&#125;//分界点不在链上，求与链相邻子树答案</span><br><span class="line">I void FG(CI x)&#123;RI i,j;PA t;for(t=T.Q(F[x]),in[x]=max(in[x],t.first),T.U(F[x],x),i=fir[x];i;i=nxt[i]) if(!vis[to]) for(j=dfn[to];j&lt;=dfn[to]+sz[to]-1;j++) t=T.Q(F[bk[j]]),in[x]=max(in[x],t.first),T.U(F[bk[j]],bk[j]);&#125;//分界点在链上，求子树内答案</span><br><span class="line">I void FO(CI x)&#123;RI i,j;PA t;for(t=T.Q(F[x]),out[x]=max(out[x],t.first),T.U(F[x],x),i=fir[x];i;i=nxt[i]) if(!vis[to]) for(j=dfn[to];j&lt;=dfn[to]+sz[to]-1;j++) t=T.Q(F[bk[j]]),out[x]=max(out[x],t.first),T.U(F[bk[j]],bk[j]);&#125;//分界点在链上，求子树外答案</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y,z,lst;PA t;for(read(n),i=1;i&lt;n;i++) read(x,y,z),Add(x,y,z),Add(y,x,z);for(DFS(1,0),i=1;i&lt;=n;i++) t=T.Q(F[i]),Mx&lt;t.first&amp;&amp;(Mx=t.first,idx=t.second,idy=i),T.U(F[i],i);//先求出全局异或和最大点对</span><br><span class="line">    for(F[idx]=0,dfs(idx,0),vis[idx]=1,i=idy;i!=idx;i=P[i]) vis[i]=1;for(T.C(),GT(idx),i=idy;i!=idx;i=P[i]) GT(i);for(i=idy;i!=idx;i=P[i]) FG(i);FG(idx),T.C();//分界点不在链上</span><br><span class="line">    for(F[idy]=cnt=0,dfs(idy,0),i=idx;i!=idy;i=P[i]) FO(i);FO(idy);for(lst=0,i=P[idx];i!=idy;i=P[i]) Ans=max(Ans,in[i]+lst),lst=max(lst,out[i]);//分界点在链上合并子树内子树外</span><br><span class="line">    return Ans=max(Ans,in[idy]+lst),writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOIP2021模拟赛8.19 C」玩家（gamer）</title>
      <link href="/2021/08/19/%E3%80%8Cnoip2021%E6%A8%A1%E6%8B%9F%E8%B5%9B8-19-c%E3%80%8D%E7%8E%A9%E5%AE%B6%EF%BC%88gamer%EF%BC%89/"/>
      <url>/2021/08/19/%E3%80%8Cnoip2021%E6%A8%A1%E6%8B%9F%E8%B5%9B8-19-c%E3%80%8D%E7%8E%A9%E5%AE%B6%EF%BC%88gamer%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>给定一个序列 ${a_i}$，统计有多少个排列 $p_1,\dots,p_n$ 对于任意 $i$ 满足 $p_i&#x3D;a_i$ 或 $p_{p_i}&#x3D;a_i$。</p><p>$1\leq n\leq 10^5,1\leq a_i\leq n$</p><p>$\texttt{2s&#x2F;512MB}$</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>首先考虑一个满足条件的排列 $p$，一定会构成若干个环，使得每个点必然走一步&#x2F;两步就能走到 $a_i$。每个点 $i$ 向 $p_i$ 或 $p_{p_i}$ 连边，可以发现如若合法，则构成的图一定是个基环内向树森林。考虑如何生成这样符合题意的图。</p><p>先反向连边，尝试构成一个基环外向树森林，显然每个点出度至多为 $2$。显然一定是若干个环以及若干条挂在环上的链。</p><p>那么先考虑如何合并环上的链，显然要么是紧跟在链与环间的端点后的，要么是与端点相隔一个点，然后与环上的点交织分布。如若交织过程中出现另一条链或者往外挂的链有分叉，显然是不可能合并起来的。</p><p>然后考虑计算环之间的答案，可以直接 DP，考虑对于每个大小的环分别考虑，如果这个环是奇环（且长度大于 $1$），显然有两种独立方案（这个可以自己画个图，额外的一个方案是全部都遵循 $p_{p_i}&#x3D;a_i$，当环大小为偶数时会重叠），如果这个环是偶环，显然仅有一种独立方案。还有可能是两个环合并，那么显然得两个长度相同的环合并，显然直接乘上节点接在另一个环上哪个点之后即可，然后可以直接转移。</p><p>由于每个节点仅会被访问一次，且 DP 转移是线性的，所以时间复杂度 $\mathcal O(N)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,p=998244353;</span><br><span class="line">int n,a[N],Ans=1,F[N],stk[N],top,len[N],deg[N],ci[N],fir[N],nxt[N],son[N],tot;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">bool vis[N];</span><br><span class="line">#define NA() (puts(&quot;0&quot;),exit(0),0)</span><br><span class="line">I int Dfs(CI x)&#123;return deg[x]&gt;1&amp;&amp;NA(),(!fir[x]?0:Dfs(son[fir[x]]))+(vis[x]=1);&#125;</span><br><span class="line">I void Sol(CI x)&#123;</span><br><span class="line">    RI lst,t=x,fi=0,i,j;W(!vis[t]) vis[t]=1,t=a[t];stk[top=1]=t;W((t=a[t])^stk[1]) stk[++top]=t;</span><br><span class="line">    for(i=1;i&lt;=top;i++) if(deg[stk[i]]&gt;1) break ;if(i&gt;top) return ++ci[top],void();</span><br><span class="line">    for(lst=0,i=1;i&lt;=top;i++) deg[stk[i]]&gt;1&amp;&amp;(!fi&amp;&amp;(fi=i),len[i]=i-lst,lst=i);len[fi]+=top-lst;</span><br><span class="line">    for(stk[0]=stk[top],i=1;i&lt;=top;i++) if(deg[stk[i]]&gt;1)&#123;</span><br><span class="line">        for(j=fir[stk[i]];j;j=nxt[j]) son[j]^stk[i-1]&amp;&amp;(t=Dfs(son[j]));t&gt;len[i]&amp;&amp;NA(),Ans=1LL*Ans*((t&lt;len[i])+(t&lt;=len[i]))%p;</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j;for(read(n),i=1;i&lt;=n;i++) read(a[i]),Add(a[i],i),(++deg[a[i]])&gt;2&amp;&amp;NA();for(i=1;i&lt;=n;i++) !vis[i]&amp;&amp;(Sol(i),0);</span><br><span class="line">    for(F[0]=i=1;i&lt;=n;Ans=1LL*Ans*F[ci[i++]]%p) for(j=1;j&lt;=ci[i];j++) F[j]=(1LL*(1+(i&amp;1&amp;&amp;i&gt;1))*F[j-1]%p+1LL*i*(j-1)%p*F[j-2]%p)%p; </span><br><span class="line">    return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 基环树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3349 [ZJOI2016]小星星</title>
      <link href="/2021/08/02/p3349-zjoi2016%E5%B0%8F%E6%98%9F%E6%98%9F/"/>
      <url>/2021/08/02/p3349-zjoi2016%E5%B0%8F%E6%98%9F%E6%98%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3349">P3349</a></p></blockquote><p>给定一棵 $n$ 个节点的树和一个 $n$ 个节点的图，要求为树上的每个节点映射到一个图上的节点（双射），且要求树上边对应图上也必须有相应的边，求方案数。</p><p>$n\leq 17$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>考虑朴素 DP，设 $F[i][j][k]$​ 表示将 $i$ 映射到 $j$，且 $i$ 的子树内的映射集合为 $k$ 的方案数。</p><p>瓶颈在于枚举子集，时间复杂度为 $\mathcal O(n^3\times 3^n)$。</p><p>考虑去掉 $k$ 这一维，显然直接套用容斥原理即可。</p><p>总方案数即为 全集 $-$ 少选一个 $+$ 少选两个 $-\dots$</p><p>这样时间复杂度降到了 $\mathcal O(n^3\times 2^n)$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=18;</span><br><span class="line">int n,m,H[N][N],A[N];</span><br><span class="line">vector&lt;int&gt; G[N],V;</span><br><span class="line">LL Ans,F[N][N];</span><br><span class="line">I int Count(RI x)&#123;RI X=0;W(x) x-=(x&amp;-x),X++;return X;&#125;</span><br><span class="line">I void Dfs(CI x,CI fa)&#123;</span><br><span class="line">    LL X;for(auto i:G[x]) i^fa&amp;&amp;(Dfs(i,x),0);</span><br><span class="line">    for(auto i:V)&#123;F[x][i]=1;for(auto j:G[x]) if(j^fa)&#123;X=0;for(auto k:V) if(i^k&amp;&amp;H[i][k]) X+=F[j][k];F[x][i]*=X;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">I LL S(CI x)&#123;</span><br><span class="line">    RI i;LL X=0;for(V.clear(),memset(A,0,sizeof(A)),i=1;i&lt;=n;i++) x&gt;&gt;(i-1)&amp;1&amp;&amp;(V.push_back(i),A[i]=1);</span><br><span class="line">    Dfs(1,0);for(auto i:V) X+=F[1][i];return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y;for(read(n,m),i=1;i&lt;=m;i++) read(x,y),H[x][y]=H[y][x]=1;</span><br><span class="line">    for(i=1;i&lt;n;i++) read(x,y),G[x].push_back(y),G[y].push_back(x);</span><br><span class="line">    for(i=0;i&lt;(1&lt;&lt;n);i++) Ans+=((n-Count(i))&amp;1?-S(i):S(i));return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈容斥原理</title>
      <link href="/2021/08/02/%E6%B5%85%E8%B0%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2021/08/02/%E6%B5%85%E8%B0%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h3><p>设有 $n$ 个集合，第 $i$ 个集合为 $A_i$，则所有集合的并集可以表示成如下形式：<br>$$<br>A_1\cup A_2\cup \cdots\cup A_n&#x3D;\sum_{i&#x3D;1}^n (-1)^{i-1}\sumA_1\cap A_2\cap\cdots\cap A_i<br>$$</p><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>假设元素 $a$​ 被 $x$​ 个集合包含，显然左式中该元素的贡献为 $1$，因为在并集内一个元素仅计算一次。</p><p>考虑其对于右式的贡献，显然它会被这个 $x$ 个集合中所有子集中被计算到，其贡献为：<br>$$<br>\sum_{i&#x3D;1}^xC_x^i(-1)^{i-1}&#x3D;1-\sum_{i&#x3D;0}^xC_x^i(-1)^i&#x3D;1<br>$$<br>由于所有元素对于左右两式的贡献均为 $1$，综上即可证得等式成立。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>容斥系数一般为 $(-1)^{S}$。</p><p>容斥的一些模型：</p><ol><li>所有情况 $-$ 至少有一个 $+$ 至少有两个 $-\dots &#x3D; $ 一个都没</li><li>全部都有 $-$ 一个也没 $&#x3D;$ 至少有一个</li><li>至少有 $k$ 个 $- C_{k+1}^k \times $ 至少有 $k+1$ 个 $+ C_{k+2}^k\times $ 至少有 $k+2$ 个 $\dots &#x3D; $ 恰好有 $k$ 个</li><li>补集转化</li><li>$\min-\max$​ 容斥</li><li>容斥原理</li></ol>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.16 D</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-16-d/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-16-d/</url>
      
        <content type="html"><![CDATA[<p>有一天 Mifafa 回到家，发现有 $n$ 只老鼠在她公寓的走廊上，她大声呼叫，所以老鼠们都跑进了走廊的洞中。</p><p>这个走廊可以用一个数轴来表示，上面有 $n$ 只老鼠和 $m$ 个老鼠洞。第 $i$ 只老鼠有一个坐标 $x_i$，第 $j$ 个洞有一个坐标 $p_j$ 和容量 $c_j$。容量表示最多能容纳的老鼠数量。</p><p>找到让老鼠们全部都进洞的方式，使得所有老鼠运动距离总和最小。</p><p>老鼠 $i$ 进入洞 $j$ 的运动距离为 $x_i−p_j$ 。</p><p>无解输出 $-1$。</p><p>$c,n,m\leq 10^6,1\leq p,x\leq 10^9$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>反悔贪心。</p><p>将所有的洞和老鼠一起按照横坐标排序，考虑一只老鼠 $i$ 如果进入了左侧离它最近的没用完的洞 $j$，若要用另一个洞 $k$ 去替换 $j$，贡献为：<br>$$<br>(p_k-x_i)-(x_i-p_j)&#x3D;p_k+(-2x_i+p_j)<br>$$<br>同理对于个洞 $i$，若用另一个老鼠 $k$ 代替原有老鼠 $j$，贡献为：<br>$$<br>(x_k-p_i)-(p_i-x_j)&#x3D;x_k+(-2p_i+x_j)<br>$$<br>然后开两个堆分别维护老鼠&amp;洞，直接按照如上规则跑。</p><p>时间复杂度 $\mathcal O(n\log n)$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(LL x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=1e6+10;</span><br><span class="line">int n,m,inf=2e9,cnt;</span><br><span class="line">#define P pair&lt;LL,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">P b[N&lt;&lt;1];</span><br><span class="line">LL sc,Ans;</span><br><span class="line">priority_queue&lt;LL&gt; Q1;</span><br><span class="line">priority_queue&lt;P&gt; Q2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,x,y;LL t;for(read(n),read(m),i=1;i&lt;=n;i++) read(x),b[++cnt]=MP(x,-1);</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(x),read(y),b[++cnt]=MP(x,y),sc+=y;</span><br><span class="line">    if(sc&lt;n) return puts(&quot;-1&quot;),0;</span><br><span class="line">    for(sort(b+1,b+cnt+1),i=1;i&lt;=cnt;i++) if(~b[i].se)&#123;</span><br><span class="line">        W(!Q1.empty()&amp;&amp;b[i].se&amp;&amp;b[i].fi&lt;Q1.top()) t=b[i].fi-Q1.top(),Q1.pop(),b[i].se--,Q2.push(MP(b[i].fi+t,0)),Ans+=t;</span><br><span class="line">        b[i].se&amp;&amp;(b[i].se--,Q2.push(MP(b[i].fi,i)),0);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        t=2e12;if(!Q2.empty()) t=b[i].fi-Q2.top().fi,j=Q2.top().se,Q2.pop(),b[j].se&amp;&amp;(b[j].se--,Q2.push(MP(b[j].fi,j)),0);</span><br><span class="line">        Ans+=t,Q1.push(b[i].fi+t);</span><br><span class="line">    &#125;return write(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反悔贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.15 D</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-d/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-d/</url>
      
        <content type="html"><![CDATA[<p>白云在白兔的城市，打算在这里住 $n$ 天，这 $n$ 天，白云计划找白兔订购水。</p><p>白云给出了接下来的 $n$​ 天，每天的需水量，第 $i$​ 天为 $D_i$ 升。</p><p>白兔给出了接下来的 $n$ 天，每天水的价格，第 $i$ 天为 $P_i$ 元每升。</p><p>白云的小区有一个共用水壶，最大容量为 $V$ 升，初始为空。 接下来每天，白云可以进行如下操作：</p><ol><li>把水壶中的水使用掉</li><li>向白兔购买若干水，并放入水壶中</li><li>向白兔购买若干水，并使用</li></ol><p>任何时候水壶中的水不能超过 $V$ 升，而且每升水每在水壶中存放一天，需要付出 $m$ 元</p><p>白兔为了难为白云，决定在某些天进行破坏操作，即选择一个子序列 $b_1,…,b_t$，在这序列中的每一天，它会在当天早上把前一天储存的水放掉。第 $i$ 天有一个破坏难度 $val_i$，白兔为了挑战自己，决定让自己进行破坏操作的 $val$ 是严格单调递增。它会找一个破坏天数最多的方案，在保证破坏次数最多的前提下，使得破坏序列的字典序最小。</p><p>白云已经知道了白兔的想法，并且获取了这个破坏难度，所以它已经能计算出白兔会在哪些日子进行破坏。</p><p>那么白云想知道，在此基础上，白云要度过接下来 $n$ 天的最小总花费。</p><p>$m,p_i\leq 1000,n\leq 10^6,d_i,V\leq 10^7,val\leq 10^9$</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>首先可以求出字典序最小的最长上升子序列 $\mathcal O(n\log n)$。</p><p>然后对于一组最优解，如果第 $i$ 天买了水并保存在水壶里，那么 $p_i$ 一定是单增的。</p><p>所以直接维护一个单调队列，由于容量限制打一个全局标记即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(LL x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=1e6+10;</span><br><span class="line">int n,m,V,a[N],d[N],p[N],stk[N],top,dp[N],Mx,Ans[N],v[N],q[N],w[N],h,t;</span><br><span class="line">LL ans;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; vis[N];</span><br><span class="line">I void LIS()&#123;</span><br><span class="line">    RI i,j;for(stk[top=1]=a[1],Mx=1,dp[1]=1,i=2;i&lt;=n;i++) if(a[i]&gt;stk[top]) stk[++top]=a[i],dp[i]=top,Mx=max(Mx,top);</span><br><span class="line">    else&#123;RI t=lower_bound(stk+1,stk+top+1,a[i])-stk;dp[i]=t,stk[t]=a[i];&#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++) vis[dp[i]].push_back(make_pair(i,a[i]));</span><br><span class="line">    for(Ans[Mx]=vis[Mx][0].first,i=Mx-1;i&gt;=1;i--)&#123;</span><br><span class="line">        RI r=vis[i].size();Ans[i]=2e9;</span><br><span class="line">        for(j=0;j&lt;r;j++) if(vis[i][j].second&lt;a[Ans[i+1]]&amp;&amp;vis[i][j].first&lt;Ans[i]) Ans[i]=vis[i][j].first;</span><br><span class="line">    &#125;for(i=1;i&lt;=Mx;i++) v[Ans[i]]=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,nd,tg=0;for(read(n),read(m),read(V),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(d[i]);for(i=1;i&lt;=n;i++) read(p[i]);</span><br><span class="line">    LIS();for(h=1,t=0,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(v[i]) h=t+1;</span><br><span class="line">        W(h&lt;=t&amp;&amp;p[i]-(i-1)*m&lt;=p[q[t]]) t--;</span><br><span class="line">        nd=d[i];W(h&lt;=t) if(nd&lt;w[q[h]]-tg)&#123;ans+=1LL*(p[q[h]]+(i-1)*m)*nd,tg+=nd,nd=0;break ;&#125;</span><br><span class="line">        else ans+=1LL*(p[q[h]]+(i-1)*m)*(w[q[h]]-tg),nd-=w[q[h]]-tg,tg=w[q[h++]];</span><br><span class="line">        ans+=1LL*nd*p[i],q[++t]=i,w[i]=V+tg,p[i]-=(i-1)*m;</span><br><span class="line">    &#125;return write(ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.15 C</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-c/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-c/</url>
      
        <content type="html"><![CDATA[<p>白云有一颗 $n$ 个节点的树，每个点有一个点权</p><p>白兔需要找到两条点不相交的路径，要求最大化这两条路径覆盖点的点权和</p><p>$n\leq 10^5$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>换根 DP。</p><p>考虑两条路径的形态。</p><ol><li>从两个子树中各抽出一条链。</li><li>在一棵子树中抽一条经过根的链，再在剩余的儿子的子树中抽一条链。</li><li>在一棵子树中抽一条子树内的链，再在经过这个子树的父亲抽一条链。</li></ol><p>然后维护一下每个点到叶子节点最长链、次长链、子树内最长链、经过子树的父亲最长链即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(LL x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,a[N],fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot;</span><br><span class="line">LL Mx,Ans,f[N],g[N],Mx1,Mx2;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Dfs(CI x,CI fa)&#123;</span><br><span class="line">    RI i,sz=0,Mx1=0,Mx2=0,id1=0,id2=0;for(i=fir[x];i;i=nxt[i]) if(to^fa) sz++,Dfs(to,x),g[x]=max(g[x],g[to]),f[to]&gt;Mx1?(Mx2=Mx1,id2=id1,Mx1=f[to],id1=to):f[to]&gt;Mx2&amp;&amp;(Mx2=f[to],id2=to);</span><br><span class="line">    if(!Mx1&amp;&amp;!Mx2) return Ans=max(Ans,f[x]=g[x]=a[x]),void();</span><br><span class="line">    f[x]=a[x]+f[id1],g[x]=max(g[x],f[x]);</span><br><span class="line">    if(!Mx2) return Ans=max(Ans,f[x]),void();</span><br><span class="line">    g[x]=max(g[x],f[x]+f[id2]);</span><br><span class="line">    if(sz==2) return Ans=max(Ans,max(f[x]+g[id2],g[id1]+a[x]+f[id2])),void();</span><br><span class="line">    for(i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;to^id1&amp;&amp;to^id2&amp;&amp;(Ans=max(Ans,max(f[x]+f[id2]+g[to],max(a[x]+f[to]+f[id2]+g[id1],a[x]+f[to]+f[id1]+g[id2]))));</span><br><span class="line">&#125;</span><br><span class="line">I void Dfs2(CI x,CI fa,LL S)&#123;</span><br><span class="line">    RI i,Mx1=0,Mx2=0,id1=0,id2=0;for(i=fir[x];i;i=nxt[i]) if(to^fa) f[to]&gt;Mx1?(Mx2=Mx1,id2=id1,Mx1=f[to],id1=to):f[to]&gt;Mx2&amp;&amp;(Mx2=f[to],id2=to);</span><br><span class="line">    for(i=fir[x];i;i=nxt[i]) if(to^fa) to^id1?(Ans=max(Ans,S+f[id1]+g[to]),Dfs2(to,x,max(S,f[x])+a[to]),0):(Ans=max(Ans,S+f[id2]+g[to]),Dfs2(to,x,max(S,f[id2]+a[x])+a[to]),0); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,x,y;for(read(n),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">    for(i=1;i&lt;n;i++) read(x),read(y),Add(x,y),Add(y,x);</span><br><span class="line">    return Dfs(1,0),Dfs2(1,0,a[1]),write(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 换根DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.15 B</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-b/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-15-b/</url>
      
        <content type="html"><![CDATA[<p>白云建立了 $n$ 个商店，白兔打算按照编号 $1\sim n$ 的顺序访问这些商店。商店 $i$ 有一个价格 $ai$ 表示交易商品所需的代价。</p><p>白兔在按顺序走时，每到达一个商店，可以花费代价购买一件商品，并放入自己手中。也可以出售手上的商品，并获得利润。</p><p>白兔的力量有限，同一时刻只能携带一个商品。问它遍历完所有商店后能够获得的利润最大是多少？</p><p>白兔的精力也有限，所以，在最大化利润的前提下，它想让交易次数尽可能地少。</p><p>当然，白云不想让白兔轻松获利，它有时会命令一段区间内的商店把价格同时加上一个数。</p><p>$T\leq 5,1\leq n,Q\leq 10^5,c\leq 10^5$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>第一问十分简单，直接贪心考虑，$\forall i \in [1,n)$，若 $a_i&lt;a_{i+1}$，则在 $i$ 买入，在 $i+1$ 卖出一定是最优的。</p><p>第二问考虑线段树，其实就是在第一问差分的基础上，求所有极长非负整数区间且区间和大于 $0$ 的个数。直接线段树即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int Tt,n,q,a[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n-1</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].S=T[x&lt;&lt;1].S+T[x&lt;&lt;11].S,T[x].SS=T[x&lt;&lt;1].SS+T[x&lt;&lt;11].SS-(T[x&lt;&lt;11].pre&gt;0&amp;&amp;T[x&lt;&lt;1].suf&gt;0),T[x].pre=T[x&lt;&lt;1].pre?T[x&lt;&lt;1].pre:T[x&lt;&lt;11].pre,T[x].suf=T[x&lt;&lt;11].suf?T[x&lt;&lt;11].suf:T[x&lt;&lt;1].suf)</span><br><span class="line">    public:</span><br><span class="line">        struct node&#123;int S,SS,pre,suf;&#125;T[N&lt;&lt;2];</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(l==r) return T[x].pre=T[x].suf=a[l+1]-a[l],T[x].S=max(T[x].pre,0LL),T[x].SS=(T[x].pre&gt;0LL),void();</span><br><span class="line">            B(LT),B(RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return T[x].pre+=v,T[x].suf+=v,T[x].S=max(T[x].pre,0LL),T[x].SS=(T[x].pre&gt;0LL),void();</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,o,x,y,z;read(Tt);W(Tt--)&#123;</span><br><span class="line">        for(read(n),read(q),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">        for(S.B(),i=1;i&lt;=q;i++) read(o),o?write(S.T[1].S),pc(&#x27; &#x27;),write(S.T[1].SS&lt;&lt;1),pc(&#x27;\n&#x27;):(read(x),read(y),read(z),x&gt;1&amp;&amp;(S.U(x-1,z),0),y&lt;n&amp;&amp;(S.U(y,-z),0));</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.14 D</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-14-d/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-14-d/</url>
      
        <content type="html"><![CDATA[<p>给定一个 $n$​ 个节点，$m$ 条边无向图，初始边权均为 $1$。有 $k$ 次操作，每次操作可以选取一条边，使其边权加一。</p><p>设一条边的边权为 $v$​​，定义经过该边的时间为 $\frac{1}{v}$​​。</p><p>现有两个人，其中一个从 $s_1$ 走到 $t_1$，一个从 $s_2$ 走到 $t_2$，问如何操作使得两人花费总时间最少？</p><p>$n,m\leq 5000,0\leq k\leq 10^9$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>这里给个非正解。</p><p>直接分别跑两次最短路，然后记录一下重复路径，再整个三分就过了。</p><p>然后简要说说正解。</p><p>显然两人重复路径一定是连续的一条。</p><p>那么肯定是一条长链+四条链挂在端点上。</p><p>暴力枚举长链的两个端点，然后处理出每个点到起始点&#x2F;终点的距离（四条链），然后丢到一个桶里。</p><p>现在你就可以知道重复路径为长度为 $i$ 时，四条链长度最小值。</p><p>然后对于所有的 $i$ 分别跑次三分就好了。</p><p>这里给出<strong>非正解</strong>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">#define double long double</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=5e3+10;</span><br><span class="line">int n,m,k,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],w[N&lt;&lt;1],tot=1,s1,t1,s2,t2,F[N],vis[N],p[N],Sum,A1,A2,GG[N];</span><br><span class="line">vector&lt;int&gt; g[N];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i] </span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">I void Spfa()&#123;</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop();memset(F,63,sizeof(F)),memset(vis,0,sizeof(vis)),vis[s1]=1,F[s1]=0,q.push(s1);W(!q.empty())</span><br><span class="line">        for(u=q.front(),q.pop(),i=fir[u];i;i=nxt[i]) if(F[to]&gt;F[u]+1) g[to].clear(),g[to].push_back(i),F[to]=F[u]+1,!vis[to]&amp;&amp;(q.push(to),vis[to]=1);</span><br><span class="line">        else if(F[to]==F[u]+1) g[to].push_back(i);</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">I void U(CI x)&#123;if(x==s1) return ;RI i,sz=g[x].size();for(i=0;i&lt;sz;i++) w[g[x][i]]++,w[g[x][i]^1]++,!GG[son[g[x][i]^1]]&amp;&amp;(GG[son[g[x][i]^1]]=1,U(son[g[x][i]^1]),0);&#125;</span><br><span class="line">I void Spfa2()&#123;</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop();memset(F,63,sizeof(F)),memset(vis,0,sizeof(vis)),vis[s2]=1,F[s2]=0,q.push(s2);W(!q.empty())</span><br><span class="line">        for(u=q.front(),q.pop(),i=fir[u];i;i=nxt[i]) if(F[to]&gt;F[u]+1) p[to]=i,F[to]=F[u]+1,!vis[to]&amp;&amp;(q.push(to),vis[to]=1);</span><br><span class="line">        else if(F[to]==F[u]+1&amp;&amp;w[i]&amp;&amp;!w[p[to]]) p[to]=i;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">I void U2(CI x)&#123;if(x==s2) return ;Sum+=(w[p[x]]&gt;0),U2(son[p[x]^1]);&#125;</span><br><span class="line">I double Q(CI x,CI y,CI z)&#123;</span><br><span class="line">    if(k&lt;=z) return 0.0+x+y-2.0*z+(z-k)*2.0+k;</span><br><span class="line">    if(!(x+y-z)) return 0.0;</span><br><span class="line">    RI t=k/(x+y-z);t++;k%=(x+y-z);</span><br><span class="line">    if(k&gt;z) return 1.0*(x+y-2*z-(k-z))*(1.0/t)+1.0*(k-z)*(1.0/(t+1))+2.0*z*(1.0/(t+1));</span><br><span class="line">    return 1.0*(x+y-2*z)*(1.0/t)+2.0*(z-k)*(1.0/t)+2.0*k*(1.0/(t+1));</span><br><span class="line">&#125;</span><br><span class="line">I double check(int x,int y,int mid)&#123;</span><br><span class="line">    RI f=mid/y,g=(k-mid)/x;++f,++g;</span><br><span class="line">    return (1.0-1.0/f)*y*2+(2.0*(mid%y)/f/(f+1))</span><br><span class="line">            +(1.0-1.0/g)*x+(1.0*((k-mid)%x)/(g+1)/g);</span><br><span class="line">&#125;</span><br><span class="line">I double calc(int x,int y)&#123;</span><br><span class="line">    if(!x&amp;&amp;!y) return 0;</span><br><span class="line">    if(!x)&#123;</span><br><span class="line">        RI f=k/y;++f;</span><br><span class="line">        return 2*y-(f?(1.0-1.0/f)*y*2:0)-(k%y)*(2.0/f/(f+1));</span><br><span class="line">    &#125;</span><br><span class="line">    if(!y)&#123;</span><br><span class="line">        RI g=k/x;++g;</span><br><span class="line">        return x-(g?(1.0-1.0/g)*x:0)-(k%x)*(1.0/g/(g+1));</span><br><span class="line">    &#125;</span><br><span class="line">    int l=0,r=k,i;</span><br><span class="line">    while(r-l&gt;=3)&#123;</span><br><span class="line">        RI lmid=l+(r-l)/3,rmid=lmid+(r-l)/3;</span><br><span class="line">        if(check(x,y,lmid)&lt;check(x,y,rmid)) l=lmid;</span><br><span class="line">        else r=rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    double res=0;</span><br><span class="line">    for(i=l;i&lt;=r;i++) res=max(res,check(x,y,i));</span><br><span class="line">    return x+2*y-res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y;for(read(n),read(m),read(k),i=1;i&lt;=m;i++) read(x),read(y),Add(x,y),Add(y,x);</span><br><span class="line">    return read(s1),read(t1),read(s2),read(t2),Spfa(),A1=F[t1],U(t1),Spfa2(),A2=F[t2],U2(t2),printf(&quot;%.17Lf\n&quot;,calc(A1+A2-Sum*2,Sum)),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 三分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.13 D</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-d/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-d/</url>
      
        <content type="html"><![CDATA[<p>给定 $n$ 个数的序列 ${a_i}$，有 $m$ 组询问，每次询问给定区间 $[l,r]$，问有多少个子区间 $[i,j]$ 满足 $a_i,\dots,a_j$ 中不同的整数的数目是奇数。</p><p>$n,m\leq 5\times 10^5,1\leq a_i\leq n$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>首先肯定是考虑将询问离线。</p><p>然后考虑如何维护这个答案。</p><p>不难发现，子区间就相当于所有的前缀中取后缀。</p><p>那么我们只需要将询问按右端点排序，更新一下这个数上一次出现位置+1到此位置的状态即可。</p><p>直接在线段树上打个标记，分别记录一下奇&#x2F;偶情况的区间个数、数量、上次出现时间、答案即可。</p><p>查询就相当于区间求和了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e5+10;</span><br><span class="line">int n,m,a[N],p[N],v[N],j;</span><br><span class="line">LL Ans[N];</span><br><span class="line">struct Que&#123;int l,r,id;&#125;q[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        struct node&#123;int cnt,sz[2],stk[2],lst,tg;LL Ans;&#125;T[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].sz[0]=T[x&lt;&lt;1].sz[0]+T[x&lt;&lt;11].sz[0],T[x].sz[1]=T[x&lt;&lt;1].sz[1]+T[x&lt;&lt;11].sz[1],T[x].Ans=T[x&lt;&lt;1].Ans+T[x&lt;&lt;11].Ans)</span><br><span class="line">        I void PD(CI x,CI l,CI r)&#123;</span><br><span class="line">            T[x].stk[T[x].tg]+=j-T[x].lst,T[x].lst=j;</span><br><span class="line">            T[x].Ans+=1LL*T[x].stk[1]*T[x].sz[0]+1LL*T[x].stk[0]*T[x].sz[1];</span><br><span class="line">            if(l&lt;r) T[x&lt;&lt;1].stk[!T[x&lt;&lt;1].tg]+=T[x].stk[1],T[x&lt;&lt;1].stk[T[x&lt;&lt;1].tg]+=T[x].stk[0],T[x&lt;&lt;1].tg^=T[x].tg,</span><br><span class="line">            T[x&lt;&lt;11].stk[!T[x&lt;&lt;11].tg]+=T[x].stk[1],T[x&lt;&lt;11].stk[T[x&lt;&lt;11].tg]+=T[x].stk[0],T[x&lt;&lt;11].tg^=T[x].tg,</span><br><span class="line">            T[x&lt;&lt;1].lst=T[x&lt;&lt;11].lst=j;</span><br><span class="line">            T[x].tg&amp;&amp;(swap(T[x].sz[0],T[x].sz[1]),T[x].tg=0),T[x].stk[0]=T[x].stk[1]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(T[x].sz[0]=r-l+1,l==r) return ;</span><br><span class="line">            B(LT),B(RT);</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return j--,PD(x,l,r),T[x].tg=1,j++,PD(x,l,r),void();</span><br><span class="line">            PD(x,l,r);if(l&lt;r) PD(x&lt;&lt;1,l,mid),PD(x&lt;&lt;11,mid+1,r);</span><br><span class="line">            L&lt;=mid&amp;&amp;(U(L,R,LT),0),R&gt;mid&amp;&amp;(U(L,R,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(PD(x,l,r),L&lt;=l&amp;&amp;r&lt;=R) return T[x].Ans;</span><br><span class="line">            LL S=0;return L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return x.r&lt;y.r;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n),i=1;i&lt;=n;i++) read(a[i]),p[i]=v[a[i]],v[a[i]]=i;</span><br><span class="line">    for(read(m),i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    for(sort(q+1,q+m+1,cmp),T.B(),i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        W(j&lt;q[i].r) j++,T.U(p[j]+1,j);</span><br><span class="line">        Ans[q[i].id]=T.Q(q[i].l,q[i].r);</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) writeln(Ans[i]);return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 离线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.13 C</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-c/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-c/</url>
      
        <content type="html"><![CDATA[<p>给定一棵 $n$ 个节点的带权有根树，保证每个节点权值均为非负整数。</p><p>定义 $f(x)$​，表示对于节点 $x$​，包含 $x$​ 的节点的平均值最大的连通块内平均值。</p><p>求 $\min_{i&#x3D;1}^n f(i)$。</p><p>$n\leq 10^5$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>既有最小也有最大，想到二分。</p><p>可以二分答案，每次 check 的时候数字权值减去 mid，跑一次换根 DP，求出经过每个点的最大连通块，如果每个连通块的权值均 $\ge0$，那么说明符合条件。</p><p>然后这题不卡精度，随便跑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">#define eps 1e-7</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,P=998244353;</span><br><span class="line">int n,a[N],fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,vis[N],Mx,ff;</span><br><span class="line">double F[N],Ans=20000000000.0,g[N],b[N];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Dfs(CI x)&#123;RI i;for(F[x]=b[x],i=fir[x];i;i=nxt[i]) Dfs(to),F[x]+=max(0.0,F[to]);&#125;</span><br><span class="line">I void Dfs2(CI x)&#123;for(RI i=fir[x];i;i=nxt[i]) g[to]=max(0.0,g[x]-max(F[to],0.0))+F[to],Dfs2(to);&#125;</span><br><span class="line">I bool check(double x)&#123;</span><br><span class="line">    RI i;for(i=1;i&lt;=n;i++) b[i]=1.0*a[i]-x;ff=0;</span><br><span class="line">    Dfs(1),g[1]=F[1],Dfs2(1);for(i=1;i&lt;=n;i++) if(g[i]&lt;0.0) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,j,x;double l=200000000.0,r=0.0,mid;for(read(n),i=1;i&lt;=n;i++) read(a[i]),l=min(l,1.0*a[i]),r=max(r,1.0*a[i]);for(i=2;i&lt;=n;i++) read(x),Add(x,i);</span><br><span class="line">    W(r-l&gt;eps) check(mid=(l+r)/2.0)?r=mid:l=mid;</span><br><span class="line">    return printf(&quot;%.6lf\n&quot;,l),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 换根DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.13 B</title>
      <link href="/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-b/"/>
      <url>/2021/07/24/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-13-b/</url>
      
        <content type="html"><![CDATA[<p>给定串 $s$，问其中有多少 namomo 子序列。定义一个子序列 $t$​ 是 namomo 子序列，当且仅当：</p><ol><li>$t_3&#x3D;t_5$</li><li>$t_4&#x3D;t_6$</li><li>$t_1,t_2,t_3,t_4$​ 两两不同。</li></ol><p>输出答案 $\bmod 998244353$ 的结果。</p><p>$6\leq s\leq 10^6$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>这题有多种做法，这里提供一种比较简洁小清新的做法。</p><p>首先 $t_1,t_2$ 可以先放在一边，等下直接用组合数爆算。</p><p>设 $f_{i,j,k}$​ 表示已经占了 $i$ 位，当前是 $j$ 这个字符，上一个是 $k$ 这个字符的方案数。</p><p>然后每次刷表倒序（避免 $t_1,t_2$ 算重问题）转移即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+10,P=998244353;</span><br><span class="line">int n,Ans,a[N],F[5][64][64],Sum,sm[64],SS;</span><br><span class="line">char b[N];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,j,k,t,l,e;cin&gt;&gt;b+1;n=strlen(b+1);for(i=1;i&lt;=n;i++) a[i]=(&#x27;a&#x27;&lt;=b[i]&amp;&amp;b[i]&lt;=&#x27;z&#x27;)?(b[i]-&#x27;a&#x27;):((&#x27;A&#x27;&lt;=b[i]&amp;&amp;b[i]&lt;=&#x27;Z&#x27;)?(b[i]-&#x27;A&#x27;+26):(b[i]-&#x27;0&#x27;+52));</span><br><span class="line">    for(i=1;i&lt;=n;i++) Sum++,SS+=sm[a[i]]++;for(i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        Sum--,SS-=--sm[a[i]];</span><br><span class="line">        for(j=0;j&lt;=61;j++) if(a[i]^j)&#123;</span><br><span class="line">            F[1][a[i]][j]++;</span><br><span class="line">            (F[3][j][a[i]]+=F[2][j][a[i]])%=P;</span><br><span class="line">            (F[2][a[i]][j]+=F[1][j][a[i]])%=P;</span><br><span class="line">            (Ans+=F[3][a[i]][j]*((Sum-sm[a[i]]-sm[j])*((Sum-sm[a[i]]-sm[j])-1)/2%P-SS+(sm[a[i]]*(sm[a[i]]-1)/2)%P+(sm[j]*(sm[j]-1)/2)%P)%P)%=P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return write(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF GYM102759 I. Query On A Tree 17</title>
      <link href="/2021/07/24/cf-gym102759-i-query-on-a-tree-17/"/>
      <url>/2021/07/24/cf-gym102759-i-query-on-a-tree-17/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://codeforces.com/gym/102759/problem/I">GYM102759 I</a></p></blockquote><p>给定一棵以 $1$​ 为根节点的拥有 $N$​ 个节点的带点权树，初始时每个点的点权均为 $0$​，有 $Q$​ 次操作，每次操作有两种类型：</p><ul><li><code>1 u</code>，以 $u$ 为根节点的子树内每个点点权均加 $1$。</li><li><code>2 u v</code>，将节点 $u$ 到节点 $v$ 的简单路径上的点的点权均加 $1$。</li></ul><p>每次操作后询问使 $\sum_{y&#x3D;1}^N A_y\times dist(x,y)$​ 最小的 $x$，其中 $dist(x,y)$ 表示点 $x$ 到点 $y$ 的路径上的边数，如果有多个，请输出离根节点 $1$ 最近的那个。</p><p>$N,Q\leq 10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然最后的答案就是求带权重心。</p><p>那么我们相当于求深度最浅的重心。</p><blockquote><p>对于一个点 $v$，如果它是答案，把它作为根，那么 $root$ 所在的子树大小 $\leq$ 权值和的一半，也就是说剩下的大小（以 $root$ 为根时子树 $v$ 的大小）$\ge$ 权值和的一半，也就是说中位数一定包含在 $v$ 所包含的子树里。</p></blockquote><p>直接上轻重链剖分，可以线段树上二分求出中位数，每次倍增向上跳，判一下是否符合条件即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,m,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,dep[N],f[N][21],sz[N],mx[N],dfn[N],top[N],bk[N],cnt;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Dfs1(CI x,CI fa)&#123;RI i;for(dep[x]=dep[f[x][0]=fa]+(sz[x]=1),i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(Dfs1(to,x),sz[x]+=sz[to],sz[mx[x]]&lt;sz[to]&amp;&amp;(mx[x]=to));&#125;</span><br><span class="line">I void Dfs2(CI x,CI Top)&#123;</span><br><span class="line">    if(top[x]=Top,bk[dfn[x]=++cnt]=x,mx[x]) Dfs2(mx[x],Top);</span><br><span class="line">    RI i;for(i=fir[x];i;i=nxt[i]) to^f[x][0]&amp;&amp;to^mx[x]&amp;&amp;(Dfs2(to,to),0);</span><br><span class="line">&#125;</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        LL T[N&lt;&lt;2],tg[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x]=T[x&lt;&lt;1]+T[x&lt;&lt;11])</span><br><span class="line">        I void PD(CI x,CI l,CI r)&#123;tg[x]&amp;&amp;(T[x&lt;&lt;1]+=tg[x]*(mid-l+1),tg[x&lt;&lt;1]+=tg[x],T[x&lt;&lt;11]+=tg[x]*(r-mid),tg[x&lt;&lt;11]+=tg[x],tg[x]=0);&#125;</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI L,CI R,CI v,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x]+=v*(r-l+1),tg[x]+=v,void();</span><br><span class="line">            PD(x,l,r),L&lt;=mid&amp;&amp;(U(L,R,v,LT),0),R&gt;mid&amp;&amp;(U(L,R,v,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            LL S=0;return PD(x,l,r),L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),S;</span><br><span class="line">        &#125;</span><br><span class="line">        I int G(LL k,PT)&#123;</span><br><span class="line">            if(l==r) return bk[l];</span><br><span class="line">            return PD(x,l,r),T[x&lt;&lt;1]&gt;=k?G(k,LT):G(k-T[x&lt;&lt;1],RT);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL S()&#123;return T[1];&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void U(RI x,RI y)&#123;</span><br><span class="line">    W(top[x]^top[y]) dep[top[x]]&lt;dep[top[y]]&amp;&amp;(swap(x,y),0),T.U(dfn[top[x]],dfn[x],1),x=f[top[x]][0];</span><br><span class="line">    dfn[x]&gt;dfn[y]&amp;&amp;(swap(x,y),0),T.U(dfn[x],dfn[y],1);</span><br><span class="line">&#125;</span><br><span class="line">I int Q()&#123;</span><br><span class="line">    LL k=T.S()/2+1;RI j,i=T.G(k);</span><br><span class="line">    if(T.Q(dfn[i],dfn[i]+sz[i]-1)&gt;=k) return i;</span><br><span class="line">    for(j=20;~j;j--) if(f[i][j]&amp;&amp;T.Q(dfn[f[i][j]],dfn[f[i][j]]+sz[f[i][j]]-1)&lt;k) i=f[i][j];</span><br><span class="line">    return f[i][0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,o,x,y;for(read(n),i=1;i&lt;n;i++) read(x,y),Add(x,y),Add(y,x);for(Dfs1(1,0),Dfs2(1,1),j=1;j&lt;=20;j++) for(i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];</span><br><span class="line">    for(read(m);m--;) read(o,x),o&amp;1?T.U(dfn[x],dfn[x]+sz[x]-1,1):(read(y),U(x,y)),writeln(Q());return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树的重心 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF679E Bear and Bad Powers of 42</title>
      <link href="/2021/07/23/cf679e-bear-and-bad-powers-of-42/"/>
      <url>/2021/07/23/cf679e-bear-and-bad-powers-of-42/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/CF679E">CF679E</a></p></blockquote><p>定义一个正整数是坏的，当且仅当它是 $42$ 的次幂，否则它是好的。</p><p>给定一个长度为 $n$ 的序列 $a_i$，保证初始时所有数都是好的。</p><p>有 $q$ 次操作，每次操作有三种可能：</p><ul><li><code>1 i</code> 查询 $a_i$。</li><li><code>2 l r x</code> 将 $a_{l\dots r}$ 赋值为一个好的数 $x$。</li><li><code>3 l r x</code> 将 $a_{l \dots r}$ 都加上 $x$，重复这一过程直到所有数都变好。</li></ul><p>$n,q \le 10^5,a_i,x \le 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线段树</p><p>考虑对于每个点，维护 $d$ 表示距离该点最近的好数。</p><p>每次操作 $3$ 直接暴力修改即可。</p><p>分析下这样做的复杂度：</p><p>由于在 $10^{18}$ 范围内，$42$ 的幂次只有 $12$ 个，也就是说每次操作三，最多修改 $12$ 次，显然这个复杂度是可以接受的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,m,a[N];</span><br><span class="line">LL pw[15];</span><br><span class="line">#define LW(x) (lower_bound(pw+1,pw+12,x)-pw)</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        struct node&#123;LL d,lg,tgA,tgC;&#125;T[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].d=min(T[x&lt;&lt;1].d,T[x&lt;&lt;11].d))</span><br><span class="line">        #define PD(x) (T[x].tgC&amp;&amp;(T[x&lt;&lt;1].lg=LW(T[x].tgC),T[x&lt;&lt;1].d=pw[T[x&lt;&lt;1].lg]-T[x].tgC,T[x&lt;&lt;1].tgC=T[x].tgC,T[x&lt;&lt;1].tgA=0,\</span><br><span class="line">        T[x&lt;&lt;11].lg=LW(T[x].tgC),T[x&lt;&lt;11].d=pw[T[x&lt;&lt;11].lg]-T[x].tgC,T[x&lt;&lt;11].tgC=T[x].tgC,T[x&lt;&lt;11].tgA=0,T[x].tgC=0),\</span><br><span class="line">        T[x].tgA&amp;&amp;(T[x&lt;&lt;1].tgC?T[x&lt;&lt;1].tgC+=T[x].tgA:T[x&lt;&lt;1].tgA+=T[x].tgA,T[x&lt;&lt;1].d-=T[x].tgA,T[x&lt;&lt;11].tgC?T[x&lt;&lt;11].tgC+=T[x].tgA:T[x&lt;&lt;11].tgA+=T[x].tgA,T[x&lt;&lt;11].d-=T[x].tgA,T[x].tgA=0))</span><br><span class="line">        I void AP(CI x,LL v)&#123;T[x].lg=LW(v),T[x].d=pw[T[x].lg]-v;&#125;</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(l==r) return AP(x,a[l]),void();</span><br><span class="line">            B(LT),B(RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL Q(CI p,PT)&#123;</span><br><span class="line">            if(l==r) return pw[T[x].lg]-T[x].d;</span><br><span class="line">            return PD(x),p&lt;=mid?Q(p,LT):Q(p,RT);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL QD(PT)&#123;</span><br><span class="line">            if(T[x].d&gt;=0) return T[x].d;</span><br><span class="line">            if(l==r) return AP(x,pw[T[x].lg]-T[x].d),T[x].d;</span><br><span class="line">            return PD(x),T[x].d=min(QD(LT),QD(RT));</span><br><span class="line">        &#125;</span><br><span class="line">        I void A(CI L,CI R,LL v,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].tgC?T[x].tgC+=v:T[x].tgA+=v,T[x].d-=v,void();</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(A(L,R,v,LT),0),R&gt;mid&amp;&amp;(A(L,R,v,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void C(CI L,CI R,LL v,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].lg=LW(v),T[x].d=pw[T[x].lg]-v,T[x].tgC=v,T[x].tgA=0,void();</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(C(L,R,v,LT),0),R&gt;mid&amp;&amp;(C(L,R,v,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void UA(CI l,CI r,CI x)&#123;T.A(l,r,x);W(!T.QD()) T.A(l,r,x);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,o,l,r;LL x;for(pw[0]=1,i=1;i&lt;=11;i++) pw[i]=pw[i-1]*42;for(read(n,m),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">    for(T.B();m--;) read(o,l),o&lt;2?writeln(T.Q(l)):(read(r,x),o&amp;1?UA(l,r,x):T.C(l,r,x));return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF453E Little Pony and Lord Tirek</title>
      <link href="/2021/07/23/cf453e-little-pony-and-lord-tirek/"/>
      <url>/2021/07/23/cf453e-little-pony-and-lord-tirek/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>你有 $n$ 只小马（编号从 $1$ 到 $n$）。每只小马有三种属性。</p><p>$s_i$：时间为 $0$ 时这只小马拥有的法力值。</p><p>$m_i$：这只小马可以拥有的最大法力值。</p><p>$r_i$：这只小马单位时间内回复的法力值。</p><p>提雷克会给出 $m$​ 条指令，每一条都可以被描述为 $3$ 个整数：$t_i, l_i, r_i$。表示在时间为 $t_i$ 时，提雷克会从区间 $[l_i,r_i]$ 的小马中吸取魔力，指令保证 $t$ 升序，计算每一条指令之后提雷克可以吸取多少点魔力。</p><p>$1\leq n,m\leq 10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线段树</p><p>打一个标记记录是否拥有初始值、上一次修改的时间。</p><p>然后如果拥有初始值，直接暴力修改，因为单点查询之后会被清零，所以这部分是 $\mathcal O(n)$ 的。</p><p>如果已经被修改过，没有初始值，直接在线段树上按照时间顺序建个 vector，然后二分一下贡献是 $m_i,t_i\times r_i$。显然如果上次修改的时间较早，则是前一种情况，否则是后一种情况，所以直接二分并分别维护前缀、后缀和即可。</p><p>单次区间合并直接双指针扫过去即可，所以总时间复杂度是 $\mathcal O(n\log ^2n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,inf=2e9;</span><br><span class="line">int n,q,tim;</span><br><span class="line">struct Pony&#123;int s,m,r,t;&#125;a[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        struct node&#123;</span><br><span class="line">            vector&lt;int&gt; pre,suf;vector&lt;Pony&gt; f;vector&lt;int&gt; t;</span><br><span class="line">            int tg;</span><br><span class="line">            I void Merge(Cn vector&lt;Pony&gt;&amp; a,Cn vector&lt;Pony&gt;&amp; b)&#123;</span><br><span class="line">                f.clear();RI p=0,sa=a.size(),sb=b.size(),i=0,j=0;W(i&lt;sa&amp;&amp;j&lt;sb) a[i].t&lt;b[j].t?f.push_back(a[i++]):f.push_back(b[j++]);</span><br><span class="line">                W(i&lt;sa) f.push_back(a[i++]);W(j&lt;sb) f.push_back(b[j++]);</span><br><span class="line">                p=0,pre.clear();for(auto i:f) p+=i.m,pre.push_back(p),t.push_back(i.t);</span><br><span class="line">                p=0,suf.clear();for(i=f.size()-1;~i;i--) p+=f[i].r,suf.push_back(p);reverse(suf.begin(),suf.end());</span><br><span class="line">            &#125;</span><br><span class="line">            I int G(RI x)&#123;</span><br><span class="line">                x-=tg;RI p=lower_bound(t.begin(),t.end(),x)-t.begin();</span><br><span class="line">                RI tmp=0;if(p) tmp+=pre[p-1];if(p!=t.size()) tmp+=suf[p]*x;return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;T[N&lt;&lt;2];</span><br><span class="line">        I void PU(CI x)&#123;</span><br><span class="line">            if(T[x&lt;&lt;1].tg==-2T[x&lt;&lt;11].tg==-2) return void(T[x].tg=-2);</span><br><span class="line">            if(T[x&lt;&lt;1].tg==T[x&lt;&lt;11].tg&amp;&amp;T[x&lt;&lt;1].tg&gt;=0) return void(T[x].tg=T[x&lt;&lt;1].tg);</span><br><span class="line">            T[x].tg=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        I void PD(CI x)&#123;T[x].tg&gt;=0&amp;&amp;(T[x&lt;&lt;1].tg=T[x&lt;&lt;11].tg=T[x].tg);&#125;</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(T[x].tg=-2,l==r) return T[x].f.push_back(a[l]),T[x].pre.push_back(a[l].m),T[x].t.push_back(a[l].t),T[x].suf.push_back(a[l].r),void();</span><br><span class="line">            B(LT),B(RT),T[x].Merge(T[x&lt;&lt;1].f,T[x&lt;&lt;11].f);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(l==r&amp;&amp;T[x].tg==-2) return T[x].tg=tim,min(a[l].s+tim*a[l].r,a[l].m);</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R&amp;&amp;T[x].tg&gt;=0)&#123;int tmp=T[x].G(tim);T[x].tg=tim;return tmp;&#125;</span><br><span class="line">            int S=0;return PD(x),L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),PU(x),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,l,r;for(read(n),i=1;i&lt;=n;i++) read(a[i].s,a[i].m,a[i].r),a[i].t=a[i].r?a[i].m/a[i].r:inf;</span><br><span class="line">    for(T.B(),read(q),i=1;i&lt;=q;i++) read(tim,l,r),writeln(T.Q(l,r));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.12 C</title>
      <link href="/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-12-c/"/>
      <url>/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-12-c/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个 $2\cdot 10^9\times 2\cdot 10^9$ 的网格图，现要从 $(x_1,y_1)$ 走到 $(x_2,y_2)$，每次只能走上下左右四个方向且不能走到网格图外面。</p><p>假设当前位置为 $(x,y)$，</p><ul><li>向南走一步（$x$ 加一）的代价为 $2xy^2+2y^2+x^2$；</li><li>向北走一步（$x$ 减一）的代价为 $-2xy^2+2y^2+x^2$；</li><li>向东走一步（$y$ 加一）的代价为 $2x^2y+2x^2+y^2$；</li><li>向西走一步（$y$ 减一）的代价为 $-2x^2y+2x^2+y^2$；</li></ul><p>问从 $(x_1,y_1)$ 走到 $(x_2,y_2)$ 的最小代价对 $998244353$ 取模的结果是多少？</p><p>$1\leq n\leq 5\times 10^4,1\leq x_1,y_1,x_2,y_2\leq 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，路径 $(x_1,y_1)\dots (x_2,y_2)$​ 的花费：<br>$$<br>T&#x3D;x_k^2y_k^2-x_1^2y_1^2+\sum_{i&#x3D;1}^{k-1}x_i^2+y_i^2<br>$$<br>我们把起点和终点有关的项 $x_k^2y_k^2-x_1^2y_1^2-x_k^2-y_k^2$ 先拿掉，相当于我们要最小化：<br>$$<br>\sum_{i&#x3D;1}^kx_i^2+y_i^2<br>$$<br>然后就可以无脑分类讨论了：</p><p><img src="https://z3.ax1x.com/2021/07/22/WBFniR.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=510,P=998244353,Inv6=(P+1)/6;</span><br><span class="line">int Tt,sx,sy,tx,ty,Ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    read(Tt);W(Tt--)&#123;</span><br><span class="line">        read(sx),read(sy),read(tx),read(ty);</span><br><span class="line">        #define LS(x) ((x)*((x)+1)%P*(2*(x)+1)%P*Inv6%P)</span><br><span class="line">        #define Sqr(x) ((x)*(x)%P)</span><br><span class="line">        #define CX(sx,sy,tx,ty) (sy&lt;ty?(LS(ty)-LS(sy)+Sqr(sy)-Sqr(ty)+Sqr(sx)*(ty-sy)%P):(LS(sy)-LS(ty)+Sqr(sx)*(sy-ty)))</span><br><span class="line">        #define CY(sx,sy,tx,ty) (sx&lt;tx?(LS(tx)-LS(sx)+Sqr(sx)-Sqr(tx)+Sqr(sy)*(tx-sx)%P):(LS(sx)-LS(tx)+Sqr(sy)*(sx-tx)))</span><br><span class="line">        #define CZ(sx,sy,tx,ty) (sx&lt;tx?(2*(LS(tx)-LS(sx))-Sqr(tx)+Sqr(sx)+2*(LS(tx)-LS(sx)-Sqr(tx)+Sqr(sx))%P):(2*(LS(sx)-LS(tx))-Sqr(sx)+Sqr(tx)+2*(LS(sx)-LS(tx))%P))</span><br><span class="line">        Ans=(Sqr(tx)*Sqr(ty)%P-Sqr(sx)*Sqr(sy))%P;</span><br><span class="line">        if(sx==tx)&#123;Ans+=CX(sx,sy,tx,ty);&#125;else</span><br><span class="line">        if(sy==ty)&#123;Ans+=CY(sx,sy,tx,ty);&#125;else</span><br><span class="line">        if(sx==sy&amp;&amp;tx==ty)&#123;Ans+=CZ(sx,sy,tx,ty);&#125;else</span><br><span class="line">        if(sx&lt;tx)&#123;</span><br><span class="line">            if(sy&gt;=ty) (Ans+=(CX(sx,sy,sx,ty)+CY(sx,ty,tx,ty))%P)%=P;else</span><br><span class="line">            if(sx&gt;=sy&amp;&amp;tx&gt;=ty) (Ans+=(sx&lt;=ty?(CX(sx,sy,sx,sx)+CZ(sx,sx,ty,ty)+CY(ty,ty,tx,ty)):(CX(sx,sy,sx,ty)+CY(sx,ty,tx,ty)))%P)%=P;else</span><br><span class="line">            if(sx&lt; sy&amp;&amp;tx&lt; ty) (Ans+=(sy&lt;=tx?(CY(sx,sy,sy,sy)+CZ(sy,sy,tx,tx)+CX(tx,tx,tx,ty)):(CY(sx,sy,tx,sy)+CX(tx,sy,tx,ty)))%P)%=P;else</span><br><span class="line">            if(sx&gt;=sy&amp;&amp;tx&lt; ty) (Ans+=(CX(sx,sy,sx,sx)+CZ(sx,sx,tx,tx)+CX(tx,tx,tx,ty))%P)%=P;else</span><br><span class="line">            if(sx&lt; sy&amp;&amp;tx&gt;=ty) (Ans+=(CY(sx,sy,sy,sy)+CZ(sy,sy,ty,ty)+CY(ty,ty,tx,ty))%P)%=P;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(sy&lt;=ty) (Ans+=(CY(sx,sy,tx,sy)+CX(tx,sy,tx,ty))%P)%=P;else</span><br><span class="line">            if(sx&gt;=sy&amp;&amp;tx&gt;=ty) (Ans+=(sy&lt;=tx?(CY(sx,sy,tx,sy)+CX(tx,sy,tx,ty)):(CY(sx,sy,sy,sy)+CZ(sy,sy,tx,tx)+CX(tx,tx,tx,ty)))%P)%=P;else</span><br><span class="line">            if(sx&lt; sy&amp;&amp;tx&lt; ty) (Ans+=(sx&lt;=ty?(CX(sx,sy,sx,ty)+CY(sx,ty,tx,ty)):(CX(sx,sy,sx,sx)+CZ(sx,sx,ty,ty)+CY(ty,ty,tx,ty)))%P)%=P;else</span><br><span class="line">            if(sx&gt;=sy&amp;&amp;tx&lt; ty) (Ans+=(CY(sx,sy,sy,sy)+CZ(sy,sy,ty,ty)+CY(ty,ty,tx,ty))%P)%=P;else</span><br><span class="line">            if(sx&lt; sy&amp;&amp;tx&gt;=ty) (Ans+=(CX(sx,sy,sx,sx)+CZ(sx,sx,tx,tx)+CX(tx,tx,tx,ty))%P)%=P;</span><br><span class="line">        &#125;write((Ans+P)%P),pc(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 分类讨论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.11 D</title>
      <link href="/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-11-d/"/>
      <url>/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-11-d/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定三个长度为 $n$ 的正整数序列 $A,B,C$。</p><p>定义 $f(X,l,r)$ 表示在序列 $X$ 中，$\max X_i-\min X_i$。</p><p>定义一个区间 $[l,r]$ 的权值为 $f(A,l,r)\times f(B,l,r)\times f(C,l,r)$。</p><p>求对于所有 $1\leq l\leq r\leq n$，区间 $[l,r]$ 的权值之和对 $2^{32}$​ 取模的结果。</p><p>$1\leq n\leq 10^5,1\leq A_i,B_i,C_i\leq10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑分治。</p><p>首先答案的式子可以展开。</p><p>令 $\max_{i&#x3D;l}^rA_i&#x3D;MxA,\min_{i&#x3D;l}^r&#x3D;MnA,\max_{i&#x3D;l}^rB_i&#x3D;MxB,\min_{i&#x3D;l}^rB_i&#x3D;MnB,\max_{i&#x3D;l}^rC_i&#x3D;MxC,\min_{i&#x3D;l}^rC_i&#x3D;MnC$。​<br>$$<br>\begin{align}<br>f(A,l,r)\times f(B,l,r)\times f(C,l,r) &amp; &#x3D; (\max_{i&#x3D;l}^rA_i-\min_{i&#x3D;l}^rA_i)\times(\max_{i&#x3D;l}^rB_i-\min_{i&#x3D;l}^rB_i)\times(\max_{i&#x3D;l}^rC_i-\min_{i&#x3D;l}^rC_i)\<br>&amp; &#x3D; MxA\times MxB\times MxC-MxA\times MxB\times MnC-MxA\times MnB\times MxC-MnA\times MxB\times MxC+MxA\times MnB\times MnC+MnA\times MxB\times MnC+MnA\times MnB\times MxC-MnA\times MnB\times MnC<br>\end{align}<br>$$<br>然后对于每个式子，直接分治处理，倒序枚举 $[l,mid]$​​​​​​​，然后三个指针扫 $[mid+1,r]$​​​​​ 分类讨论（取左边为最大值&#x2F;取右边为最大值）。</p><p>码量稍大。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">#define ui unsigned int</span><br><span class="line">using namespace std;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">ui n,a[N],b[N],c[N],A[N],B[N],C[N],Ans,ans,SA[N],SB[N],SC[N],AB[N],AC[N],BC[N],ABC[N];</span><br><span class="line">I void Solve1(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve1(l,mid),Solve1(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=max(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=max(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=max(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=max(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=max(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=max(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&lt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&lt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&lt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve2(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve2(l,mid),Solve2(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=max(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=max(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=min(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=min(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=min(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=min(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&lt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&gt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&gt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve3(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve3(l,mid),Solve3(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=min(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=min(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=max(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=max(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=min(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=min(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&gt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&lt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&gt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve4(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve4(l,mid),Solve4(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=min(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=min(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=min(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=min(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=max(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=max(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&gt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&gt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&lt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve5(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve5(l,mid),Solve5(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=min(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=min(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=max(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=max(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=max(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=max(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&gt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&lt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&lt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve6(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve6(l,mid),Solve6(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=max(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=max(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=min(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=min(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=max(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=max(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&lt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&gt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&lt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve7(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve7(l,mid),Solve7(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=max(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=max(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=max(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=max(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=min(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=min(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&lt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&lt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&gt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void Solve8(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]*b[l]*c[l]);</span><br><span class="line">    RI i,ja,jb,jc,mid=l+r&gt;&gt;1;Solve8(l,mid),Solve8(mid+1,r);</span><br><span class="line">    for(A[mid]=a[mid],i=mid-1;i&gt;=l;i--) A[i]=min(A[i+1],a[i]);for(A[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) A[i]=min(A[i-1],a[i]);</span><br><span class="line">    for(B[mid]=b[mid],i=mid-1;i&gt;=l;i--) B[i]=min(B[i+1],b[i]);for(B[mid+1]=b[mid+1],i=mid+2;i&lt;=r;i++) B[i]=min(B[i-1],b[i]); </span><br><span class="line">    for(C[mid]=c[mid],i=mid-1;i&gt;=l;i--) C[i]=min(C[i+1],c[i]);for(C[mid+1]=c[mid+1],i=mid+2;i&lt;=r;i++) C[i]=min(C[i-1],c[i]);</span><br><span class="line">    SA[mid]=SB[mid]=SC[mid]=AB[mid]=AC[mid]=BC[mid]=ABC[mid]=0;</span><br><span class="line">    for(i=mid+1;i&lt;=r;i++) SA[i]=SA[i-1]+A[i],SB[i]=SB[i-1]+B[i],SC[i]=SC[i-1]+C[i],AB[i]=AB[i-1]+A[i]*B[i],AC[i]=AC[i-1]+A[i]*C[i],BC[i]=BC[i-1]+B[i]*C[i],ABC[i]=ABC[i-1]+A[i]*B[i]*C[i];</span><br><span class="line">    for(ja=jb=jc=mid+1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(ja&lt;=r&amp;&amp;A[ja]&gt;=A[i]) ja++;W(jb&lt;=r&amp;&amp;B[jb]&gt;=B[i]) jb++;W(jc&lt;=r&amp;&amp;C[jc]&gt;=C[i]) jc++;</span><br><span class="line">             if(ja&lt;=jb&amp;&amp;jb&lt;=jc) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jb-1]-SA[ja-1])+C[i]*(AB[jc-1]-AB[jb-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(ja&lt;=jc&amp;&amp;jc&lt;=jb) Ans+=A[i]*B[i]*C[i]*(ja-mid-1)+B[i]*C[i]*(SA[jc-1]-SA[ja-1])+B[i]*(AC[jb-1]-AC[jc-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jb&lt;=ja&amp;&amp;ja&lt;=jc) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[ja-1]-SB[jb-1])+C[i]*(AB[jc-1]-AB[ja-1])+ABC[r]-ABC[jc-1];</span><br><span class="line">        else if(jb&lt;=jc&amp;&amp;jc&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jb-mid-1)+A[i]*C[i]*(SB[jc-1]-SB[jb-1])+A[i]*(BC[ja-1]-BC[jc-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">        else if(jc&lt;=ja&amp;&amp;ja&lt;=jb) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[ja-1]-SC[jc-1])+B[i]*(AC[jb-1]-AC[ja-1])+ABC[r]-ABC[jb-1];</span><br><span class="line">        else if(jc&lt;=jb&amp;&amp;jb&lt;=ja) Ans+=A[i]*B[i]*C[i]*(jc-mid-1)+A[i]*B[i]*(SC[jb-1]-SC[jc-1])+A[i]*(BC[ja-1]-BC[jb-1])+ABC[r]-ABC[ja-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(scanf(&quot;%u&quot;,&amp;n),i=1;i&lt;=n;i++) scanf(&quot;%u&quot;,&amp;a[i]);for(i=1;i&lt;=n;i++) scanf(&quot;%u&quot;,&amp;b[i]);for(i=1;i&lt;=n;i++) scanf(&quot;%u&quot;,&amp;c[i]);</span><br><span class="line">    Solve1(1,n),Solve2(1,n),Solve3(1,n),Solve4(1,n),ans=Ans,Ans=0,</span><br><span class="line">    Solve5(1,n),Solve6(1,n),Solve7(1,n),Solve8(1,n),ans+=-Ans;</span><br><span class="line">    return printf(&quot;%u\n&quot;,ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.10 D</title>
      <link href="/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-10-d/"/>
      <url>/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-10-d/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一棵 $n$ 个节点的树，有 $m$ 个询问，每次给定 $l,r$，查询若只保留点编号在 $[l,r]$ 的点，边编号在 $[l,r]$ 的边，有多少个连通块。</p><p>此时点 $a$ 与点 $b$ 连通当且仅当 $l\leq a,b\leq r$，且 $a,b$ 在树上的简单路径中所有的点与边的编号都在 $[l,r]$ 之间。</p><p>$1\leq n,m\leq 10^6$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑连通块个数&#x3D;点数-边数。</p><p>而点数 $&#x3D;r-l+1$​ 是确定的，那么只需要考虑如何维护边数即可。</p><p>那么如何判断是否是有用的边？</p><p>其实就等价于对于边 $i$，满足 $l\leq i\leq r$，并且 $i$ 连接的两个点 $x,y$，满足 $l\leq x,y\leq r$。</p><p>也就是说，对于边 $i$，需要满足 $l\leq \min(i,x,y)\leq \max(i,x,y)\leq r$​。</p><p>然后这题就成了二维数点问题。</p><p>可以先把询问离线。</p><p>按照 $r$ 从小到大，依次加入点与边。</p><p>然后用树状数组维护即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(RI x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">Cn int N=1e6+10;</span><br><span class="line">int n,m,Ans[N];</span><br><span class="line">struct Edge&#123;int x,y;&#125;e[N];</span><br><span class="line">struct Que&#123;int x,y,id;&#125;q[N];</span><br><span class="line">I bool cmp(Cn Edge&amp; x,Cn Edge&amp; y)&#123;return x.x&gt;y.x;&#125;</span><br><span class="line">I bool cmp2(Cn Que&amp; x,Cn Que&amp; y)&#123;return x.x&gt;y.x;&#125;</span><br><span class="line">class TreeArray&#123;</span><br><span class="line">    private:</span><br><span class="line">        int c[N];</span><br><span class="line">        #define lowbit(x) (x&amp;(-x))</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI x,CI y)&#123;RI i;for(i=x;i&lt;=n;i+=lowbit(i)) c[i]+=y;&#125;</span><br><span class="line">        I int Q(CI x)&#123;RI i,S=0;for(i=x;i;i-=lowbit(i)) S+=c[i];return S;&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,l,r;for(read(n),read(m),i=1;i&lt;n;i++) read(l),read(r),e[i]=(Edge)&#123;min(min(l,r),i),max(max(l,r),i)&#125;;</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(q[i].x),read(q[i].y),q[i].id=i;</span><br><span class="line">    for(j=1,sort(e+1,e+n,cmp),sort(q+1,q+m+1,cmp2),i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        W(j&lt;n&amp;&amp;e[j].x&gt;=q[i].x) T.U(e[j].y,1),j++;</span><br><span class="line">        Ans[q[i].id]=q[i].y-q[i].x+1-T.Q(q[i].y);</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) write(Ans[i]),pc(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.07.09 D</title>
      <link href="/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-09-d/"/>
      <url>/2021/07/22/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-07-09-d/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一棵 $n$​ 个节点的树 $T$​，有 $m$​ 个询问，每次询问给定 $l,r$​，问存在多少个 $k\in Z$​，使从树上编号为 $l$​ 的点沿着 $l\rightarrow r$​ 的简单路径走 $k$​ 步恰好到达 $k$​。</p><p>$1\leq n\leq 3\times 10^5,1\leq m\leq 3\times 10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑树上从 $l$​ 走到 $r$​ 的路径可以拆成两段：$l\rightarrow lca,lca\rightarrow r$​。</p><p>令当前节点为 $k$，则可以分类讨论：</p><ul><li>$l\rightarrow lca$​，显然此时步数为 $dep_l-dep_k$，那么由题意可得 $dep_l-dep_k&#x3D;k$，移项，$dep_l&#x3D;k+dep_k$，因此只需要预处理出 $k+dep_k$，然后每次询问利用树链剖分直接主席树上查询即可。</li><li>$lca\rightarrow r$，显然此时步数为 $dep_k-dep_{lca}+dep_l-dep_{lca}$，那么由题意可得 $dep_k+dep_l-2\times dep_{lca}&#x3D;k$，移项，$dep_l-2\times dep_{lca}&#x3D;k-dep_k$，与上一类同理处理即可。</li></ul><p>最后注意下 $lca$ 可能算两次的情况。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp; </span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar</span><br><span class="line">using namespace std;</span><br><span class="line">Cn int N=3e5+10,M=11;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(RI x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">int n,m,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,dep[N],f[N],sz[N],mx[N],top[N],dfn[N],cnt,rtA[N&lt;&lt;1],rtB[N&lt;&lt;1],A[N&lt;&lt;1],B[N&lt;&lt;1],CA,CB;</span><br><span class="line">struct Que&#123;int l,r;&#125;q[N];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Dfs1(CI x,CI fa)&#123;</span><br><span class="line">    RI i;for(dep[x]=dep[f[x]=fa]+(sz[x]=1),i=fir[x];i;i=nxt[i]) to^fa&amp;&amp;(Dfs1(to,x),sz[x]+=sz[to],sz[to]&gt;sz[mx[x]]&amp;&amp;(mx[x]=to));</span><br><span class="line">&#125;</span><br><span class="line">I void Dfs2(CI x,CI Top)&#123;</span><br><span class="line">    if(top[x]=Top,dfn[x]=++cnt,mx[x]) Dfs2(mx[x],Top);</span><br><span class="line">    RI i;for(i=fir[x];i;i=nxt[i]) to^mx[x]&amp;&amp;to^f[x]&amp;&amp;(Dfs2(to,to),0);</span><br><span class="line">&#125;</span><br><span class="line">I int LCA(RI x,RI y)&#123;</span><br><span class="line">    W(top[x]^top[y]) dep[top[x]]&lt;dep[top[y]]&amp;&amp;(swap(x,y),0),x=f[top[x]];</span><br><span class="line">    return dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line">class ChairmanTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id;struct node&#123;int l,r,v;&#125;T[N*40];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define LT T[x].l,l,mid</span><br><span class="line">        #define RT T[x].r,mid+1,r</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,RI pre,int&amp; x,CI l=1,CI r=n)&#123;</span><br><span class="line">            if(T[x=++id]=T[pre],T[x].v++,l==r) return ;</span><br><span class="line">            p&lt;=mid?U(p,T[pre].l,LT):U(p,T[pre].r,RT);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI L,CI R,CI x,CI l=1,CI r=n)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].v;</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;TA,TB;</span><br><span class="line">I int QA(RI x,RI y,CI v)&#123;</span><br><span class="line">    RI S=0;W(top[x]^top[y]) S+=TA.Q(dfn[top[x]],dfn[x],rtA[v]),x=f[top[x]];</span><br><span class="line">    return S+TA.Q(dfn[y],dfn[x],rtA[v]);</span><br><span class="line">&#125;</span><br><span class="line">I int QB(RI x,RI y,CI v)&#123;</span><br><span class="line">    RI S=0;W(top[x]^top[y]) S+=TB.Q(dfn[top[x]],dfn[x],rtB[v]),x=f[top[x]];</span><br><span class="line">    return S+TB.Q(dfn[y]+1,dfn[x],rtB[v]);</span><br><span class="line">&#125;</span><br><span class="line">#define LWA(x) (lower_bound(A+1,A+CA+1,x)-A)</span><br><span class="line">#define LWB(x) (lower_bound(B+1,B+CB+1,x)-B)</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y,t;for(read(n),read(m),i=1;i&lt;n;i++) read(x),read(y),Add(x,y),Add(y,x);</span><br><span class="line">    for(Dfs1(1,0),Dfs2(1,1),i=1;i&lt;=m;i++) read(q[i].l),read(q[i].r),t=LCA(q[i].l,q[i].r),A[++CA]=dep[q[i].l],B[++CB]=dep[t]*2-dep[q[i].l];</span><br><span class="line">    for(i=1;i&lt;=n;i++) A[++CA]=i+dep[i],B[++CB]=dep[i]-i;sort(A+1,A+CA+1),CA=unique(A+1,A+CA+1)-A-1,sort(B+1,B+CB+1),CB=unique(B+1,B+CB+1)-B-1;</span><br><span class="line">    for(i=1;i&lt;=n;i++) TA.U(dfn[i],rtA[LWA(i+dep[i])],rtA[LWA(i+dep[i])]),TB.U(dfn[i],rtB[LWB(dep[i]-i)],rtB[LWB(dep[i]-i)]);</span><br><span class="line">    for(i=1;i&lt;=m;i++) t=LCA(q[i].l,q[i].r),write(QA(q[i].l,t,LWA(dep[q[i].l]))+QB(q[i].r,t,LWB(dep[t]*2-dep[q[i].l]))),pc(&#x27;\n&#x27;);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF765F Souvenirs</title>
      <link href="/2021/07/21/cf765f-souvenirs/"/>
      <url>/2021/07/21/cf765f-souvenirs/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/CF765F">CF765F</a></p></blockquote><p>给定一个长度为 $n$ 的序列 $a_i$，有 $m$ 个询问，每次询问给定 $l,r$，求对于 $i,j\in[l,r]$，且满足 $i\not &#x3D; j$，$a_i - a_j$ 的最小值。</p><p>$1\leq n\leq 10^5,1\leq m\leq 3\times 10^5,0\leq a_i\leq 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>分块（感觉 mrsrz 讲的很清楚了，但感觉复杂度分析有点奇怪？很好奇 mrsrz 错误的块长是咋过的）。</p><p>设 $suf_{i,j}$ 表示第 $i$ 个数字与第 $i$ 个数字所对应的块后面的块一直到第 $j$ 个块的贡献，$pre_{i,j}$ 表示第 $i$ 个数字所对应的块后面的块一直到第 $j$ 个块的贡献，$F_{i,j}$ 表示第 $i$ 个块到第 $j$ 个块的答案。</p><p>显然最小值一定是权值 $a_i$ 相邻的两个数之间所取得，所以可以考虑先对于每个块按照权值从小到大排一遍序，然后暴力枚举每一个位置作为 $a_i$，然后双指针枚 $j$，使得 $a_i&lt;a_j$，那么以 $a_i$ 更新位置 $j$ 所在块的 $suf_i$。</p><p>然后 $suf_{i,j}$ 显然是可以从 $suf_{i,j-1}$ 或者是 $suf_{i+1,j}$ 继承来的，那么直接取个 $\min$ 即可。</p><p>然后 $pre$ 的预处理同理。</p><p>那么 $F$ 显然可以由 $pre$ 转移，$F_{i,j}&#x3D;pre_{R_j,i}$，注意 $F_{i,j}$ 还可以从 $F_{i,j-1}$ 以及 $F_{j,j}$ 继承。</p><p>至此就可以在 $\mathcal O(\frac{n^2}{B})$ 的时间内预处理出 $F,pre,suf$。</p><p>查询的时候可以把散块暴力双指针扫描（还是利用答案一定是权值排序后相邻两个数间取得的性质），中间整块查询答案 $F_i,j$ 即可，两边散块到中间的答案直接查 $pre,suf$，具体细节详见代码，显然这部分的时间复杂度是 $\mathcal O(mB)$。</p><p>令块大小为 $B$，则总时间复杂度为 $\mathcal O(\frac{n^2}B+mB)$。</p><p>显然当 $B&#x3D;\frac{n}{\sqrt m}\approx 182$ 时，总时间复杂度最优，为 $\mathcal O(n\sqrt m)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(2)</span><br><span class="line">#pragma GCC optimize(&quot;Ofast&quot;)</span><br><span class="line">#pragma GCC target(&quot;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma&quot;)</span><br><span class="line">#pragma GCC optimize(&quot;unroll-loops&quot;)</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=N/185+5;</span><br><span class="line">int n,m,S=185,a[N],L[M],R[M],F[M][M],suf[N][M],pre[N][M],tot;</span><br><span class="line">#define abs(x) ((x)&lt;0?-(x):(x))</span><br><span class="line">#define P pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;P&gt; b[M];</span><br><span class="line">I void B()&#123;</span><br><span class="line">    RI i,j,k,t,X,sz;for(i=1;i&lt;=n;i++) !((i-1)%S)&amp;&amp;(R[tot]=i-1,L[++tot]=i),b[tot].push_back(MP(a[i],i));R[tot]=n;</span><br><span class="line">    for(memset(pre,63,sizeof(pre)),memset(suf,63,sizeof(suf)),i=1;i&lt;=tot;i++) for(F[i][i]=2e9,sort(b[i].begin(),b[i].end()),j=1;j&lt;b[i].size();j++) F[i][i]=min(F[i][i],abs(b[i][j].fi-b[i][j-1].fi));</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=i+1;j&lt;=tot;j++)&#123;for(t=0,k=0,sz=b[i].size();k&lt;sz;k++)&#123;W(t&lt;b[j].size()&amp;&amp;b[j][t].fi&lt;b[i][k].fi) t++;t&gt;0&amp;&amp;(suf[b[i][k].se][j]=min(suf[b[i][k].se][j],abs(b[i][k].fi-b[j][t-1].fi))),t&lt;b[j].size()&amp;&amp;(suf[b[i][k].se][j]=min(suf[b[i][k].se][j],abs(b[i][k].fi-b[j][t].fi)));&#125;for(k=R[i]-1;k&gt;=L[i];k--) suf[k][j]=min(suf[k][j],suf[k+1][j]);&#125;//排过序后，双指针扫描预处理出 suf</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=i-1;j;j--)&#123;for(t=0,k=0,sz=b[i].size();k&lt;sz;k++)&#123;W(t&lt;b[j].size()&amp;&amp;b[j][t].fi&lt;b[i][k].fi) t++;t&gt;0&amp;&amp;(pre[b[i][k].se][j]=min(pre[b[i][k].se][j],abs(b[i][k].fi-b[j][t-1].fi))),t&lt;b[j].size()&amp;&amp;(pre[b[i][k].se][j]=min(pre[b[i][k].se][j],abs(b[i][k].fi-b[j][t].fi)));&#125;for(k=L[i]+1;k&lt;=R[i];k++) pre[k][j]=min(pre[k][j],pre[k-1][j]);&#125;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=L[i];j&lt;=R[i];j++)&#123;for(k=i+2;k&lt;=tot;k++) suf[j][k]=min(suf[j][k],suf[j][k-1]);for(k=i-2;k&gt;=1;k--) pre[j][k]=min(pre[j][k],pre[j][k+1]);&#125;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=i+1;j&lt;=tot;j++) F[i][j]=min(pre[R[j]][i],min(F[i][j-1],F[j][j]));//整块答案更新</span><br><span class="line">&#125;</span><br><span class="line">#define bl(x) ((x-1)/S+1)</span><br><span class="line">vector&lt;int&gt; v,g;</span><br><span class="line">I int Merge(CI L1,CI R1,CI L2,CI R2)&#123;//两个散块暴力双指针扫描</span><br><span class="line">    RI i,j,X=2e9,sz,vs,gs;for(v.clear(),g.clear(),sz=b[bl(L1)].size(),i=0;i&lt;sz;i++) if(L1&lt;=b[bl(L1)][i].se&amp;&amp;b[bl(L1)][i].se&lt;=R1) v.push_back(b[bl(L1)][i].fi);</span><br><span class="line">    for(i=0,sz=b[bl(L2)].size();i&lt;sz;i++) if(L2&lt;=b[bl(L2)][i].se&amp;&amp;b[bl(L2)][i].se&lt;=R2) g.push_back(b[bl(L2)][i].fi);</span><br><span class="line">    for(j=i=0,vs=v.size(),gs=g.size();i&lt;vs;i++)&#123;W(j&lt;gs&amp;&amp;g[j]&lt;v[i]) j++;j&gt;0&amp;&amp;(X=min(X,abs(g[j-1]-v[i]))),j&lt;g.size()&amp;&amp;(X=min(X,abs(g[j]-v[i])));&#125;return X;</span><br><span class="line">&#125;</span><br><span class="line">I int G(CI L,CI R)&#123;//单块内暴力</span><br><span class="line">    RI i,j,X,sz=b[bl(L)].size();j=0;W(j&lt;sz&amp;&amp;!(L&lt;=b[bl(L)][j].se&amp;&amp;b[bl(L)][j].se&lt;=R)) j++;</span><br><span class="line">    for(X=2e9,i=j+1;i&lt;sz;j=i,i=j+1)&#123;W(i&lt;sz&amp;&amp;!(L&lt;=b[bl(L)][i].se&amp;&amp;b[bl(L)][i].se&lt;=R)) i++;i&lt;sz&amp;&amp;(X=min(X,abs(b[bl(L)][i].fi-b[bl(L)][j].fi)));&#125;return X;</span><br><span class="line">&#125;</span><br><span class="line">I int Q(CI l,CI r)&#123;</span><br><span class="line">    RI i,j,X;if(bl(l)==bl(r)) return G(l,r);</span><br><span class="line">    return X=min(suf[l][bl(r)-1],pre[r][bl(l)+1]),bl(l)+1&lt;=bl(r)-1&amp;&amp;(X=min(X,F[bl(l)+1][bl(r)-1])),X=min(X,min(G(l,R[bl(l)]),G(L[bl(r)],r))),min(X,Merge(l,R[bl(l)],L[bl(r)],r));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r;for(read(n),i=1;i&lt;=n;i++) read(a[i]);for(B(),read(m),i=1;i&lt;=m;i++) read(l,r),writeln(Q(l,r));return clear(),0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>义乌中学暑假集训 2021.7.8 D</title>
      <link href="/2021/07/08/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-7-8-d/"/>
      <url>/2021/07/08/%E4%B9%89%E4%B9%8C%E4%B8%AD%E5%AD%A6%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD-2021-7-8-d/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>见到 lxl 小姐姐真的好好好兴奋！！！</p><p>果然好可爱</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个序列 $A$，求所有 $1\leq l \leq r \leq n$ 的区间 $[l,r]$ 的最大子段和的和，答案对 $2^{64}$ 取模。</p><p>$1\leq n\leq 10^5,-10^9\leq A_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑分治，求跨越左右两个区间的贡献。</p><p>维护一下区间的 $suf$ 表示后缀和，$pre$ 表示前缀和，$sl$ 表示左区间的后缀最大子段和，$sr$ 表示右区间的前缀最大子段和。</p><p>若 $l\leq i \leq mid,mid+1\leq j\leq r$，显然答案为 $\max{suf_i+pre_j,sl_i,sr_j,}$。</p><p>然而三个数的最大值难以维护，所以考虑拆成两种情况。</p><ol><li>$sl_i\ge sr_j$ 所以答案就变成了 $\max{suf_i+pre_j,sl_i}$，然后先减去 $suf_i$，再加回去，可以得到 $\max{pre_j,sl_i-suf_i}+suf_i$，这样 $j$ 就独自只在一个候选 $\max$ 之中了，这样比较好维护。 那么再继续拆分，分两类讨论，直接根据以上条件二维偏序即可</li><li>$sl_i&lt;sr_j$ 和情况 $1$ 同理，这里不再赘述。</li></ol><p>然后二维偏序可以直接用 sort + BIT 进行，博主是开了 $3$ 个树状数组。</p><p>最后喷一下 lxl，明明 $pre,suf,sl,sr$ 全是有单调性的，直接二分就好了（害我写了二维偏序跑得比二分慢了 $8s$）</p><p>放张图纪念一下我的推狮子：</p><p><img src="https://z3.ax1x.com/2021/07/08/ROO7z4.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline</span><br><span class="line">#define W while</span><br><span class="line">#define RI register int </span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define pc putchar </span><br><span class="line">#define int LL</span><br><span class="line">#define LL long long </span><br><span class="line">#define ull unsigned long long </span><br><span class="line">using namespace std;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">I void read(int&amp; x)&#123;RI f=1;char c=gc();x=0;W(!(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;)) f=c^&#x27;-&#x27;?f:-1,c=gc();W(&#x27;0&#x27;&lt;=c&amp;&amp;c&lt;=&#x27;9&#x27;) x=x*10+(c-&#x27;0&#x27;),c=gc();x*=f;&#125;</span><br><span class="line">I void write(ull x)&#123;x&gt;=10&amp;&amp;(write(x/10),0),pc(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">int n,a[N];</span><br><span class="line">LL P,s1[N],s2[N],pre[N],suf[N];</span><br><span class="line">ull Ans;</span><br><span class="line">struct node&#123;LL pre,suf,sum,ans;&#125;T[N&lt;&lt;2];</span><br><span class="line">I node operator + (Cn node&amp; x,Cn node&amp; y)&#123;return (node)&#123;max(x.pre,x.sum+y.pre),max(x.suf+y.sum,y.suf),x.sum+y.sum,max(max(x.ans,y.ans),x.suf+y.pre)&#125;;&#125;</span><br><span class="line">class SegmentTree&#123;//线段树求最大子段和</span><br><span class="line">    private:</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x]=T[x&lt;&lt;1]+T[x&lt;&lt;11])</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x]=(node)&#123;a[l],a[l],a[l],a[l]&#125;);</span><br><span class="line">            B(LT),B(RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I node Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            if(R&lt;=mid) return Q(L,R,LT);if(L&gt;mid) return Q(L,R,RT);</span><br><span class="line">            return Q(L,R,LT)+Q(L,R,RT);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">struct Temp&#123;LL s;int id;&#125;;</span><br><span class="line">I bool cmp1(Cn Temp&amp; x,Cn Temp&amp; y)&#123;return x.s&lt;y.s;&#125;</span><br><span class="line">I bool cmp2(Cn Temp&amp; x,Cn Temp&amp; y)&#123;return x.s&gt;y.s;&#125;</span><br><span class="line">class TreeArray&#123;//树状数组</span><br><span class="line">    private:</span><br><span class="line">        LL c[N];</span><br><span class="line">        #define lowbit(x) (x&amp;(-x))</span><br><span class="line">    public:</span><br><span class="line">        I void C(CI x)&#123;RI i;for(i=x;i&lt;=n;i+=lowbit(i)) c[i]=0;&#125;</span><br><span class="line">        I void U(CI x,CI y)&#123;RI i;for(i=x;i&lt;=n;i+=lowbit(i)) c[i]+=y;&#125;</span><br><span class="line">        I LL Q(CI x)&#123;RI i;LL S=0;for(i=x;i;i-=lowbit(i)) S+=c[i];return S;&#125;</span><br><span class="line">&#125;A,B,C;</span><br><span class="line">#define LW(x) (lower_bound(b+1,b+c2+1,x)-b)</span><br><span class="line">I void Solve(CI l,CI r)&#123;</span><br><span class="line">    if(l==r) return void(Ans+=a[l]);</span><br><span class="line">    RI i,j,c1,c2;Solve(l,mid),Solve(mid+1,r);Temp t[r-l+5];LL b[r-l+5];</span><br><span class="line">    for(suf[mid]=a[mid],i=mid-1;i&gt;=l;i--) suf[i]=suf[i+1]+a[i];</span><br><span class="line">    for(pre[mid+1]=a[mid+1],i=mid+2;i&lt;=r;i++) pre[i]=pre[i-1]+a[i];//预处理出前/后缀和</span><br><span class="line">    for(s1[mid]=S.Q(mid,mid).ans,i=mid-1;i&gt;=l;i--) s1[i]=max(s1[i+1],S.Q(i,mid).ans);</span><br><span class="line">    for(s2[mid+1]=S.Q(mid+1,mid+1).ans,i=mid+2;i&lt;=r;i++) s2[i]=max(s2[i-1],S.Q(mid+1,i).ans);//预处理出前/后缀最大子段和</span><br><span class="line">    for(i=mid-1;i&gt;=l;i--) suf[i]=max(suf[i+1],suf[i]);for(i=mid+2;i&lt;=r;i++) pre[i]=max(pre[i],pre[i-1]);//记得取 max</span><br><span class="line">    for(c2=0,i=mid+1;i&lt;=r;i++) b[++c2]=pre[i];for(i=l;i&lt;=mid;i++) b[++c2]=s1[i]-suf[i];//第一种情况</span><br><span class="line">    sort(b+1,b+c2+1),c2=unique(b+1,b+c2+1)-b-1;</span><br><span class="line">    for(c1=0,i=mid+1;i&lt;=r;i++) t[++c1]=(Temp)&#123;s2[i],i&#125;;</span><br><span class="line">    for(sort(t+1,t+c1+1,cmp1),j=1,i=mid;i&gt;=l;i--)&#123;</span><br><span class="line">        W(j&lt;=c1&amp;&amp;t[j].s&lt;=s1[i]) A.U(LW(pre[t[j].id]),1),B.U(LW(pre[t[j].id]),pre[t[j].id]),j++;//二维偏序</span><br><span class="line">        Ans+=A.Q(LW(s1[i]-suf[i]))*s1[i]+(A.Q(n)-A.Q(LW(s1[i]-suf[i])))*suf[i]+(B.Q(n)-B.Q(LW(s1[i]-suf[i])));</span><br><span class="line">    &#125;for(i=1;i&lt;j;i++) A.C(LW(pre[t[i].id])),B.C(LW(pre[t[i].id]));//记得清空</span><br><span class="line">    for(c2=0,i=mid+1;i&lt;=r;i++) b[++c2]=s2[i]-pre[i];for(i=l;i&lt;=mid;i++) b[++c2]=suf[i];//第二种情况</span><br><span class="line">    sort(b+1,b+c2+1),c2=unique(b+1,b+c2+1)-b-1;</span><br><span class="line">    for(sort(t+1,t+c1+1,cmp2),j=1,i=l;i&lt;=mid;i++)&#123;</span><br><span class="line">        W(j&lt;=c1&amp;&amp;t[j].s&gt;s1[i]) A.U(LW(s2[t[j].id]-pre[t[j].id]),1),B.U(LW(s2[t[j].id]-pre[t[j].id]),pre[t[j].id]),C.U(LW(s2[t[j].id]-pre[t[j].id]),s2[t[j].id]),j++;//二维偏序</span><br><span class="line">        Ans+=A.Q(LW(suf[i]))*suf[i]+B.Q(LW(suf[i]))+(C.Q(n)-C.Q(LW(suf[i])));</span><br><span class="line">    &#125;for(i=1;i&lt;j;i++) A.C(LW(s2[t[i].id]-pre[t[i].id])),B.C(LW(s2[t[i].id]-pre[t[i].id])),C.C(LW(s2[t[i].id]-pre[t[i].id]));//记得清空</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i;for(read(n),i=1;i&lt;=n;i++) read(a[i]);</span><br><span class="line">    return S.B(),Solve(1,n),write(Ans),pc(&#x27;\n&#x27;),0;//建线段树（求区间最大子段和）、分治</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 分类讨论 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 二维偏序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升学e网通 倍速播放</title>
      <link href="/2021/07/02/%E5%8D%87%E5%AD%A6e%E7%BD%91%E9%80%9A-%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE/"/>
      <url>/2021/07/02/%E5%8D%87%E5%AD%A6e%E7%BD%91%E9%80%9A-%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>请使用电脑网页端以进行。（手机其实也可以，不过本文不着重提）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-Tampermonkey"><a href="#安装-Tampermonkey" class="headerlink" title="安装 Tampermonkey"></a>安装 Tampermonkey</h3><p>可以在浏览器的**插件商店**中下载，也可以从其他渠道获取<a href="https://wmhl.lanzoui.com/ib8glab">Tampermonkey的crx文件</a>，然后解压提取出来。</p><p>然后进入浏览器<strong>设置</strong>→<strong>扩展程序</strong>，进入后再打开右上角的<strong>开发者模式</strong>并保持该窗口的开启。之后找到被解压后的tampermonkey.crx文件，将其拖动到<strong>扩展程序</strong>界面，释放并同意安装。</p><p><img src="https://pic2.zhimg.com/80/v2-947ceb4ff0dd70cc7f240cf8ba822b5d_1440w.png" alt="img"></p><p>成功安装后会弹出窗口，且右上角会出现油猴插件的标识</p><p>这里引用了 <a href="https://zhuanlan.zhihu.com/p/128453110">知友无名HL的文章</a>。</p><h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><p>上 greasyfork 搜寻升学e网通的脚本（在此感谢脚本作者）</p><p>Greasyfork 项目链接：<a href="https://greasyfork.org/zh-CN/scripts/427464-%E5%8D%87%E5%AD%A6-e-%E7%BD%91%E9%80%9A%E5%B9%BF%E5%91%8A%E8%B7%B3%E8%BF%87">升学 E 网通广告跳过</a></p><p>Greasyfork 项目链接：<a href="https://greasyfork.org/zh-CN/scripts/428775-%E5%8D%87%E5%AD%A6-e-%E7%BD%91%E9%80%9A-ewt360-%E8%AF%95%E5%8D%B7%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90-%E9%80%89%E6%8B%A9%E9%A2%98">升学 E 网通 (EWT360) 试卷自动完成 (选择题)</a></p><p>如果您对 Greasyfork 访问有障碍，可以点击下方一键脚本。</p><p><a href="https://yzxoi.top/test.user.js">选择题自动完成</a></p><p><a href="https://yzxoi.top/play.user.js">视频倍速播放</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>登录 升学e网通 官网。</p><p>视频播放时会自动倍速，如果不行可点击右上角按钮刷新页面。</p><p>考试时点击右下角自动完成按钮，选择题将自动填入正确答案。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 升学e网通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2508 [HAOI2008]圆上的整点</title>
      <link href="/2021/06/29/p2508-haoi2008%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/"/>
      <url>/2021/06/29/p2508-haoi2008%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2508">P2508</a></p></blockquote><p>求一个给定的圆（$x^2+y^2&#x3D;r^2$）的圆周上有多少个点的坐标是整数。</p><p>$r\leq 2\times 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$$<br>\begin{align}<br>x^2+y^2&#x3D;r^2 &amp; \Leftrightarrow y&#x3D;\sqrt{r^2-x^2}\<br>&amp; \Leftrightarrow y&#x3D;\sqrt{(r+x)(r-x)}<br>\end{align}<br>$$</p><p>令 $d&#x3D;\gcd(r+x,r-x),A&#x3D;\frac{r+x}d,B&#x3D;\frac{r-x}d$，则有<br>$$<br>y^2&#x3D;d^2AB\Leftrightarrow AB&#x3D;(\frac yd)^2<br>$$<br>故 $AB$ 为平方数。</p><p>而 $\gcd(A,B)&#x3D;1$。</p><p>则 $A,B$ 分别为平方数，即 $A&#x3D;i^2,B&#x3D;j^2,(i,j\in Z)$。</p><p>那么：<br>$$<br>i^2&#x3D;\frac{r+x}d\<br>j^2&#x3D;\frac{r-x}d<br>$$<br>两式相加得：<br>$$<br>i^2+j^2&#x3D;\frac {2r}d<br>$$<br>那么枚举一下 $d$ 和 $i$，然后算出 $j$ 判一下是否合法即可。</p><p>时间复杂度：$\mathcal O(N)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">int r,Ans;</span><br><span class="line">I int gcd(CI a,CI b)&#123;return !b?a:gcd(b,a%b);&#125;</span><br><span class="line">I void Work(CI d)&#123;</span><br><span class="line">    RI i,j,x,y;for(i=1;i*i&lt;=r/d;i++)&#123;</span><br><span class="line">        j=sqrt(r/d-i*i);</span><br><span class="line">        if(j*j+i*i==r/d&amp;&amp;gcd(i,j)==1)&#123;</span><br><span class="line">            x=d*i*i-r/2,y=sqrt((r/2+x)*(r/2-x));</span><br><span class="line">            if(x&gt;0&amp;&amp;y&gt;0&amp;&amp;x*x+y*y==(r/2)*(r/2)) Ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,j;for(read(r),r*=2,i=1;i*i&lt;=r;i++) if(!(r%i)) Work(i),i*i&lt;r&amp;&amp;(Work(r/i),0);</span><br><span class="line">    return writeln((Ans+1)*4),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5298 [PKUWC2018]Minimax</title>
      <link href="/2021/06/26/p5298-pkuwc2018minimax/"/>
      <url>/2021/06/26/p5298-pkuwc2018minimax/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5298">P5298</a></p></blockquote><p>给定一棵 $n$ 个节点的根节点为 $1$ 的有根树，每个节点最多有两个子节点。</p><p>定义节点 $x$ 的权值为：</p><ol><li>若 $x$ 没有子节点，则其权值为 $a_i$。</li><li>若 $x$ 有子节点，则它的权值有 $p_x$ 的概率为其子节点的权值的最大值，有 $1-p_x$ 的概率为其子节点的权值的最小值。</li></ol><p>假设 $1$ 号点的权值有 $m$ 种可能性，其中权值第 $i$ 小的可能性的权值为 $V_i$，它的概率为 $D_i(D_i&gt;0)$，求：<br>$$<br>\sum_{i&#x3D;1}^mi\cdot V_i\cdot D_i^2 \bmod 998244353<br>$$<br>$1\leq n\leq 3\times 10^5,1\leq w_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑 DP，设 $F_{i,j}$ 为节点 $i$ 的权值为 $j$ 的概率，则：<br>$$<br>F_{i,j}&#x3D;F_{l,j}\times (p_i\sum_{k&#x3D;1}^{j-1}F_{r,k}+(1-p_i)\sum_{k&#x3D;j+1}^mF_{r,k})+F_{r,j}\times(p_i\sum_{k&#x3D;1}^{j-1}F_{l,k}+(1-p_i)\sum_{k&#x3D;j+1}^mF_{l,k})<br>$$<br>然后发现其实就是前缀和、后缀和，直接用线段树合并转移即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define int LL</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e5+10,P=998244353;</span><br><span class="line">int n,a[N],b[N],cnt,rt[N],Ans,Inv;</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id;struct node&#123;int l,r,v,t;&#125;T[N*80];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT int&amp; x,CI l=1,CI r=cnt</span><br><span class="line">        #define LT T[x].l,l,mid</span><br><span class="line">        #define RT T[x].r,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].v=(T[T[x].l].v+T[T[x].r].v)%P)</span><br><span class="line">        I void PD(CI x)&#123;</span><br><span class="line">            T[x].t!=1&amp;&amp;(</span><br><span class="line">            T[x].l&amp;&amp;(T[T[x].l].v=1LL*T[T[x].l].v*T[x].t%P,T[T[x].l].t=1LL*T[T[x].l].t*T[x].t%P),</span><br><span class="line">            T[x].r&amp;&amp;(T[T[x].r].v=1LL*T[T[x].r].v*T[x].t%P,T[T[x].r].t=1LL*T[T[x].r].t*T[x].t%P),</span><br><span class="line">            T[x].t=1);</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,PT)&#123;</span><br><span class="line">            if(!x) T[x=++id]=(node)&#123;0,0,0,1&#125;;</span><br><span class="line">            if(l==r) return void(T[x].v=1);</span><br><span class="line">            PD(x),p&lt;=mid?U(p,LT):U(p,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I int M(CI x,CI y,CI p,CI l=1,CI r=cnt,CI xmul=0,CI ymul=0)&#123;</span><br><span class="line">            if(!x&amp;&amp;!y) return 0;</span><br><span class="line">            if(!x) return T[y].v=1LL*T[y].v*ymul%P,T[y].t=1LL*T[y].t*ymul%P,y;</span><br><span class="line">            if(!y) return T[x].v=1LL*T[x].v*xmul%P,T[x].t=1LL*T[x].t*xmul%P,x;</span><br><span class="line">            PD(x),PD(y);</span><br><span class="line">            RI lx=T[T[x].l].v,ly=T[T[y].l].v,rx=T[T[x].r].v,ry=T[T[y].r].v;</span><br><span class="line">            return T[x].l=M(T[x].l,T[y].l,p,l,mid,(xmul+1LL*ry*(1-p+P))%P,(ymul+1LL*rx*(1-p+P))%P),</span><br><span class="line">            T[x].r=M(T[x].r,T[y].r,p,mid+1,r,(xmul+1LL*ly*p)%P,(ymul+1LL*lx*p)%P),PU(x),x;</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI p,PT)&#123;</span><br><span class="line">            if(l==r) return T[x].v;</span><br><span class="line">            return PD(x),p&lt;=mid?Q(p,LT):Q(p,RT);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I int QP(RI a,RI b)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%P),a=1LL*a*a%P,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">#define LW(x) (lower_bound(b+1,b+cnt+1,x)-b)</span><br><span class="line">I void Dfs(CI x)&#123;</span><br><span class="line">    if(!v[x].size()) return T.U(a[x],rt[x]);</span><br><span class="line">    for(auto i:v[x]) Dfs(i);</span><br><span class="line">    if(v[x].size()==1) rt[x]=rt[v[x][0]];</span><br><span class="line">    else rt[x]=T.M(rt[v[x][0]],rt[v[x][1]],a[x]);</span><br><span class="line">&#125;</span><br><span class="line">I int Sqr(CI x)&#123;return 1LL*x*x%P;&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,x;for(Inv=QP(10000,P-2),read(n),i=1;i&lt;=n;i++) read(x),v[x].push_back(i);</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(a[i]),!v[i].size()?b[++cnt]=a[i]:a[i]=1LL*a[i]*Inv%P;</span><br><span class="line">    for(sort(b+1,b+cnt+1),i=1;i&lt;=n;i++) !v[i].size()&amp;&amp;(a[i]=LW(a[i]));</span><br><span class="line">    for(Dfs(1),i=1;i&lt;=cnt;i++) Ans=(1LL*Ans+1LL*i*b[i]%P*Sqr(T.Q(i,rt[1])))%P;</span><br><span class="line">    return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 线段树合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ LCM计数</title>
      <link href="/2021/06/25/ybtoj-lcm%E8%AE%A1%E6%95%B0/"/>
      <url>/2021/06/25/ybtoj-lcm%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/contest/112/problem/8">YbtOJ</a></p></blockquote><p>给定 $T$ 组数据，每组数据给定 $n,m$，求<br>$$<br>\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m\operatorname{lcm}(i,j)[\forall n&gt;1,n^2\not \gcd(i,j)]<br>$$<br>$1\leq T\leq 10^4,1\leq n,m\leq 4\times 10^6$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由常见套路可得：</p><p>令 $S(n)&#x3D;\sum_{i&#x3D;1}^ni,F(n)&#x3D;n\times\sum_{ix}\mu(x)x [\forall d&gt;1,d^2\not \frac ni]$，则原式等同于：<br>$$<br>\sum_{T&#x3D;1}^n S(\frac nT)S(\frac mT)F(T)<br>$$<br>显然 $S(n)$ 可以 $\mathcal O(1)$ 求出，而 $F(n)$ 用埃筛的思想也可以简单求出，每次询问除法分块即可。</p><p>总时间复杂度为 $\mathcal O(N\log N + T\sqrt N)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=4e6+10,P=(1&lt;&lt;30);</span><br><span class="line">int Tt,n,m,p[N],v[N],mu[N],tot,F[N],Inv2,b[N];</span><br><span class="line">I int HB(RI n,CI x)&#123;</span><br><span class="line">    RI S=0;W(!(n%x))&#123;</span><br><span class="line">        S++,n/=x;</span><br><span class="line">        if(S&gt;2) return 0;</span><br><span class="line">    &#125;return -1LL*x*x%P*x%P*F[n]%P;</span><br><span class="line">&#125;</span><br><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,k;LL j;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else&#123;mu[i*p[j]]=0;break ;&#125;</span><br><span class="line">    for(i=2;i&lt;N;i++) for(j=1LL*i*i;j&lt;N;j+=i*i) b[j]=1;</span><br><span class="line">    for(i=1;i&lt;N;i++) if(!b[i]) for(j=i;j&lt;N;j+=i) F[j]=(1LL*mu[j/i]*(j/i)%P*j%P+F[j])%P; </span><br><span class="line">    for(i=1;i&lt;N;i++) F[i]=(1LL*F[i]+F[i-1])%P;</span><br><span class="line">&#125;</span><br><span class="line">I int S(CI n,CI m)&#123;</span><br><span class="line">    #define Sum(x) (1LL*(1+(x))*(x)/2%P)</span><br><span class="line">    RI i,j;LL X=0;</span><br><span class="line">    for(i=1;i&lt;=min(n,m);i=j+1) j=min(n/(n/i),m/(m/i)),X=(1LL*X+1LL*Sum(n/i)*Sum(m/i)%P*(F[j]-F[i-1])%P)%P,X=(X+P)%P;</span><br><span class="line">    return X;</span><br><span class="line">&#125;</span><br><span class="line">I int QP(RI a,RI b)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%P),a=1LL*a*a%P,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    GM(),read(Tt);</span><br><span class="line">    W(Tt--) read(n,m),writeln(S(n,m));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 最小数</title>
      <link href="/2021/06/24/ybtoj-%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
      <url>/2021/06/24/ybtoj-%E6%9C%80%E5%B0%8F%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.ybtoj.com.cn/contest/109/problem/8">YbtOJ 109-8</a></p></blockquote><p>给定一个正整数 $n$，求满足只由 $8$ 组成且被 $n$ 整除的最小数。</p><p>有多组数据。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目即求满足 $n88\dots8(k\text{个}8)$ 的最小的 $k$ 值。</p><p>转换一下：<br>$$<br>\begin{align}<br>n88\dots8(k\text{个}8) &amp; \Leftrightarrow \frac{n}{8}11\dots1(k\text{个}1)\\<br>&amp; \Leftrightarrow \frac{9n}{8}99\dots9(k\text{个}9)\\<br>&amp; \Leftrightarrow \frac{9n}{8}(10^k-1)\\<br>&amp; \Leftrightarrow 10^k \bmod \frac{9n}{8}&#x3D;1<br>\end{align}<br>$$<br>而：<br>$$<br>\begin{align}<br>\gcd(10^k,\frac{9n}{8})&#x3D;1 &amp; \Leftrightarrow \gcd(10,\frac{9n}{8})&#x3D;1\<br>&amp; \Rightarrow 10^{\phi(\frac{9n}{8})}\equiv 1\pmod m\\<br>&amp; \Rightarrow k\phi(\frac{9n}{8})<br>\end{align}<br>$$<br>然后直接做就可以了，时间复杂度 $O(\sqrt N\log N)$。</p><p>然而可能会爆 long long，本来要用龟速乘再多加只 $\log$ 的，但是本人太懒，直接上 int128 了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL __int128</span><br><span class="line">#define int LL</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">int Tt,n,Ans;</span><br><span class="line">vector&lt;int&gt; v; </span><br><span class="line">I int phi(RI m)&#123;</span><br><span class="line">    RI i,S,t;for(S=m,i=2;i*i&lt;=m;i++) if(!(m%i))&#123;</span><br><span class="line">        S=1LL*S/i*(i-1);W(!(m%i)) m/=i;</span><br><span class="line">    &#125;if(m&gt;1) S=1LL*S/m*(m-1);return S;</span><br><span class="line">&#125;</span><br><span class="line">I int QP(RI a,RI b,CI p)&#123;RI s=1;W(b) b&amp;1&amp;&amp;(s=1LL*s*a%p),a=1LL*a*a%p,b&gt;&gt;=1;return s;&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,t;W(read(n),n)&#123;</span><br><span class="line">        printf(&quot;Case &quot;),++Tt,write(Tt),pc(&#x27;:&#x27;),pc(&#x27; &#x27;),Ans=0;</span><br><span class="line">        if(n%16&amp;&amp;n%5)&#123;</span><br><span class="line">            if(!(n&amp;1)) n&gt;&gt;=1;</span><br><span class="line">            if(!(n&amp;1)) n&gt;&gt;=1;</span><br><span class="line">            if(!(n&amp;1)) n&gt;&gt;=1;</span><br><span class="line">            n*=9,t=n;n=phi(n);</span><br><span class="line">            for(i=1;i*i&lt;=n;i++) if(!(n%i)) v.push_back(i),v.push_back(n/i);</span><br><span class="line">            sort(v.begin(),v.end());for(auto i:v) if(QP(10,i,t)==1)&#123;Ans=i;break ;&#125;</span><br><span class="line">        &#125;writeln(Ans);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj4173 数学</title>
      <link href="/2021/06/24/bzoj4173-%E6%95%B0%E5%AD%A6/"/>
      <url>/2021/06/24/bzoj4173-%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://darkbzoj.tk/problem/4173">bzoj4173</a></p></blockquote><p>设 $S(n,m)$ 为满足 $m \bmod k + n\bmod k \ge k$ 的所有正整数 $k$ 组成的集合，求<br>$$<br>\phi(n)\times \phi(m)\times \sum_{k\in S(n,m)}\phi(k)\bmod 998244353<br>$$<br>$n,m\leq 10^{15}$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>重点是看后面的那个式子怎么化：<br>$$<br>\sum_{k\in S(n,m)}\phi(k)<br>=\sum_{n\bmod k + m\bmod k \ge k} \phi(k)\<br>$$<br>然后注重这个 $n\bmod k + m\bmod k \ge k$ 的转化：</p><p>令 $n &#x3D; q1 \times k +r1,m&#x3D;q2\times k +r2(0\leq r1,r2&lt;k)$，则有：<br>$$<br>r1+r2&#x3D;n\bmod k+m\bmod k\ge k<br>$$<br>由于 $n+m&#x3D;(q1+q2)\times k+(r1+r2)$，则：<br>$$<br>(n+m)-(q1+q2)\times k &#x3D; r1+r2 \ge k<br>$$<br>两边同除 $k$ 得：<br>$$<br>\lfloor \frac{n+m}{k}\rfloor-\lfloor \frac{n}{k}\rfloor-\lfloor \frac{m}{k}\rfloor&#x3D;1<br>$$<br>所以：<br>$$<br>\begin{align}<br>\sum_{n\bmod k + m\bmod k \ge k} \phi(k)<br>&amp;&#x3D;\sum_{k&#x3D;1}^{n+m}\phi(k)\times[\lfloor \frac{n+m}{k}\rfloor-\lfloor \frac{n}{k}\rfloor-\lfloor \frac{m}{k}\rfloor&#x3D;1]\\<br>&amp;&#x3D;\sum_{k&#x3D;1}^{n+m}\phi(k)\times(\lfloor \frac{n+m}{k}\rfloor-\lfloor \frac{n}{k}\rfloor-\lfloor \frac{m}{k}\rfloor)\\<br>&amp;&#x3D;\sum_{k&#x3D;1}^{n+m}\phi(k)\times\lfloor \frac{n+m}{k}\rfloor-\sum_{k&#x3D;1}^{n+m}\phi(k)\times\lfloor \frac{n}{k}\rfloor-\sum_{k&#x3D;1}^{n+m}\phi(k)\times\lfloor \frac{m}{k}\rfloor\\<br>&amp;&#x3D;\sum_{k&#x3D;1}^{n+m}\phi(k)\times\lfloor \frac{n+m}{k}\rfloor-\sum_{k&#x3D;1}^{n}\phi(k)\times\lfloor \frac{n}{k}\rfloor-\sum_{k&#x3D;1}^{m}\phi(k)\times\lfloor \frac{m}{k}\rfloor\\<br>&amp;&#x3D;\sum_{k&#x3D;1}^{n+m}i-\sum_{k&#x3D;1}^{n}i-\sum_{k&#x3D;1}^{m}i\\<br>&amp;&#x3D;\frac{(n+m)\times(n+m-1)}{2}-\frac{n\times(n-1)}{2}-\frac{m\times(m-1)}{2}\\<br>&amp;&#x3D;n\times m<br>\end{align}<br>$$<br>所以：<br>$$<br>\phi(n)\times \phi(m)\times \sum_{k\in S(n,m)}\phi(k)&#x3D;\phi(n)\times \phi(m)\times n\times m<br>$$<br>直接搞就好了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5,p=998244353;</span><br><span class="line">int n,m;</span><br><span class="line">I int phi(RI m)&#123;</span><br><span class="line">    RI i,S=m;for(i=2;i*i&lt;=m;i++) if(!(m%i))&#123;</span><br><span class="line">        S=S/i*(i-1);W(!(m%i)) m/=i;</span><br><span class="line">    &#125;if(m&gt;1) S=S/m*(m-1);return S%p;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;return read(n,m),writeln(phi(n)*phi(m)%p*(n%p)%p*(m%p)%p),0;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3302 [SDOI2013]森林</title>
      <link href="/2021/06/22/p3302-sdoi2013%E6%A3%AE%E6%9E%97/"/>
      <url>/2021/06/22/p3302-sdoi2013%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个 $N$ 个节点的森林，每个点有权值 $v_i$，初始有 $M$ 条边，有 $T$ 个操作：</p><ul><li><code>Q x y k</code> 查询点 $x$ 到点 $y$ 路径上的点权种第 $k$ 小，保证合法。</li><li><code>L x y</code> 在点 $x$ 和点 $y$ 之间连一条边，保证合法。</li></ul><p><strong>强制在线</strong></p><p>$1\leq N,M,T \leq 8\times 10^4,v_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先观察两个操作，分别对应两个算法：主席树、LCT。</p><p>但是这两个不容易并存，（但其实还是可以写的</p><p>所以考虑将一个换掉，比如说把 LCT 换成启发式合并，每次暴力将小的一棵树合并到另一棵树上，这样启发式合并复杂度为 $\mathcal O(\log N)$，然后主席树暴力重建复杂度为 $\mathcal O(\log N)$，合起来就是两只 $\log$ 还是可以接受的。</p><p>总时间复杂度 $\mathcal O(N \log^2N)$，总空间复杂度 $\mathcal O(N\log ^2 N)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=8e4+10;</span><br><span class="line">int Tt,n,m,k,a[N],b[N],fa[N],cnt,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,sz[N],g[N][20],rt[N],dep[N];</span><br><span class="line">I int GC()&#123;char c=gc();W(c^&#x27;Q&#x27;&amp;&amp;c^&#x27;L&#x27;) c=gc();return c^&#x27;L&#x27;;&#125;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">class ChairmanTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id;</span><br><span class="line">        struct node&#123;int l,r,v;&#125;T[N*400];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">    public:</span><br><span class="line">        I void B(int&amp; x,CI p,CI l,CI r,CI v)&#123;</span><br><span class="line">            if(T[x=++id]=T[p],T[x].v++,l==r) return ;</span><br><span class="line">            v&lt;=mid?B(T[x].l,T[p].l,l,mid,v):B(T[x].r,T[p].r,mid+1,r,v);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI s1,CI s2,CI s3,CI s4,CI l,CI r,CI k)&#123;</span><br><span class="line">            if(l==r) return b[l];RI t=T[T[s1].l].v+T[T[s2].l].v-T[T[s3].l].v-T[T[s4].l].v;</span><br><span class="line">            return k&lt;=t?Q(T[s1].l,T[s2].l,T[s3].l,T[s4].l,l,mid,k):Q(T[s1].r,T[s2].r,T[s3].r,T[s4].r,mid+1,r,k-t);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void Dfs(CI x,CI f,CI tp)&#123;</span><br><span class="line">    RI i;for(g[x][0]=f,i=1;i&lt;=18;i++) g[x][i]=g[g[x][i-1]][i-1];</span><br><span class="line">    for(T.B(rt[x],rt[f],1,cnt,a[x]),dep[x]=dep[f]+1,fa[x]=tp,sz[tp]++,i=fir[x];i;i=nxt[i]) to^f&amp;&amp;(Dfs(to,x,tp),0);</span><br><span class="line">&#125;</span><br><span class="line">I int LCA(RI x,RI y)&#123;</span><br><span class="line">    RI i;for(dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),i=18;~i;i--) if(dep[y]&lt;=dep[g[x][i]]&amp;&amp;(x=g[x][i]),x==y) return x;</span><br><span class="line">    for(i=18;~i;i--) if(g[x][i]^g[y][i]) x=g[x][i],y=g[y][i];return g[x][0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,o,x,y,z,p=0;for(read(Tt,n,m,k),i=1;i&lt;=n;i++) read(a[i]),b[++cnt]=a[i],fa[i]=i;</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(x,y),Add(x,y),Add(y,x);</span><br><span class="line">    for(sort(b+1,b+cnt+1),cnt=unique(b+1,b+cnt+1)-b-1,i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+cnt+1,a[i])-b;</span><br><span class="line">    for(i=1;i&lt;=n;i++) fa[i]==i&amp;&amp;(Dfs(i,0,i),0);</span><br><span class="line">    for(i=1;i&lt;=k;i++) (o=GC())?read(x,y,z),x^=p,y^=p,z^=p,writeln(p=T.Q(rt[x],rt[y],rt[LCA(x,y)],rt[g[LCA(x,y)][0]],1,cnt,z)):</span><br><span class="line">    (read(x,y),x^=p,y^=p,Add(x,y),Add(y,x),sz[fa[x]]&gt;sz[fa[y]]?Dfs(y,x,fa[x]):Dfs(x,y,fa[y]));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 rope</title>
      <link href="/2021/05/28/%E6%B5%85%E8%B0%88-rope/"/>
      <url>/2021/05/28/%E6%B5%85%E8%B0%88-rope/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天做了 <a href="https://www.luogu.com.cn/problem/UVA12538">UVA12538 自带版本控制功能的IDE Version Controlled IDE</a> 看了下题解发现可以用 rope 直接水过，所以发篇博客，记录一下 rope 的用法。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>rope 的本质就是块状链表。rope 是 C++ STL 中 pbds 的一个分支，想要引用，需要加上两行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ext/rope&gt;</span><br><span class="line">using namespace __gnu_cxx;  </span><br></pre></td></tr></table></figure><p>rope 可以实现在 $\mathcal O(1)$ 的时间拷贝历史版本，所以其可以轻松实现可持久化。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crope a,b;</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>首先定义一个 <code>crope a;</code></p><ul><li><code>a.push_back(x)</code>：在 <code>a</code> 的末尾添加 <code>x</code>。</li><li><code>a.insert(p,x)</code>: 在 <code>a</code> 的位置 <code>p</code> 后面添加 <code>x</code>。</li><li><code>a.erase(p,x)</code>: 从 <code>a</code> 的位置 <code>p</code> 开始删除 <code>x</code> 个元素。</li><li><code>a.replace(p,x)</code>: 从 <code>a</code> 的位置 <code>p</code> 开始换成 <code>x</code>。</li><li><code>a.substr(p,x)</code>：从 <code>a</code> 的位置 <code>p</code> 开始截取 <code>x</code> 个元素。</li><li><code>a.at(x)</code>：访问 <code>a</code> 的第 <code>x</code> 个元素。（其实第五种操作可以替代这个操作）</li></ul><p>然后如果有 $n$ 个操作，时间复杂度是 $\mathcal O(N^{1.5})$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>然后你就可以秒了这道黑题了：<a href="https://www.luogu.com.cn/problem/UVA12538">UVA12538 自带版本控制功能的IDE Version Controlled IDE</a></p><p>当然你也可以写块链，再套上个可持久化的话就得再套个分块，反正我是懒得写。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#include &lt;ext/rope&gt;</span><br><span class="line">using namespace __gnu_cxx;  </span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e4+10;</span><br><span class="line">int m,L;</span><br><span class="line">char str[N];</span><br><span class="line">crope nw,s[N],t;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI b=0,opt,p,v,c;read(m);W(m--) if(read(opt),opt==1) read(p),scanf(&quot;%s&quot;,&amp;str),p-=b,nw.insert(p,str),s[++L]=nw;</span><br><span class="line">    else if(opt==2) read(p,v),p-=b,v-=b,nw.erase(p-1,v),s[++L]=nw;</span><br><span class="line">    else read(v,p,c),v-=b,p-=b,c-=b,t=s[v].substr(p-1,c),b+=count(t.begin(),t.end(),&#x27;c&#x27;),cout&lt;&lt;t&lt;&lt;&#x27;\n&#x27;;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl </tag>
            
            <tag> rope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP11444 MAXOR - MAXOR &amp; bzoj 2741 【FOTILE模拟赛】L</title>
      <link href="/2021/05/27/sp11444-maxor-maxor-bzoj-2741-%E3%80%90fotile%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%91l/"/>
      <url>/2021/05/27/sp11444-maxor-maxor-bzoj-2741-%E3%80%90fotile%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%91l/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个长度为 $n$ 的序列 $a_i$，有 $m$ 个询问，查询一段区间内的子区间的异或和最大值。</p><p>强制在线。</p><p>$1\leq n\leq 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先肯定考虑使用 Trie 树。</p><p>然而普通 Trie 树并不能处理这个问题，所以我们考虑先使其可持久化，处理区间异或值。</p><p>然后再分块，记 $F[i][j]$ 表示从第 $i$ 个块开始到位置 $j$ 的答案，显然可以 $\mathcal O(N\sqrt N)$ 枚举每一个块以及每一个位置，再加一只 $log$ 在可持久化 Trie 树上求得答案。</p><p>对于询问，只需要把最左端块的散块部分暴力枚举即可，剩下的直接 $\mathcal O(1)$ 查询。</p><p>总时间复杂度：$O((N+Q)\sqrt N \log V)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define int long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=sqrt(N)+10;</span><br><span class="line">int n,m,S,a[N],bl[N],Ans[M][N],L[M],R[M],F[M][N],tot;</span><br><span class="line">class Trie&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id,rt[N];</span><br><span class="line">        struct node&#123;int nxt[2],v;&#125;T[N*31];</span><br><span class="line">        I void U(int&amp; x,CI y,CI v,CI d)&#123;++(T[x=++id]=T[y]).v,~d&amp;&amp;(U(T[x].nxt[v&gt;&gt;d&amp;1],T[y].nxt[v&gt;&gt;d&amp;1],v,d-1),0);&#125;</span><br><span class="line">        I int Q(CI x,CI y,CI v,CI d)&#123;</span><br><span class="line">            if(!~d) return 0;</span><br><span class="line">            #define o (v&gt;&gt;d&amp;1^1)</span><br><span class="line">            return T[T[x].nxt[o]].v^T[T[y].nxt[o]].v?Q(T[x].nxt[o],T[y].nxt[o],v,d-1)(1&lt;&lt;d):Q(T[x].nxt[o^1],T[y].nxt[o^1],v,d-1);</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI x,CI v)&#123;U(rt[x],x?rt[x-1]:0,v,30);&#125;</span><br><span class="line">        I int Q(CI l,CI r,CI v)&#123;return Q(rt[l-1],rt[r],v,30);&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void B()&#123;</span><br><span class="line">    RI i,j;for(T.U(0,0),S=sqrt(n),i=1;i&lt;=n;i++) !((i-1)%S)&amp;&amp;(R[tot]=i-1,L[++tot]=i),bl[i]=tot,T.U(i,a[i]);R[tot]=n;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=L[i]+1;j&lt;=n;j++) F[i][j]=max(F[i][j-1],T.Q(L[i],j-1,a[j]));</span><br><span class="line">&#125;</span><br><span class="line">I int Q(CI l,CI r)&#123;</span><br><span class="line">    RI i,X=0;if(bl[l]==bl[r])&#123;for(i=l;i&lt;r;i++) X=max(X,T.Q(i+1,r,a[i]));return X;&#125;</span><br><span class="line">    for(i=l;i&lt;=R[bl[l]];i++) X=max(X,T.Q(i+1,r,a[i]));return max(X,F[bl[l]+1][r]);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    RI i,x,y,l,r,p=0;for(read(n,m),i=1;i&lt;=n;i++) read(a[i]),a[i]^=a[i-1];B();</span><br><span class="line">    W(m--) read(x,y),writeln(p=Q(min((x+p)%n+1,(y+p)%n+1)-1,max((x+p)%n+1,(y+p)%n+1)));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 可持久化 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6774 [NOI2020] 时代的眼泪</title>
      <link href="/2021/05/24/p6774-noi2020-%E6%97%B6%E4%BB%A3%E7%9A%84%E7%9C%BC%E6%B3%AA/"/>
      <url>/2021/05/24/p6774-noi2020-%E6%97%B6%E4%BB%A3%E7%9A%84%E7%9C%BC%E6%B3%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P6774">P6774</a></p></blockquote><p>给定长度为 $n$ 的序列，其中第 $i$ 个点的权值为 $p_i$，保证 $p_i$ 为 $[1,n]$ 的排列。</p><p>有 $m$ 个询问，每个询问给定 $l,r,x,y$ 表示求出序列区间为 $[l,r]$ 的矩形的值在 $[x,y]$ 的顺序对数量。</p><p>$n\leq 10^5,m\leq 2\times 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>历经 9 个月，终于回来补这道题了。</p><blockquote><p>一道非常优秀的分块<strong>入门</strong>题，值得分块初学者花时间思考，不值得一写。</p><p>——BFqwq</p></blockquote><p>假设我们需要询问的是 $(l,r,x,y)$ 的答案，那么我们就可以把这个区间拆成中间是整块，两边是散块的结构。那么我们只需要分别考虑对应的贡献即可。</p><ol><li>首先是左右散块之内的 事先预处理所有块内排序，并离散化，预处理出前缀权值、位置的点的数量，查询时直接暴力枚举所有权值，每个点直接查询前缀和即可。</li><li>其次是左散块对右散块的贡献 块内事先排序，查询时直接归并排序查询顺序对数。</li><li>左右散块对中间整块的贡献 直接暴力枚举散块内所有点，预处理时开个前缀和记录前缀块、权值点的数量，查询时直接用前缀和计算即可。</li><li>中间整块之间 显然整块之间的答案可以通过容斥解决，直接暴力枚举每个块，考虑先加上之前块（包含本块）对这个块的贡献（预处理后前缀和查询），显然此时肯定会导致重复，那么再减去这个块自己内部的重复，再减去剩下之前的块的重复即可。</li></ol><p>至此，你就切掉了这个分块入门题，祝你好运！&gt;.&lt;</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">s[i][j]表示1~i块权值&lt;=j的数</span><br><span class="line">g[i]表示块内离散化后的值</span><br><span class="line">r[i][j]表示第i块离散化后j还原对应值</span><br><span class="line">v[i][j]第i块&lt;=j数个数</span><br><span class="line">F1[k][i][j]第k块离散化后权值&lt;=i位置&lt;=j的权值的个数</span><br><span class="line">F2[k][i][j]第k块离散化后权值&lt;=i与&lt;=j的块构成顺序对的个数</span><br><span class="line">F3[k][i][j]第k块离散化后权值在[i,j]的顺序对数</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,M=sqrt(N)+10;</span><br><span class="line">int n,m,S,a[N],bl[N],tot,L[M],R[M],v[M][N],s[M][N],g[N],r[M][M],id,F1[M][M][M],F2[M][M][M],F3[M][M][M];</span><br><span class="line">I void Build()&#123;</span><br><span class="line">    RI i,j,k;S=sqrt(n);for(i=1;i&lt;=n;i++) !((i-1)%S)&amp;&amp;(R[tot]=i-1,L[++tot]=i),bl[i]=tot;R[tot]=n;</span><br><span class="line">    for(j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">        for(i=L[j];i&lt;=R[j];i++) v[j][a[i]]=i;</span><br><span class="line">        for(id=0,i=1;i&lt;=n;i++) v[j][i]&amp;&amp;(r[j][g[v[j][i]]=++id]=v[j][i],v[j][i]=1),v[j][i]+=v[j][i-1],s[j][i]=s[j-1][i]+v[j][i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=1;k&lt;=tot;k++)&#123;</span><br><span class="line">        for(i=L[k];i&lt;=R[k];i++) F1[k][g[i]][i-L[k]+1]=1;</span><br><span class="line">        for(i=1;i&lt;=R[k]-L[k]+1;i++) for(j=1;j&lt;=R[k]-L[k]+1;j++) F1[k][i][j]+=F1[k][i][j-1]+F1[k][i-1][j]-F1[k][i-1][j-1];</span><br><span class="line">        for(i=L[k];i&lt;=R[k];i++) for(j=i+1;j&lt;=R[k];j++) g[i]&lt;g[j]&amp;&amp;(F3[k][g[i]][g[j]]=1);</span><br><span class="line">        for(i=1;i&lt;=R[k]-L[k]+1;i++) for(j=1;j&lt;=R[k]-L[k]+1;j++) F3[k][i][j]+=F3[k][i][j-1]+F3[k][i-1][j]-F3[k][i-1][j-1];</span><br><span class="line">        for(i=L[k];i&lt;=R[k];i++)&#123;</span><br><span class="line">            for(j=1;j&lt;k;j++) F2[k][g[i]][j]=s[j][a[i]]-s[j-1][a[i]];</span><br><span class="line">            F2[k][g[i]][k]=F3[k][g[i]][g[i]]-F3[k][g[i]][g[i]-1];</span><br><span class="line">        &#125;for(i=1;i&lt;=R[k]-L[k]+1;i++) for(j=1;j&lt;=tot;j++) F2[k][i][j]+=F2[k][i][j-1]+F2[k][i-1][j]-F2[k][i-1][j-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#define QS(O,l,r,x,y) (O[r][y]-O[(l)-1][y]-O[r][(x)-1]+O[(l)-1][(x)-1])</span><br><span class="line">I LL Q(CI k,CI l,CI r,RI x,RI y)&#123;</span><br><span class="line">    RI i;x=v[k][x-1]+1,y=v[k][y];LL Ans=0;for(i=l;i&lt;=r;i++) if(x&lt;=g[i]&amp;&amp;g[i]&lt;=y) Ans+=QS(F1[k],x,g[i],l-L[k]+1,i-L[k]);</span><br><span class="line">    return Ans;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; A,B;</span><br><span class="line">I LL Q(CI bL,CI bR,CI Ll,CI Lr,CI Rl,CI Rr,CI x,CI y)&#123;</span><br><span class="line">    A.clear(),B.clear();RI i,j,Ans=0;for(i=v[bL][x-1]+1;i&lt;=v[bL][y];i++) if(Ll&lt;=r[bL][i]&amp;&amp;r[bL][i]&lt;=Lr) A.push_back(a[r[bL][i]]);</span><br><span class="line">    for(i=v[bR][x-1]+1;i&lt;=v[bR][y];i++) if(Rl&lt;=r[bR][i]&amp;&amp;r[bR][i]&lt;=Rr) B.push_back(a[r[bR][i]]);</span><br><span class="line">    for(i=j=0;j&lt;B.size();j++)&#123;W(i&lt;A.size()&amp;&amp;A[i]&lt;=B[j]) i++;Ans+=i;&#125;return Ans;</span><br><span class="line">&#125;</span><br><span class="line">I LL Q(CI l,CI r,CI x,CI y)&#123;</span><br><span class="line">    RI i,bL=bl[l],bR=bl[r];if(bL==bR) return Q(bL,l,r,x,y);</span><br><span class="line">    LL Ans=Q(bL,l,R[bL],x,y)+Q(bR,L[bR],r,x,y)+Q(bL,bR,l,R[bL],L[bR],r,x,y);</span><br><span class="line">    for(i=l;i&lt;=R[bL];i++) if(x&lt;=a[i]&amp;&amp;a[i]&lt;=y) Ans+=QS(s,bL+1,bR-1,a[i],y);</span><br><span class="line">    for(i=L[bR];i&lt;=r;i++) if(x&lt;=a[i]&amp;&amp;a[i]&lt;=y) Ans+=QS(s,bL+1,bR-1,x,a[i]);</span><br><span class="line">    for(i=bL+1;i&lt;=bR-1;i++)&#123;</span><br><span class="line">        RI X=v[i][x-1]+1,Y=v[i][y];</span><br><span class="line">        Ans+=QS(F2[i],X,Y,bL+1,i)-QS(F3[i],1,X-1,X,Y)-(Y-X+1)*QS(s,bL+1,i-1,1,x-1);</span><br><span class="line">    &#125;return Ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r,x,y;for(read(n,m),i=1;i&lt;=n;i++) read(a[i]);Build();W(m--) read(l,r,x,y),writeln(Q(l,r,x,y));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>#61. 【UR #5】怎样更有力气</title>
      <link href="/2021/05/23/61-%E3%80%90ur-5%E3%80%91%E6%80%8E%E6%A0%B7%E6%9B%B4%E6%9C%89%E5%8A%9B%E6%B0%94/"/>
      <url>/2021/05/23/61-%E3%80%90ur-5%E3%80%91%E6%80%8E%E6%A0%B7%E6%9B%B4%E6%9C%89%E5%8A%9B%E6%B0%94/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://uoj.ac/problem/61">#61. UR #5</a></p></blockquote><p>大力水手问禅师：“大师，很多事情都需要用很大力气才能完成，而我在吃了菠菜之后力气很大，于是就导致我现在非常依赖菠菜。我很讨厌我的现状，有没有办法少吃点菠菜甚至不吃菠菜却仍很有力气？”</p><p>禅师浅笑，答：“方法很简单，不过若想我教你，你需先下山徒手修路。”</p><p>山下是 $n$ 座村庄从 $1$ 到 $n$ 编号，之间没有路相连。禅师给了大力水手一张草图，这张草图里 $n$ 座村庄被 $n - 1$ 条双向道路连接，任意一个村庄都可以通过双向道路到达其它所有村庄。</p><p>现在大力水手要根据禅师的意思在村庄间修路。禅师规定大力水手需要在 $m$ 天内完成任务，其中大力水手的修路方式如下：</p><ol><li>第 $i$ 天，禅师指定了两个村庄 $v_i$ 和 $u_i$，在<strong>草图上</strong> $v_i$ 号村庄到 $u_i$ 号村庄的最短路径上的所有村庄（包括 $v_i$ 和 $u_i$）中，大力水手需要选出若干对村庄（一个村庄可以被重复选多次，当然大力水手在这天也可以一对村庄都不选），然后在选出的每一对村庄间修建双向道路。</li><li>在实地考察中大力水手发现，有 $p$ 个限制关系 $(t_i, a_i, b_i)$，表示在第 $t_i$ 天无法在 $a_i$ 号村庄到 $b_i$ 号村庄间修路（路是双向的，所以自然也无法在 $b_i$ 号村庄到 $a_i$ 号村庄间修路）。</li><li>每一天都有个修理所需力气值 $w_i$，表示在第 $i$ 天每修建一条道路都要耗费 $w_i$ 点力气值。</li></ol><p>大力水手开始蛮力干了起来，一罐又一罐地吞食菠菜，结果经常修建一些无用的道路，每天都累得筋疲力尽。</p><p>作为一个旁观者，请你帮大力水手求出要想让 $m$ 天后任意一对村庄之间都可以互相到达，所需要的总力气值最少是多少。注意最后修出来的道路不必和草图一致。</p><p>$n,m,p \leq 300000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先肯定是想要把所有边按权值从小到大排序然后跑 MST。</p><p>那么考虑如何把一天内所有限制之后的子图搞出来。</p><p>如果限制的数量很少，甚至小于这两个点之间的距离，那么肯定存在一种方案使得任意两点之间连一条边，那么其实就相当于把所有点直接相互连边，那么直接暴力连就好了。</p><p>否则两点之间的距离小于限制，那么可以直接暴力把路径上点全部扣下来，每次考虑选取限制最少的点，从这个点出发，暴力枚举所有与这个点没有限制的点并且尝试合并。</p><p>对于所有与这个点之间有限制的点，可以直接暴力枚举，如果枚举到的点的限制的点集大小小于这个点可以连边的点集大小，说明必然存在一种方案使得其两点之间连通，所以也是直接连即可。否则直接暴力跑一次，由于度数最小的点的度数大约是 $\mathcal O(\sqrt N)$，所以这部分复杂度时 $\mathcal O(N)$ 的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e5+10;</span><br><span class="line">int n,m,p,fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,dep[N],f[N],w[N],mx[N],fa[N],vis[N];LL Ans;</span><br><span class="line">#define P pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;int&gt; E[N],Y,X;</span><br><span class="line">vector&lt;P&gt; L[N];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">struct Edge&#123;int u,v,w,id;&#125;e[N];</span><br><span class="line">I bool cmp(Cn Edge&amp; x,Cn Edge&amp; y)&#123;return x.w&lt;y.w;&#125;</span><br><span class="line">I void Dfs(CI x)&#123;RI i;for(i=fir[x];i;i=nxt[i]) dep[to]=dep[x]+1,Dfs(to);&#125;</span><br><span class="line">I void Dfs2(CI x)&#123;RI i;for(i=fir[x];i;i=nxt[i]) Dfs2(to),w[fa[x]]+=w[x],w[mx[x]]&lt;w[to]&amp;&amp;(mx[x]=to);&#125;</span><br><span class="line">I int GF(CI x)&#123;return f[x]?f[x]=GF(f[x]):x;&#125;</span><br><span class="line">struct GetFa&#123;</span><br><span class="line">    int F[N];</span><br><span class="line">    I int GF(CI x)&#123;return x==F[x]?x:F[x]=GF(F[x]);&#125;</span><br><span class="line">&#125;O,U;</span><br><span class="line">I bool Ct(RI x,RI y,RI k)&#123;RI t=0;W(x^y)&#123;dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),x=fa[x],t++;if(t&gt;L[k].size()) return 1;&#125;return t&gt;L[k].size();&#125;</span><br><span class="line">I void M(RI x,RI y,CI z)&#123;if((x=O.GF(x))^(y=O.GF(y))) O.F[x]=y,Ans+=z;&#125;</span><br><span class="line">I void FU(RI x,RI y,CI z)&#123;W(x^y) dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),M(x,fa[x],z),U.F[x]=fa[x],x=U.GF(fa[x]);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,t,x,y,Mn;for(read(n,m,p),dep[1]=w[1]=1,i=2;i&lt;=n;i++) read(x),Add(x,i),fa[i]=x,w[i]=1;Dfs(1);Dfs2(1);</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(e[i].u,e[i].v,e[i].w),e[i].id=i;sort(e+1,e+m+1,cmp);</span><br><span class="line">    for(i=1;i&lt;=p;i++) read(t,x,y),L[t].push_back(MP(x,y));</span><br><span class="line">    for(i=1;i&lt;=n;i++) O.F[i]=U.F[i]=i;</span><br><span class="line">    for(i=1;i&lt;=m;i++) if(Ct(e[i].u,e[i].v,e[i].id)) FU(e[i].u,e[i].v,e[i].w);else&#123;</span><br><span class="line">        for(auto j:L[e[i].id]) E[j.fi].push_back(j.se),E[j.se].push_back(j.fi);</span><br><span class="line">        Y.clear(),x=e[i].u,y=e[i].v;W(x^y) dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),Y.push_back(x),x=fa[x];Y.push_back(x);</span><br><span class="line">        Mn=2e9,t=0;for(auto j:Y) E[j].size()&lt;Mn&amp;&amp;(Mn=E[j].size(),t=j);</span><br><span class="line">        X.clear();for(auto j:E[t]) vis[j]=1;for(auto j:Y) if(!vis[j]) X.push_back(j),M(j,t,e[i].w);for(auto j:E[t]) vis[j]=0;</span><br><span class="line">        for(auto j:E[t])&#123;</span><br><span class="line">            for(auto k:E[j]) vis[k]=1;for(auto k:E[t]) !vis[k]&amp;&amp;(M(j,k,e[i].w),0);for(auto k:E[j]) vis[k]=0;</span><br><span class="line">            if(E[j].size()&lt;X.size()) M(t,j,e[i].w);</span><br><span class="line">            else&#123;for(auto k:E[j]) vis[k]=1;for(auto k:X) !vis[k]&amp;&amp;(M(k,j,e[i].w),0);for(auto k:E[j]) vis[k]=0;&#125;</span><br><span class="line">        &#125;for(auto j:L[e[i].id]) E[j.fi].clear(),E[j.se].clear();</span><br><span class="line">    &#125;return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5222 Game</title>
      <link href="/2021/05/20/p5222-game/"/>
      <url>/2021/05/20/p5222-game/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5222">P5222</a></p></blockquote><p>给定一个 $N\times M$ 的网格，其中有 $T$ 个格子有障碍，现需要在第一列摆一定量棋子，每一次可以执行以下操作：</p><ol><li>向上&#x2F;向下移动一枚棋子一个单位，且该位置没有障碍、没有其他棋子</li><li>将本列所有棋子移动到下一列，且下一列目标位置没有障碍</li></ol><p>再给定 $Q$ 个询问，每个询问给出 $k_i$，询问最多能在第一列上放多少棋子，使得经过若干操作后把所有棋子移动到最后一列，且所有棋子加起来总共最多执行 $k_i$ 次 $1$ 操作。</p><p>$N\leq 50,M\leq 10^6,T\leq 10^3,Q\leq 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先可以发现 $M$ 肯定是没有任何用的，可以把中间全是没有障碍的列直接缩掉，这样网格就变成了 $N\times T$ 大小。</p><p>然后我们还可以对询问进行转化，可以先预处理出一开始摆放 $i(1\leq i \leq N)$ 个棋子在第一列时，最少执行操作 $1$ 的次数，从而在每次询问中做到 $\mathcal O(N)$ 求解答案，那么询问总时间复杂度就是 $\mathcal O(NQ)$ 的。</p><p>接下来的问题就是如何预处理摆放 $i$ 个棋子为第一列时，最少执行操作 $1$ 次数。</p><p>既有障碍物又不能和另外的棋子重叠，这时我们可以想到可以用费用流解决这道题。</p><h3 id="80分做法"><a href="#80分做法" class="headerlink" title="80分做法"></a>80分做法</h3><p>可以把每个点向合法的上&#x2F;下面的相邻的点连一条容量为 $inf$，代价为 $1$ 的边，表示操作 $1$。</p><p>每个点再向合法的右边一列连一条容量为 $1$，代价为 $0$ 的边，表示操作 $2$。</p><p>但为什么操作 $1$ 要连 $inf$ 呢？</p><p>可以参考这种情况：</p><p><img src="https://pic4.58cdn.com.cn/nowater/webim/big/n_v20c3c3ed52360431096ed4eb5d46bec71.png"></p><p>其中<code>.</code>表示空，方块表示障碍。</p><p><img src="https://pic7.58cdn.com.cn/nowater/webim/big/n_v2d72d65f0c4414970b99b16d2b08b6540.png"></p><p>显然中间有一条上下的边会走过两次，如果容量为 $1$ 就无法通过。</p><p>最后再建立一个超级源点连接第一列所有点，超级汇点连接最后一列所有点，容量均为 $1$，代价均为 $0$，再把超级源点拆成两个点，每次多摆放一个棋子就把这两个点之间的容量 $+1$ 即可。</p><p>此时点的总数为 $NT$，边的总数为 $N^2T$。</p><p>期望总时间复杂度为 $\mathcal O(N^2TF)$，最坏时间复杂度为 $\mathcal O(N^3T^2F)$（$F$ 表示最大流流量）。</p><h3 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h3><p>由于费用流期望复杂度为 $\mathcal O(MF)$，最坏复杂度为 $\mathcal O(NMF)$，然而这里所有的边的容量均为 $1$，所以可以在这种 $0&#x2F;1$ 网格图中跑 Spfa 时用双端队列 (deque) 优化 Spfa，每次插入时跟队头比较，如果更小就插入队头，否则插入队尾，然后我不知道这样时间复杂度为多少，反正出题人 CYJian 说是 $\mathcal O(N^3T)$，足以通过此题。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e3+10,M=55,R=N*M,E=N*M*M;</span><br><span class="line">int n,m,S,T,TT,Q,cnt,G[M][N],fir[R],nxt[E&lt;&lt;1],son[E&lt;&lt;1],w[E&lt;&lt;1],cost[E&lt;&lt;1],tot=1,Ans,Cost,F[R],C[R],P[R],vis[R],inf=2e9,ans[M];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA b[N];</span><br><span class="line">I bool cmp(Cn PA&amp; x,Cn PA&amp; y)&#123;return x.se&lt;y.se;&#125;</span><br><span class="line">I void Add(CI x,CI y,CI z,CI c)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,cost[tot]=c;nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0,cost[tot]=-c;&#125;</span><br><span class="line">deque&lt;int&gt; q;</span><br><span class="line">#define to son[i]</span><br><span class="line">I bool bfs()&#123;</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop_front();q.push_front(S);memset(C,63,sizeof(C)),memset(vis,0,sizeof(vis));F[S]=inf=C[0];C[S]=0;W(!q.empty())</span><br><span class="line">        for(i=fir[vis[u=q.front()]=0,u],q.pop_front();i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;C[to]&gt;C[u]+cost[i]) C[to]=C[u]+cost[P[to]=i],F[to]=min(F[u],w[i]),!vis[to]&amp;&amp;(q.empty()?q.push_front(to),0:(C[to]&gt;C[q.front()]?q.push_back(to):q.push_front(to),0),vis[to]=1);//Spfa 双端队列优化</span><br><span class="line">    return C[T]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">I void MCMF()&#123;</span><br><span class="line">    RI i;W(bfs())&#123;</span><br><span class="line">        for(i=T;i^S;i=son[P[i]^1]) w[P[i]]-=F[T],w[P[i]^1]+=F[T];</span><br><span class="line">        Ans+=F[T];Cost+=F[T]*C[T];</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">#define idx(i,j) (((i)-1)*cnt+j)</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,x;for(read(n,m,TT,Q),i=1;i&lt;=TT;i++) read(b[i].fi,b[i].se);sort(b+1,b+TT+1,cmp);</span><br><span class="line">    for(i=1;i&lt;=TT;i++) b[i-1].se+2&lt;=b[i].se&amp;&amp;cnt++,b[i-1].se&lt;b[i].se&amp;&amp;cnt++,G[b[i].fi][cnt]=1;//删除空白列</span><br><span class="line">    for(S=n*cnt+1,T=n*cnt+2,i=1;i&lt;=n;i++) for(j=2;j&lt;=cnt;j++) if(!G[i][j-1]&amp;&amp;!G[i][j]) Add(idx(i,j-1),idx(i,j),1,0);//向同行下一列连边</span><br><span class="line">    for(i=1;i&lt;n;i++) for(j=1;j&lt;=cnt;j++) if(!G[i][j]&amp;&amp;!G[i+1][j]) Add(idx(i,j),idx(i+1,j),inf,1),Add(idx(i+1,j),idx(i,j),inf,1);//向同列隔壁行连边</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!G[i][1]) Add(0,idx(i,1),1,0);//超级源点向第一列连边</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!G[i][cnt]) Add(idx(i,cnt),T,1,0);//最后一列向超级汇点连边</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(Add(S,0,1,0),MCMF(),Ans==i) ans[i]=Cost;else n=i-1;//每次多加1的容量</span><br><span class="line">    for(i=1;i&lt;=Q;i++)&#123;for(read(x),j=n;~j;j--) if(ans[j]&lt;=x) break ;writeln(j);&#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="想要跑得更快？"><a href="#想要跑得更快？" class="headerlink" title="想要跑得更快？"></a>想要跑得更快？</h3><p>陈指导发现这个图其实可以<strong>缩点</strong>，然后时间复杂度就变成了优秀的 $\mathcal O(NT)$。</p><p>首先可以知道如果有 $x$ 个连续的棋子一起向上移动一个单位就等价于把最下面的一个棋子向上移动 $x$ 个单位。</p><p>也就是我们可以花费 $i-j$ 的代价把同一列第 $i$ 行棋子移动到第 $j$ 行，但要求 $i$ 到 $j$ 之间没有障碍。</p><p>另外还有一个显然的结论就是如果下一个格子没有障碍，我们就不必花费 $1$ 的代价移动这个棋子。</p><p>也就是同一行连续一段没有障碍的格子一旦进入了这一段后，必然会一直沿着这条路直到碰到障碍。</p><p>那么我们可以把<strong>同一行的连续的空格子的点缩成一个点</strong>。</p><p>这样点数就变成了 $\mathcal O(T)$，边数变成了 $\mathcal O(NT)$，然后就有了十分优秀的复杂度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e3+10,M=55,R=N*M,E=N*M*M;</span><br><span class="line">int n,m,S,T,TT,Q,cnt,G[M][N],fir[R],nxt[E&lt;&lt;1],son[E&lt;&lt;1],w[E&lt;&lt;1],cost[E&lt;&lt;1],tot=1,Ans,Cost,F[R],C[R],P[R],vis[R],inf=2e9,ans[M],ID,id[M][N];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">PA b[N];</span><br><span class="line">I bool cmp(Cn PA&amp; x,Cn PA&amp; y)&#123;return x.se&lt;y.se;&#125;</span><br><span class="line">I void Add(CI x,CI y,CI z,CI c)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,cost[tot]=c;nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0,cost[tot]=-c;&#125;</span><br><span class="line">deque&lt;int&gt; q;</span><br><span class="line">#define to son[i]</span><br><span class="line">I bool bfs()&#123;</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop_front();q.push_front(S);memset(C,63,sizeof(C)),memset(vis,0,sizeof(vis));F[S]=inf=C[0];C[S]=0;W(!q.empty())</span><br><span class="line">        for(i=fir[vis[u=q.front()]=0,u],q.pop_front();i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;C[to]&gt;C[u]+cost[i]) C[to]=C[u]+cost[P[to]=i],F[to]=min(F[u],w[i]),!vis[to]&amp;&amp;(q.empty()?q.push_front(to),0:(C[to]&gt;C[q.front()]?q.push_back(to):q.push_front(to),0),vis[to]=1);//Spfa 双端队列优化</span><br><span class="line">    return C[T]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">I void MCMF()&#123;</span><br><span class="line">    RI i;W(bfs())&#123;</span><br><span class="line">        for(i=T;i^S;i=son[P[i]^1]) w[P[i]]-=F[T],w[P[i]^1]+=F[T];</span><br><span class="line">        Ans+=F[T];Cost+=F[T]*C[T];</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">#define idx(i,j) id[i][j]</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,x;for(read(n,m,TT,Q),i=1;i&lt;=TT;i++) read(b[i].fi,b[i].se);sort(b+1,b+TT+1,cmp);</span><br><span class="line">    for(i=1;i&lt;=TT;i++) b[i-1].se+2&lt;=b[i].se&amp;&amp;cnt++,b[i-1].se&lt;b[i].se&amp;&amp;cnt++,G[b[i].fi][cnt]=1;</span><br><span class="line">    for(i=1;i&lt;=n;i++) for(j=1;j&lt;=cnt;j++) if(!G[i][j]&amp;&amp;!G[i][j-1]&amp;&amp;j&gt;1) id[i][j]=id[i][j-1];else id[i][j]=++ID;//缩点+重新标号</span><br><span class="line">    for(S=++ID,T=++ID,S&lt;&lt;=1,T&lt;&lt;=1,i=1;i&lt;=n;i++) for(j=1;j&lt;cnt;j++)&#123;</span><br><span class="line">        k=i-1;W(k&gt;=1&amp;&amp;G[i][j+1]&amp;&amp;!G[i][j]&amp;&amp;!G[k][j]) !G[k][j+1]&amp;&amp;(Add(idx(i,j)&lt;&lt;11,idx(k,j+1)&lt;&lt;1,1,abs(i-k)),0),k--;</span><br><span class="line">        k=i+1;W(k&lt;=n&amp;&amp;G[i][j+1]&amp;&amp;!G[i][j]&amp;&amp;!G[k][j]) !G[k][j+1]&amp;&amp;(Add(idx(i,j)&lt;&lt;11,idx(k,j+1)&lt;&lt;1,1,abs(i-k)),0),k++;//转化：向同列不同行连边</span><br><span class="line">    &#125;for(i=1;i&lt;=ID-2;i++) Add(i&lt;&lt;1,i&lt;&lt;11,1,0);//每个点拆成两个点，限制流量</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!G[i][1]) Add(0,idx(i,1)&lt;&lt;1,1,0);</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!G[i][cnt]) Add(idx(i,cnt)&lt;&lt;11,T,1,0);</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(Add(S,0,1,0),MCMF(),Ans==i) ans[i]=Cost;else n=i-1;</span><br><span class="line">    for(i=1;i&lt;=Q;i++)&#123;for(read(x),j=n;~j;j--) if(ans[j]&lt;=x) break ;writeln(j);&#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缩点 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5481 [BJOI2015] 糖果</title>
      <link href="/2021/05/18/p5481-bjoi2015-%E7%B3%96%E6%9E%9C/"/>
      <url>/2021/05/18/p5481-bjoi2015-%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5481">P5481</a></p></blockquote><p>给定一个大小为 $n\times m$ 的表格，可以填入自然数 $1$ 到 $k$，要求每一行数字单调不减，且任意两行不能完全相同，求方案数，答案对 $p$ 取模。</p><p>$1\leq n,m\leq 10^5,1\leq k,p \leq 2\times 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于单调不降，所以相当于从 $k$ 个数字中选择 $m$ 个，并且可以在后面添加 $m-1$ 个虚拟位置，表示该行第 $i$ 个数字和第 $i-1$ 个数字相等的情况。</p><p>那么单行的方案数就是 $C_{m+k-1}^m$，总方案数就是 $A_{C_{m+k-1}^m}^n$。</p><p>然后发现：$C_{m+k-1}^m&#x3D;\frac{\prod\limits_{i&#x3D;k}^{m+k-1}i}{m!}$，$A_{m}^n&#x3D;\prod\limits_{i&#x3D;m-n+1}^mi$。</p><p>由于这两个式子都可以在 $\mathcal O(N)$ 时间求得，所以总复杂度为 $O(N)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e9+1e5+10,M=sqrt(N);</span><br><span class="line">int n,m,k,P,p[M],v[M],tot,y[M];</span><br><span class="line">map&lt;int,int&gt; r;</span><br><span class="line">I void GP()&#123;</span><br><span class="line">    RI i,j;for(i=2;i&lt;M;i++) for(!v[i]&amp;&amp;(p[++tot]=i),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;M;j++)</span><br><span class="line">    if(v[i*p[j]]=1,!(i%p[j])) break ; </span><br><span class="line">&#125;</span><br><span class="line">I void U(RI x,CI c)&#123;</span><br><span class="line">    RI i;for(i=1;i&lt;=tot&amp;&amp;p[i]&lt;=x;i++) if(!(x%p[i]))&#123;</span><br><span class="line">        W(!(x%p[i])) y[i]+=c,x/=p[i];</span><br><span class="line">    &#125;if(x&gt;1) r[x]+=c;</span><br><span class="line">&#125;</span><br><span class="line">I int QP(RI A,RI B)&#123;RI S=1;W(B) B&amp;1&amp;&amp;(S=1LL*S*A%P),A=1LL*A*A%P,B&gt;&gt;=1;return S;&#125;</span><br><span class="line">I int G()&#123;</span><br><span class="line">    RI i,X=1;for(i=1;i&lt;=tot;i++) X=1LL*X*QP(p[i],y[i])%P;</span><br><span class="line">    for(auto j:r) X=1LL*X*QP(j.first,j.second)%P;return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,X,Y=1;for(GP(),read(n,m,k,P),i=k;i&lt;=m+k-1;i++) U(i,1);</span><br><span class="line">    for(i=m;i&gt;=1;i--) U(i,-1);for(X=G(),i=X-n+1;i&lt;=X;i++) Y=1LL*Y*i%P;</span><br><span class="line">    return writeln(Y),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT1984 [AGC001F] Wide Swap</title>
      <link href="/2021/05/17/at1984-agc001f-wide-swap/"/>
      <url>/2021/05/17/at1984-agc001f-wide-swap/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/AT1984">AT1984[AGC001F]</a></p></blockquote><p>给出一个元素集合为 ${1,2,\dots,N}$( $1\leq N\leq 500,000$)的排列 $P$，当有 $i,j (1\leq i&lt;j\leq N)$满足$j-i\geq K (1\leq K\leq N-1)$ 且 $P_{i}-P_{j}&#x3D;&#x3D;1∣$ 时，可以交换 $P_{i}$ 和 $P_{j}$。</p><p>求：可能排列中字典序最小的排列</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令 $P_{a_i}&#x3D;i$，那么题中的限制条件就改为 $P_i-P_{i-1}\ge k$，而要使原排列字典序最小也就相当于 $a_i$ 的字典序最小。</p><p>然后如果 $P_i-P_{i-1}&lt;k$，则 $i,j$ 之间的相对位置无法改变，此时只需要连一条反边，最后跑一边拓扑就好了。</p><p>但是如果这样的话建图会达到 $\mathcal O(N^2)$，但不难发现很多边都是重复的，所以可以用线段树优化建图。直接从 $1$ 到 $n$ 扫一遍，对于左边的只需要向其离 $i$ 最近的连边即可，右边同理。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e5+10;</span><br><span class="line">int n,k,a[N],b[N],fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,in[N],Ans[N];</span><br><span class="line">vector&lt;int&gt; p;</span><br><span class="line">I void Add(CI x,CI y)&#123;in[y]++,nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int T[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x]=max(T[x&lt;&lt;1],T[x&lt;&lt;11]))</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x]=v);</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S=max(S,Q(L,R,LT))),R&gt;mid&amp;&amp;(S=max(S,Q(L,R,RT))),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">I void Topo()&#123;</span><br><span class="line">    RI u,i;W(!q.empty()) q.pop();for(i=1;i&lt;=n;i++) if(!in[i]) q.push(i);W(!q.empty())&#123;</span><br><span class="line">        for(p.push_back(u=q.top()),q.pop(),i=fir[u];i;i=nxt[i]) if(!--in[to]) q.push(to);</span><br><span class="line">    &#125;for(i=0;i&lt;n;i++) Ans[p[i]]=n-i;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,t;for(read(n,k),i=1;i&lt;=n;i++) read(a[i]),b[a[i]]=i;</span><br><span class="line">    for(i=1;i&lt;=n;i++) t=T.Q(b[i],min(b[i]+k-1,n)),t&amp;&amp;(Add(b[i],b[t]),0),t=T.Q(max(1,b[i]-k+1),b[i]),t&amp;&amp;(Add(b[i],b[t]),0),T.U(b[i],i);</span><br><span class="line">    for(Topo(),i=1;i&lt;=n;i++) writeln(Ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1829 [国家集训队]Crash的数字表格 / JZPTAB</title>
      <link href="/2021/05/15/p1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Fcrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-jzptab/"/>
      <url>/2021/05/15/p1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Fcrash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-jzptab/</url>
      
        <content type="html"><![CDATA[<h2 id="Desciption"><a href="#Desciption" class="headerlink" title="Desciption"></a>Desciption</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P1829">P1829</a></p></blockquote><p>给定 $n,m$，求</p><p>$$(\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^mlcm(i,j)) \bmod 20101009$$</p><p>$1\leq n,m\leq 10^7$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先抛开模数，</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^mlcm(i,j)$$</p><p>根据最小公倍数定义，</p><p>$$&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\frac{ij}{gcd(i,j)}$$</p><p>然后常见套路，枚举 $gcd$，</p><p>$$&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{d&#x3D;1}^n\frac{ij}{d}[gcd(i,j)&#x3D;d]$$</p><p>改变枚举顺序，把 $gcd(i,j)&#x3D;d$ 消成 $gcd(i,j)&#x3D;1$，</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^n\sum\limits_{i&#x3D;1}^{\lfloor\frac{n}{d} \rfloor}\sum\limits_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}dij[gcd(i,j)&#x3D;1]$$</p><p>然后根据莫比乌斯函数性质，</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^n\sum\limits_{i&#x3D;1}^{\lfloor\frac{n}{d} \rfloor}\sum\limits_{j&#x3D;1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{kgcd(i,j)}\mu(k)dij$$</p><p>改变枚举顺序，</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^nd\sum\limits_{k&#x3D;1}^{\lfloor{\frac{n}{d}}\rfloor}\mu(k)k^2\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{dk}\rfloor}\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{dk}\rfloor}ij$$</p><p>然后根据结合律，</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^nd\sum\limits_{k&#x3D;1}^{\lfloor{\frac{n}{d}}\rfloor}\mu(k)k^2(\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{dk}\rfloor}i)(\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{dk}\rfloor}j)$$</p><p>那么令 $F(x)&#x3D;\mu(x)x^2$，$G(x)&#x3D;\sum\limits_{i&#x3D;1}^xi$，由于其均是积性函数，故</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^nd\sum\limits_{k&#x3D;1}^{\lfloor{\frac{n}{d}}\rfloor}F(k)G(\lfloor \frac{n}{dk}\rfloor)G(\lfloor \frac{m}{dk}\rfloor)$$</p><p>然后 $F(x)$ 直接筛的时候处理即可，$G(x)$ 为等差数列，直接 $\mathcal O(1)$ 求出，最后用整除分块优化即可。</p><p>时间复杂度：$\mathcal O(N)$（$\sum\limits_{i&#x3D;1}^N \sqrt\frac{N}{i}\approx N$）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define int LL</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e7+10,P=20101009;</span><br><span class="line">int n,m,p[N],v[N],mu[N],tot,F[N],Inv2;</span><br><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,j,k;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1,0),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else break ;</span><br><span class="line">    for(i=1;i&lt;N;i++) F[i]=(1LL*F[i-1]+mu[i]*i%P*i%P)%P;</span><br><span class="line">&#125;</span><br><span class="line">I int S(CI n,CI m)&#123;</span><br><span class="line">    #define Sum(x) (1LL*(1+(x))*(x)%P*Inv2%P)</span><br><span class="line">    RI i,j,k,Tn,Tm;LL X=0,Y=0;for(k=1;k&lt;=min(n,m);(Y+=X*k%P)%=P,k++) for(Tn=n/k,Tm=m/k,X=0,i=1;i&lt;=min(Tn,Tm);i=j+1)</span><br><span class="line">    j=min(Tn/(Tn/i),Tm/(Tm/i)),(X+=1LL*(F[j]-F[i-1])*Sum(Tn/i)%P*Sum(Tm/i)%P)%=P;return (Y+P)%P;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    return Inv2=(P+1)/2,GM(),read(n,m),writeln(S(n,m)),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P3327 [SDOI2015]约数个数和</title>
      <link href="/2021/05/15/p3327-sdoi2015%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/"/>
      <url>/2021/05/15/p3327-sdoi2015%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3327">P3327</a></p></blockquote><p>设 $d(x)$ 表示 $x$ 的约数个数，有 $T$ 组数据，给定 $n,m$ 求</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^md(ij)$$</p><p>$1\leq T,n,m\leq 5\times 10^4$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先你得知道：</p><p>$$d(ij)&#x3D;\sum\limits_{xi}\sum\limits_{yj}[gcd(x,y)&#x3D;1]$$</p><p>然后就是基本套路时间了：</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^md(ij)$$</p><p>$$&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{xi}\sum\limits_{yj}[gcd(x,y)&#x3D;1]$$</p><p>然后套路地改为枚举 $x,y$：</p><p>$$&#x3D;\sum\limits_{x&#x3D;1}^n\sum\limits_{y&#x3D;1}^m[gcd(x,y)&#x3D;1]\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[xi][yj]$$</p><p>显而易见：</p><p>$$&#x3D;\sum\limits_{x&#x3D;1}^n\sum\limits_{y&#x3D;1}^m[gcd(x,y)&#x3D;1]\lfloor\frac{n}{x} \rfloor\lfloor \frac{m}{y} \rfloor$$</p><p>然后为了美观，把 $x,y$ 换为 $i,j$，由莫比乌斯函数性质可得：</p><p>$$&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{dgcd(i,j)}\mu(d)\times \lfloor \frac{n}{i} \rfloor\times \lfloor \frac{m}{j} \rfloor$$</p><p>再根据常见套路，改为枚举 $d$：</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^n\mu(d)\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{d} \rfloor}\sum\limits_{j&#x3D;1}^{\lfloor\frac{m}{d} \rfloor}\lfloor \frac{n}{id}\rfloor \lfloor \frac{m}{jd}\rfloor$$</p><p>然后根据分配律，可以把后面式子分为两部分计算：</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^n\mu(d)(\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{d} \rfloor}\lfloor \frac{n}{id}\rfloor)(\sum\limits_{j&#x3D;1}^{\lfloor\frac{m}{d} \rfloor} \lfloor \frac{m}{jd}\rfloor)$$</p><p>所以我们只需要预处理出 $F(x)&#x3D;\sum\limits_{i&#x3D;1}^x\lfloor \frac{x}{i} \rfloor$ 即可。</p><p>$$&#x3D;\sum\limits_{d&#x3D;1}^n\mu(d)\times F(\lfloor\frac{n}{d}\rfloor)\times F(\lfloor \frac{m}{d}\rfloor)$$</p><p>时间复杂度：$\mathcal O(T\sqrt N +N\sqrt N)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e4+10;</span><br><span class="line">int T,n,m,p[N],v[N],mu[N],tot;</span><br><span class="line">LL F[N];</span><br><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,j,k;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1,0),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else break ;</span><br><span class="line">    for(i=1;i&lt;N;i++) mu[i]+=mu[i-1];</span><br><span class="line">    for(k=1;k&lt;N;k++) for(i=1;i&lt;=k;i=j+1) j=k/(k/i),F[k]+=1LL*(j-i+1)*(k/i);</span><br><span class="line">&#125;</span><br><span class="line">I LL S(CI n,CI m)&#123;</span><br><span class="line">    RI i,j;LL X=0;for(i=1;i&lt;=min(n,m);i=j+1) j=min(n/(n/i),m/(m/i)),X+=1LL*(mu[j]-mu[i-1])*F[n/i]*F[m/i];return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    GM(),read(T);W(T--) read(n,m),writeln(S(n,m));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2257 YY的GCD</title>
      <link href="/2021/05/15/p2257-yy%E7%9A%84gcd/"/>
      <url>/2021/05/15/p2257-yy%E7%9A%84gcd/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2257">P2557</a></p></blockquote><p>有 $T$ 组数据，求：</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[gcd(i,j)\in prime]$$</p><p>$T\leq 10^4,n,m\leq 10^7$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然可以枚举质数，所以原式可以化为：</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{k&#x3D;1}^{\min{n,m}}[gcd(i,j)&#x3D;k](k\in prime)$$</p><p>根据基本套路，可以把 $[gcd(i,j)&#x3D;k]$ 化为 $[gcd(i,j)&#x3D;1]$：</p><p>$$\sum\limits_{k&#x3D;1}^{\min{n,m}}\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{k} \rfloor}\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{k}\rfloor}[gcd(i,j)&#x3D;1](k\in prime)$$</p><p>由莫比乌斯函数性质可得：</p><p>$$\sum\limits_{k&#x3D;1}^{\min{n,m}}\sum\limits_{i&#x3D;1}^{\lfloor \frac{n}{k} \rfloor}\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{k}\rfloor}\sum\limits_{dgcd(i,j)}\mu(d)(k\in prime)$$</p><p>再根据基本套路，可以变换枚举顺序，可得：</p><p>$$\sum\limits_{k&#x3D;1}^{n}\sum\limits_{d&#x3D;1}^{\lfloor\frac{n}{d} \rfloor}\mu(d)\times \lfloor \frac{n}{kd} \rfloor\times \lfloor \frac{m}{kd} \rfloor(k\in prime)$$</p><p>此时时间复杂度为 $\mathcal{O}(\text{质数个数}\times \sqrt N)$，显然会 TLE。</p><p>此时就有一个常用的技巧可以降低时间复杂度。</p><p>设 $T&#x3D;kd$，有</p><p>$$\sum\limits_{T&#x3D;1}^n \lfloor \frac{n}{T}\rfloor\times \lfloor \frac{m}{T}\rfloor \sum\limits_{kT,k\in prime}\mu(\frac{T}{k})$$</p><p>显然后面的式子可以直接预处理。</p><p>暂且将这种常用的技巧理解为通过变换枚举顺序，使得某一式子可以预处理化吧。</p><p>然后时间复杂度就变成了 $\mathcal{O}(T\sqrt N+N)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e7+10;</span><br><span class="line">int T,n,m,mu[N],p[N],v[N],tot,F[N];</span><br><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,j;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1,0),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else break ;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=1;j*p[i]&lt;N;j++) F[j*p[i]]+=mu[j];for(i=1;i&lt;N;i++) F[i]+=F[i-1];</span><br><span class="line">&#125;</span><br><span class="line">I LL S(CI n,CI m)&#123;</span><br><span class="line">    RI i,j;LL X=0;for(i=1;i&lt;=min(n,m);i=j+1) j=min(n/(n/i),m/(m/i)),X+=1LL*(F[j]-F[i-1])*(n/i)*(m/i);return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    GM(),read(T);W(T--) read(n,m),writeln(S(n,m));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2522 [HAOI2011]Problem b</title>
      <link href="/2021/05/14/p2522-haoi2011problem-b/"/>
      <url>/2021/05/14/p2522-haoi2011problem-b/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2522">P2522</a></p></blockquote><p>有 $T$ 组数据，求</p><p>$$\sum\limits_{i&#x3D;x}^n\sum\limits_{j&#x3D;y}^m[gcd(i,j)&#x3D;k]$$</p><p>$1\leq T,x,y,n,m,k\leq 5\times 10 ^4$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可以根据容斥原理，原式可以分成四个子问题，每个子问题的式子为：</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[gcd(i,j)&#x3D;k]$$</p><p>考虑化简：</p><p>$$\sum\limits_{i&#x3D;1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{k}\rfloor}[gcd(i,j)&#x3D;1]$$</p><p>根据莫比乌斯函数性质，将函数展开可以得到：</p><p>$$\sum\limits_{i&#x3D;1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{k}\rfloor}\sum\limits_{dgcd(i,j)}\mu(d)$$</p><p>变换求和顺序，先枚举 $dgcd(i,j)$，可以得到：</p><p>$$\sum\limits_{d&#x3D;1}\mu(d)\sum\limits_{i&#x3D;1}^{\lfloor\frac{n}{k}\rfloor}[di]\sum\limits_{j&#x3D;1}^{\lfloor \frac{m}{k}\rfloor}[dj]$$</p><p>易知 $1 \sim \lfloor\frac{n}{k}\rfloor$ 中 $d$ 的倍数有 $\lfloor \frac{n}{kd} \rfloor$ 个，故原式化为：</p><p>$$\sum\limits_{d&#x3D;1}\mu(d) \lfloor \frac{n}{kd} \rfloor\lfloor\frac{m}{kd} \rfloor$$</p><p>然后直接用数论分块求解即可。</p><p>时间复杂度：$\mathcal{O}(N+T\sqrt N)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e4+10;</span><br><span class="line">int T,a,b,c,d,k,p[N],v[N],mu[N],tot;</span><br><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,j;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1,0),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else break ;</span><br><span class="line">    for(i=1;i&lt;N;i++) mu[i]+=mu[i-1];</span><br><span class="line">&#125;</span><br><span class="line">I int S(CI n,CI m)&#123;</span><br><span class="line">    RI i,j,X=0;for(i=1;i&lt;=min(n,m);i=j+1) j=min(n/(n/i),m/(m/i)),X+=(mu[j]-mu[i-1])*(n/i)*(m/i);return X;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    GM(),read(T);W(T--) read(a,b,c,d,k),writeln(S(b/k,d/k)-S(b/k,(c-1)/k)-S((a-1)/k,d/k)+S((a-1)/k,(c-1)/k));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈莫比乌斯反演</title>
      <link href="/2021/05/14/%E6%B5%85%E8%B0%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2021/05/14/%E6%B5%85%E8%B0%88%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈莫比乌斯反演"><a href="#浅谈莫比乌斯反演" class="headerlink" title="浅谈莫比乌斯反演"></a>浅谈莫比乌斯反演</h1><blockquote><p>那些各种各样的性质与定理,大多是前人几年甚至几十年才得出来的,哪里是你几天就能理解并证明的。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>莫比乌斯反演是数论中的重要内容。对于一些函数 $f(n)$，如果很难直接求出它的值，而容易求出其倍数和或约数和 $g(n)$，那么可以通过莫比乌斯反演简化运算，求得 $f(n)$ 的值。</p><p>--OI Wiki</p></blockquote><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$$\mu(d)&#x3D;\begin{cases}1&amp;d&#x3D;1\\(-1)^k&amp;d&#x3D;\prod_{i&#x3D;1}^kp_i\text{且}p_i\text{为互不相同的质数}\\0&amp;d\text{含有平方因子}\end{cases}$$</p><p>令 $n&#x3D;\prod_{i&#x3D;1}^k p_i^{c_i}$，其中 $p_i$ 为质因子，$c_i\ge 1$。</p><ol><li>当 $n&#x3D;1$ 时，$\mu(n)&#x3D;1$。</li><li>当 $n\not &#x3D; 1$ 时：</li></ol><ul><li>若 $\exists i\in[1,k],c_i&gt;1$，那么 $\mu(n)&#x3D;1$。</li><li>若 $\forall i \in [1,k],c_i&#x3D;1$，那么 $\mu(n)&#x3D;(-1)^k$。</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>莫比乌斯函数是<strong>积性函数</strong>，并且有以下性质：</p><ol><li>$$\sum\limits_{dn}\mu(d)&#x3D;\begin{cases}1 &amp; n&#x3D;1\\0 &amp; n\not &#x3D; 1\end{cases}$$</li><li>$$\sum\limits_{dn}\frac{\mu(d)}{d}&#x3D;\frac{\phi(n)}{n}$$</li></ol><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>由于莫比乌斯函数是典型的积性函数，所以也可以用欧拉筛筛出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I void GM()&#123;</span><br><span class="line">    RI i,j;for(mu[1]=1,i=2;i&lt;N;i++) for(!v[i]&amp;&amp;(mu[p[++tot]=i]=-1,0),j=1;j&lt;=tot&amp;&amp;i*p[j]&lt;N;j++)</span><br><span class="line">    if(v[i*p[j]]=1,i%p[j]) mu[i*p[j]]=-mu[i];else break ;</span><br><span class="line">    for(i=1;i&lt;N;i++) mu[i]+=mu[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>令 $F(n)$ 与 $f(n)$ 为定义在<strong>非负整数域</strong>上的两个函数，且他们之间满足 $$F(n)&#x3D;\sum\limits_{dn}f(d)$$。</p><p>那么我们有 $$f(n)&#x3D;\sum\limits_{dn}\mu(d)F(\lfloor \frac{n}{d}\rfloor)$$</p><p>这就是<strong>莫比乌斯反演定理</strong>，它还有另外一种形式：</p><p>如果 $$F(n)&#x3D;\sum\limits_{nd}f(d)$$</p><p>那么我们有 $$f(n)&#x3D;\sum\limits_{nd}\mu(\frac{d}{n})F(d)$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h3><ul><li>P2522 [HAOI2011]Problem b</li><li>P3455 [POI2007]ZAP-Queries</li><li>P2257 YY的GCD</li></ul><h3 id="提高题"><a href="#提高题" class="headerlink" title="提高题"></a>提高题</h3><p>咕了</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4587 [FJOI2016]神秘数</title>
      <link href="/2021/05/12/p4587-fjoi2016%E7%A5%9E%E7%A7%98%E6%95%B0/"/>
      <url>/2021/05/12/p4587-fjoi2016%E7%A5%9E%E7%A7%98%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4587">P4587</a></p></blockquote><p>一个可重复数字集合S的神秘数定义为最小的不能被S的子集的和表示的正整数。例如S&#x3D;{1,1,1,4,13}，</p><p>1 &#x3D; 1</p><p>2 &#x3D; 1+1</p><p>3 &#x3D; 1+1+1</p><p>4 &#x3D; 4</p><p>5 &#x3D; 4+1</p><p>6 &#x3D; 4+1+1</p><p>7 &#x3D; 4+1+1+1</p><p>8无法表示为集合S的子集的和，故集合S的神秘数为8。</p><p>现给定n个正整数a[1]..a[n]，m个询问，每次询问给定一个区间<a href="https://www.luogu.com.cn/problem/l%3C=r">l,r</a>，求由a[l],a[l+1],…,a[r]所构成的可重复数字集合的神秘数。</p><p>$n,m\leq 10^5,\sum a_i\leq 10^9$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑神秘数的寻找方法：先把一段集合排序，然后依次扫一遍，假设已经可以表示出 $[1,x]$，那么我们只需要判断能不能加进 $a_i$ 即可。</p><ul><li>如果 $a_i\leq x+1$，说明肯定可以被之前的表示出来，那么可以把 $a_i$ 加进去，此时范围变成 $[1,x+a_i]$。</li><li>如果 $a_i&gt;x+1$，说明此时肯定不能表示出 $x+1$，那么答案就是 $x+1$。</li></ul><p>然后直接用主席树维护即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,m,a[N],rt[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id;</span><br><span class="line">        struct node&#123;int l,r,v;&#125;T[N*400];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT int&amp; y,int &amp;x,CI l=1,CI r=1e9</span><br><span class="line">        #define LT T[y].l,T[x].l,l,mid</span><br><span class="line">        #define RT T[y].r,T[x].r,mid+1,r</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            T[x=++id]=T[y],T[x].v+=v;if(l==r) return ;</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI X,CI Y,CI L,CI R,CI l=1,CI r=1e9)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[Y].v-T[X].v;</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S+=Q(T[X].l,T[Y].l,L,R,l,mid)),R&gt;mid&amp;&amp;(S+=Q(T[X].r,T[Y].r,L,R,mid+1,r)),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r,Ans,Sum;for(read(n),i=1;i&lt;=n;i++) read(a[i]),T.U(a[i],a[i],rt[i-1],rt[i]);</span><br><span class="line">    read(m);W(m--)&#123;read(l,r),Ans=1;W(1)&#123;Sum=T.Q(rt[l-1],rt[r],1,Ans);if(Sum&gt;=Ans) Ans=Sum+1;else break ;&#125;writeln(Ans);&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2523 [HAOI2011]Problem c</title>
      <link href="/2021/05/10/p2523-haoi2011problem-c/"/>
      <url>/2021/05/10/p2523-haoi2011problem-c/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2523">P2523</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j]$ 表示剩余 $n - m$人中编号 $\ge i$ 的人，其中 $j$ 个人的编号已经确定的方案数</p><p>$$f[i][j] &#x3D; \sum \limits_{k &#x3D; 0}^j f[i + 1][j - k] \times C_j^k (0 \le j \le n - s[i] - i + 1)$$</p><p>其中 $s[i]$ 表示已经确定的 $m$ 个人中编号 $\ge i$ 的个数。</p><p>那么无解即 $s[i]&gt;n-i+1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=310;</span><br><span class="line">int T,n,m,P,v[N];</span><br><span class="line">LL F[N][N],C[N][N],S[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,x,y;read(T);W(T--)&#123;</span><br><span class="line">        memset(F,0,sizeof(F)),memset(S,0,sizeof(S)),memset(C,0,sizeof(C)),memset(v,0,sizeof(v));</span><br><span class="line">        read(n,m,P);for(i=1;i&lt;=m;i++) read(x,y),v[y]++;for(i=n;i&gt;=1;i--) S[i]=S[i+1]+v[i];</span><br><span class="line">        for(C[0][0]=i=1;i&lt;=n;i++) for(C[i][0]=j=1;j&lt;=n;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;</span><br><span class="line">        for(F[n+1][0]=1,i=n;i;i--) for(j=0;j&lt;=n-S[i]-i+1;j++) for(k=0;k&lt;=j;k++) (F[i][j]+=F[i+1][j-k]*C[j][k])%=P;</span><br><span class="line">        for(i=1;i&lt;=n;i++) if(S[i]&gt;n-i+1)&#123;puts(&quot;NO&quot;);break ;&#125;</span><br><span class="line">        i&gt;n&amp;&amp;(printf(&quot;YES &quot;),writeln(F[1][n-m]),0);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3516 [POI2011]PRZ-Shift</title>
      <link href="/2021/05/10/p3516-poi2011prz-shift/"/>
      <url>/2021/05/10/p3516-poi2011prz-shift/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3516">P3516</a></p></blockquote><p>给定一个长度为 $n$ 的排列，有两种操作：</p><ul><li>(a) 将最后一个数移到最前面。</li><li>(b) 把第三个数移到最前面。</li></ul><p>连续 $k$ 个操作可以合并成一块，表示为 $ka$ 或 $kb$，要求输出一个长度小于 $n^2$ 操作序列使得进行操作后排列变为 $1,2,3,\dots,n$。</p><p>无解输出 <code>NIE</code>。</p><p>$1\leq n \leq 2000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这里提供一个船新做法，可能会跑得快点。</p><p>考虑在前 $i-1$ 个数字已经有序排列的情况下，如何把数 $i$ 移动到第 $i$ 个位置。</p><ul><li>第 $i$ 个数字已经在第 $i$ 个位置了，那么不需要动。</li><li>第 $i$ 个数字必定在第 $j$ 个位置，其中 $j&gt;i$，那么可以先把第 $i$ 个数字移动到位置 $1$，然后每次执行 $2$ 次 a，再做一次 b，这样不断往复就可以把前 $i-1$ 个数字移动到最末尾，此时再做 $i-1$ 次 a 即可。</li></ul><p>然后最后可能会尴尬的剩下两个数，比如说下面的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 2 3 4 5 6 8 7</span><br></pre></td></tr></table></figure><p>我们发现：可以做两次 a，然后再做一次 b，即可实现将一个数向左移动两个单位，那么针对上面的数据，如果 $n$ 是奇数，肯定无解，如果是偶数，可以用上面的规律移动即可。</p><p>然后细节可能有点多，需要细心点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2010;</span><br><span class="line">int n,a[N&lt;&lt;1],b[N],s[5],p[N&lt;&lt;1],h;</span><br><span class="line">#define P pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">vector&lt;P&gt; Ans,F;</span><br><span class="line">I void Move(CI t,CI x)&#123;//模拟移动，把他拉成一个环，做到 O(1) 模拟。</span><br><span class="line">    RI i;if(t==1) (h+=n-x)%=n;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=3-x+1;i&lt;=3;i++) p[i-(3-x)]=a[h+i];for(i=1;i&lt;=3-x;i++) p[x+i]=a[h+i];</span><br><span class="line">        for(i=1;i&lt;=3;i++) a[h+i]=p[i];for(i=1;i&lt;=3;i++) a[(h+n+i)%(2*n)]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,t;for(read(n),i=1;i&lt;=n;i++) read(a[i]),b[i]=a[i];for(i=n+1;i&lt;=2*n;i++) a[i]=a[i-n];</span><br><span class="line">    for(i=1;i&lt;=n-2;i++)&#123;</span><br><span class="line">        for(j=1;j&lt;=n;j++) if(a[h+j]==i) break ; </span><br><span class="line">        if(j==i) continue ;</span><br><span class="line">        k=i-1,!k&amp;&amp;(k=n),t=0;if(j&gt;1) Ans.push_back(MP(1,n-j+1)),k+=n-j+1,Move(1,n-j+1);</span><br><span class="line">        k%=n,!k&amp;&amp;(k=n),swap(j,k);W(j+2&lt;=n) Ans.push_back(MP(1,2)),Move(1,2),Ans.push_back(MP(2,1)),Move(2,1),j+=2,t++;</span><br><span class="line">        if(j+1&lt;=n) Ans.push_back(MP(1,1)),Move(1,1),Ans.push_back(MP(2,2)),Move(2,2),j++,t++;//注意判断边界</span><br><span class="line">        Ans.push_back(MP(1,i-1)),Move(1,i-1);</span><br><span class="line">    &#125;for(i=n-1;i&lt;=n;i++) s[i-(n-2)]=a[h+i]-(n-2);for(i=1;i&lt;=2;i++) a[i]=s[i];if(a[1]==2&amp;&amp;a[2]==1)&#123;</span><br><span class="line">        if(n&amp;1) return puts(&quot;NIE&quot;),0;</span><br><span class="line">        for(Ans.push_back(MP(1,2)),i=n/2-1;i&gt;=1;i--) Ans.push_back(MP(1,2)),Ans.push_back(MP(2,1));Ans.push_back(MP(1,n-1));//如果出现最后两个不符情况</span><br><span class="line">    &#125;for(i=0;i&lt;Ans.size();)&#123;</span><br><span class="line">        j=i+1;W(j&lt;Ans.size()&amp;&amp;Ans[j].fi==Ans[i].fi) Ans[i].se+=Ans[j].se,j++;if(Ans[i].fi&amp;1) Ans[i].se%=n;else Ans[i].se%=3;</span><br><span class="line">        Ans[i].se&amp;&amp;(F.push_back(Ans[i]),0);i=j;//合并输出</span><br><span class="line">    &#125;writeln(F.size());for(auto i:F) write(i.se),pc(i.fi+&#x27;a&#x27;-1),pc(&#x27; &#x27;);</span><br><span class="line">    return pc(&#x27;\n&#x27;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3792 由乃与大母神原型和偶像崇拜</title>
      <link href="/2021/05/10/p3792-%E7%94%B1%E4%B9%83%E4%B8%8E%E5%A4%A7%E6%AF%8D%E7%A5%9E%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%81%B6%E5%83%8F%E5%B4%87%E6%8B%9C/"/>
      <url>/2021/05/10/p3792-%E7%94%B1%E4%B9%83%E4%B8%8E%E5%A4%A7%E6%AF%8D%E7%A5%9E%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%81%B6%E5%83%8F%E5%B4%87%E6%8B%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3792">P3792</a></p></blockquote><p>给定一个长度为 $n$ 的序列 ${a_i}$，有 $m$ 个操作：</p><ol><li>单点修改</li><li>查询区间 $[l,r]$ 是否可以重排成值域上连续的一段。</li></ol><p>$n,m\leq 5\times 10^5,a_i&lt; 2.5\times 10^7$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可以考虑记录某个点之前第一个权值相同的数的位置 $p_i$，然后建到线段树上，维护最大值。</p><p>那么区间 $[l,r]$ 满足条件的充要条件就是区间 $[l,r]$ 内 $p_i$ 的最大值均小于 $l$，并且 $\max_{i&#x3D;l}^r-\min_{i&#x3D;l}^r&#x3D;r-l$。</p><p>那么直接用线段树维护即可。</p><p>由于有修改操作，所以可以对于每个权值开个 set，维护出现位置，注意特判边界。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e5+10;</span><br><span class="line">int n,m,a[N],b[N&lt;&lt;1],cnt,rt[N&lt;&lt;1];</span><br><span class="line">set&lt;int&gt; v[N&lt;&lt;1];</span><br><span class="line">struct Que&#123;int opt,l,r;&#125;q[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int T[N&lt;&lt;2],Mx[N&lt;&lt;2],Mn[N&lt;&lt;2];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x]=max(T[x&lt;&lt;1],T[x&lt;&lt;11]),Mx[x]=max(Mx[x&lt;&lt;1],Mx[x&lt;&lt;11]),Mn[x]=min(Mn[x&lt;&lt;1],Mn[x&lt;&lt;11]))</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x]=v);</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void UU(CI p,CI v,PT)&#123;</span><br><span class="line">            if(l==r) return void(Mx[x]=Mn[x]=v);</span><br><span class="line">            p&lt;=mid?UU(p,v,LT):UU(p,v,RT),PU(x); </span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x];</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S=max(S,Q(L,R,LT))),R&gt;mid&amp;&amp;(S=max(S,Q(L,R,RT))),S;</span><br><span class="line">        &#125;</span><br><span class="line">        I int QM(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return Mx[x];</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S=max(S,QM(L,R,LT))),R&gt;mid&amp;&amp;(S=max(S,QM(L,R,RT))),S;</span><br><span class="line">        &#125;</span><br><span class="line">        I int QN(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return Mn[x];</span><br><span class="line">            RI S=2e9;return L&lt;=mid&amp;&amp;(S=min(S,QN(L,R,LT))),R&gt;mid&amp;&amp;(S=min(S,QN(L,R,RT))),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void U(CI x,CI y)&#123;</span><br><span class="line">    RI flg=0;auto t=v[a[x]].lower_bound(x),p=t,s=t;++s;</span><br><span class="line">    if(p!=v[a[x]].begin()) flg=1,p--;</span><br><span class="line">    if(flg&amp;&amp;s!=v[a[x]].end()) T.U(*s,*p),T.U(*t,0);else if(flg) T.U(*t,0);</span><br><span class="line">    else if(s!=v[a[x]].end()) T.U(*s,0),T.U(*t,0);else T.U(*t,0);</span><br><span class="line">    v[a[x]].erase(t);</span><br><span class="line">    v[y].insert(x),flg=0;t=v[y].lower_bound(x),p=t,s=t;++s;</span><br><span class="line">    if(p!=v[y].begin()) flg=1,p--;</span><br><span class="line">    if(flg&amp;&amp;s!=v[y].end()) T.U(*s,*p),T.U(*t,*p);else if(flg) T.U(*t,*p);</span><br><span class="line">    else if(s!=v[y].end()) T.U(*s,*t),T.U(*t,0);else T.U(*t,0);a[x]=y,T.UU(x,y);</span><br><span class="line">&#125;</span><br><span class="line">I int Q(CI l,CI r)&#123;return r-l==T.QM(l,r)-T.QN(l,r)&amp;&amp;T.Q(l,r)&lt;l;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;P3792.in&quot;,&quot;r&quot;,stdin),freopen(&quot;P3792.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i;for(read(n,m),i=1;i&lt;=n;i++) read(a[i]),b[++cnt]=a[i];</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(q[i].opt,q[i].l,q[i].r),q[i].opt&amp;1&amp;&amp;(b[++cnt]=q[i].r);</span><br><span class="line">    #define LW(x) lower_bound(b+1,b+cnt+1,x)-b</span><br><span class="line">    for(sort(b+1,b+cnt+1),cnt=unique(b+1,b+cnt+1)-b-1,i=1;i&lt;=n;i++) v[a[i]=LW(a[i])].size()&amp;&amp;(T.U(i,*v[a[i]].rbegin()),0),v[a[i]].insert(i),T.UU(i,a[i]);</span><br><span class="line">    for(i=1;i&lt;=m;i++) q[i].opt&amp;1?U(q[i].l,LW(q[i].r)):void(puts(Q(q[i].l,q[i].r)?&quot;damushen&quot;:&quot;yuanxing&quot;));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4581 [BJOI2014]想法</title>
      <link href="/2021/05/07/p4581-bjoi2014%E6%83%B3%E6%B3%95/"/>
      <url>/2021/05/07/p4581-bjoi2014%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4581">P4581</a></p></blockquote><p>给定 $m$ 个集合，其中 $A_i&#x3D;{i}$，之后 $n-m$ 个集合，每个集合是之前两个集合的并集，问之后 $n-m$ 个集合的大小。</p><p>有一定容错范围。</p><p>$1\leq m \leq 10^5,1\leq n\leq 10^6$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题面提醒的很到位，这题要用随机化。</p><p>但是如何随机化？之后和陈指导想了半小时也没想出来</p><p>可以借鉴WC2020某讲师提到的算法，通过随机一个权值，然后根据概率计算答案。</p><p>可以对于前 $m$ 个集合的元素都随机一个权值，然后每次维护出集合中的第 $k$ 小 $F_k$。</p><p>而根据概率可以得到 $\frac{F_k}{RandMax}&#x3D;\frac{k}{Ans}$。</p><p>所以调个好的随机种子+信仰就过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+10,P=30,Mx=233333333;</span><br><span class="line">int n,m,a[N],b[N][2];</span><br><span class="line">LL Ans[N];</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">I void Merge(CI now,CI x,CI y)&#123;</span><br><span class="line">    v[now].clear();RI i=0,j=0;W(i&lt;v[x].size()j&lt;v[y].size())&#123;</span><br><span class="line">        if(v[now].size()) W(i&lt;v[x].size()&amp;&amp;v[x][i]==v[now][v[now].size()-1]) i++;</span><br><span class="line">        if(v[now].size()) W(j&lt;v[y].size()&amp;&amp;v[y][j]==v[now][v[now].size()-1]) j++;</span><br><span class="line">        if(i==v[x].size()&amp;&amp;j==v[y].size()) return ;</span><br><span class="line">        if(j==v[y].size()(v[x][i]&lt;v[y][j]&amp;&amp;i&lt;v[x].size())) v[now].push_back(v[x][i]),i++;</span><br><span class="line">        else v[now].push_back(v[y][j]),j++;</span><br><span class="line">        if(v[now].size()&gt;P) return ;</span><br><span class="line">    &#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j;srand(time(NULL)),srand(rand()),srand(rand()),read(n,m);for(i=m+1;i&lt;=n;i++) read(b[i][0],b[i][1]);</span><br><span class="line">    for(j=1;j&lt;=3;j++)&#123;</span><br><span class="line">        for(i=1;i&lt;=m;i++) v[i].clear(),a[i]=1LL*rand()*rand()%Mx+1,v[i].push_back(a[i]);</span><br><span class="line">        for(i=m+1;i&lt;=n;i++) Merge(i,b[i][0],b[i][1]),Ans[i]+=1LL*((int)v[i].size()&lt;P?(int)v[i].size():(int)(1.0*P*Mx/v[i][P-1]));</span><br><span class="line">    &#125;for(i=m+1;i&lt;=n;i++) writeln(Ans[i]/3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj2122 工作评估</title>
      <link href="/2021/05/04/bzoj2122-%E5%B7%A5%E4%BD%9C%E8%AF%84%E4%BC%B0/"/>
      <url>/2021/05/04/bzoj2122-%E5%B7%A5%E4%BD%9C%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://darkbzoj.tk/problem/2122">bzoj2122</a></p></blockquote><p>利用空闲时间，BX希望外出工作，工作开始之前，公司就会给BX一个评估值 $X_0$，之后每天BX的评估值都是根据上一天的评估值和当天公司的运行状况得出，即 $X_i&#x3D;X_{i-1}+D_i$,但是每天的评估值有一个上限，也就是说完整的评估公式应该是 $X_i&#x3D;\min{X_i-1+D_i,L_i}$。现在BX已经知道了该公司对自己的初始评估值 $X_0$、公司每天的运行状况 $D_i$、每天的评估上限 $L_i$，他的空闲时间是从第 $A$ 天到第 $B$ 天，他希望找到一段时间 $i,j (A≤i≤j≤B)$，使得从第i天开始工作，到第j天结束后的评估值最大。当然如果任意一段时间的工作得到评估值都&lt;初始评估值 $X_0$，BX可以选择不工作，从而得到最大的评估值。</p><p>对于100%数据,满足 $N,M&lt;50001,Di&lt;10001,0≤Li&lt;1000000001$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>分块好题，令 $f(l,r,x_0)$ 表示区间 $[l,r]$，初始值为 $x_0$ 得到的最大评估值。</p><p>不难发现该式子有两个性质：</p><p>性质一：若 $x_i\ge x_j$，显然有 $f(l,r,x_i)\ge f(l,r,x_j)$。</p><p>性质二：令 $g(l,r)$ 表示 $f(l,r,inf)$，则 $f(l,r,x_0)&#x3D;\min{g(l,r),\sum_{i&#x3D;l}^rd_i+x_0}$。</p><p>根据性质二，我们可以得出一个重要推论：如果两个在 $[l,r]$ 中的子串，满足 $g_1\ge g_2$ 且 $s_1\ge s_2$，显然第二个子串是绝对不可能取到的。</p><p>所以最后得出的一个区间的子串一定满足 $g_i$ 单调递增，$s_i$ 单调递减。</p><p>考虑分块，每个块内的子串个数应该是 $O(N)$ 级别的（未利用推论去重），然后我们可以利用推论，使用单调栈剔除那些绝对不可能造成贡献的子串，最后块内的答案就是 $g$ 与 $s+x_0$ 的分界点。</p><p><img src="https://z3.ax1x.com/2021/05/04/gnYvIf.png" alt="g 和 s+x0 的图像，红色代表 f "></p><p>所以块内答案可以直接二分即可，块之间则需要维护 $X$，代表保留的最大价值，用以作为下一个的初始值 $x_0$，所以我们还需要维护一个块内的前缀和后缀，分五类讨论：</p><ol><li>从本块之前开始，到本块结束：我们只需要用 $X$ 与本块的前缀更新答案即可。</li><li>在本块内开始，在本块内结束：我们只需要用 $x_0$ 与本块块内答案更新即可。</li><li>从本块开始，到本块之后结束：用 $x_0$ 与本块后缀更新 $X$。</li><li>从本块之前开始，到本块之后结束：用 $X$ 与本块更新 $X$。</li><li>跟本块没有任何关系，并没有覆盖到本块任何部分：$X&#x3D;x_0$。</li></ol><p>然后维护一下就好了，注意块内二分边界。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define DD isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!DD) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),DD);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e4+10,M=sqrt(N)+50;</span><br><span class="line">int n,m,SZ,top,tot,bl[N],L[M],R[M],S[N];</span><br><span class="line">struct Val&#123;int D,L;&#125;a[N];</span><br><span class="line">struct node&#123;int g,s;&#125;stk[N];</span><br><span class="line">#define M(x,y) ((node)&#123;x,y&#125;)</span><br><span class="line">I bool cmp(Cn node&amp; x,Cn node&amp; y)&#123;return x.g^y.g?x.g&lt;y.g:x.s&lt;y.s;&#125;</span><br><span class="line">struct Block&#123;</span><br><span class="line">    node a[N],pre[M],suf[M];</span><br><span class="line">    int sz,G,S,pt,st;</span><br><span class="line">    I void P(node x)&#123;a[++sz]=x;&#125;</span><br><span class="line">    I void Pp(node x)&#123;pre[++pt]=x;&#125;</span><br><span class="line">    I void Ps(node x)&#123;suf[++st]=x;&#125;</span><br><span class="line">    I void B()&#123;</span><br><span class="line">        RI i;for(top=0,sort(a+1,a+sz+1,cmp),i=1;i&lt;=sz;stk[++top]=a[i],i++) W(top&amp;&amp;a[i].s&gt;=stk[top].s) top--;</span><br><span class="line">        for(i=1;i&lt;=top;i++) a[i]=stk[i];sz=top;//开单调栈剔除绝不可能造成贡献子串</span><br><span class="line">        for(top=0,sort(pre+1,pre+pt+1,cmp),i=1;i&lt;=pt;stk[++top]=pre[i],i++) W(top&amp;&amp;pre[i].s&gt;=stk[top].s) top--;</span><br><span class="line">        for(i=1;i&lt;=top;i++) pre[i]=stk[i];pt=top;</span><br><span class="line">        for(top=0,sort(suf+1,suf+st+1,cmp),i=1;i&lt;=st;stk[++top]=suf[i],i++) W(top&amp;&amp;suf[i].s&gt;=stk[top].s) top--;</span><br><span class="line">        for(i=1;i&lt;=top;i++) suf[i]=stk[i];st=top;//前后缀同理</span><br><span class="line">    &#125;</span><br><span class="line">    I int V(Cn node&amp; v,CI x0)&#123;return min(v.g,v.s+x0);&#125;//价值计算</span><br><span class="line">    I int Q(node* x,CI x0)&#123;</span><br><span class="line">        RI n=x==a?sz:x==pre?pt:x==suf?st:-1,l=1,r=n,p=-1,X=x0;if(!(~n)) return 0;</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        W(l&lt;=r) x[mid].g&gt;=x[mid].s+x0?p=mid,r=mid-1:l=mid+1;//二分寻找分界点</span><br><span class="line">        if(~p) return X=V(x[p],x0),p&lt;n&amp;&amp;(X=max(X,V(x[p+1],x0))),p&gt;1&amp;&amp;(X=max(X,V(x[p-1],x0))),X;//注意边界</span><br><span class="line">        else return max(max(V(x[1],x0),V(x[n],x0)),x0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;b[M];</span><br><span class="line">I void B()&#123;</span><br><span class="line">    RI i,j,k,v;for(i=1;i&lt;=n;i++) !((i-1)%SZ)&amp;&amp;(R[tot]=i-1,L[++tot]=i),bl[i]=tot;R[tot]=n;</span><br><span class="line">    #define MS M(v,S[k]-S[j-1])</span><br><span class="line">    for(i=1;i&lt;=tot;b[i].B(),i++) for(b[i].S=S[R[i]]-S[L[i]-1],j=L[i];j&lt;=R[i];j++) for(v=2e9,k=j;k&lt;=R[i];k++)</span><br><span class="line">    v=min(a[k].L,v+a[k].D),b[i].P(MS),j==L[i]&amp;&amp;(b[i].Pp(MS),0),k==R[i]&amp;&amp;(b[i].Ps(MS),0),j==L[i]&amp;&amp;k==R[i]&amp;&amp;(b[i].G=v);//建块</span><br><span class="line">&#125;</span><br><span class="line">I int Q(CI l,CI r,CI x0)&#123;</span><br><span class="line">    RI i,A=x0,bL=bl[l],bR=bl[r],X=x0;for(i=l;i&lt;=min(r,R[bL]);i++) X=min(max(X,x0)+a[i].D,a[i].L),A=max(A,X);//散块暴力</span><br><span class="line">    if(X=max(X,x0),bL&lt;bR)&#123;for(i=bL+1;i&lt;=bR-1;i++) A=max(A,b[i].Q(b[i].pre,X)),X=min(S[R[i]]-S[L[i]-1]+X,b[i].G),//情况1,4</span><br><span class="line">    A=max(A,b[i].Q(b[i].a,x0)),X=max(X,b[i].Q(b[i].suf,x0)),X=max(X,x0);//情况2,3,5</span><br><span class="line">    for(i=L[bR];i&lt;=r;i++) X=min(max(X,x0)+a[i].D,a[i].L),A=max(A,X);&#125;return A;//散块暴力</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r,x0;for(read(n,m),SZ=sqrt(N),i=1;i&lt;=n;i++) read(a[i].D),S[i]=S[i-1]+a[i].D;</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(a[i].L);B();W(m--) read(l,r,x0),writeln(Q(l,r,x0));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF819B Mister B and PR Shifts</title>
      <link href="/2021/04/29/cf819b-mister-b-and-pr-shifts/"/>
      <url>/2021/04/29/cf819b-mister-b-and-pr-shifts/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="http://codeforces.com/problemset/problem/819/B">CF819B</a></p></blockquote><p>给定一个长度为 $n$ 的全排列 ${p_i}$，定义其偏移值为 $\sum_{i&#x3D;1}^{n}p_i-i$，你可以将 $k\in[0,n-1]$ 个数从后面移到前面，使全排列的偏移值最小，输出最小偏移值和此时的 $k$，如果有多个符合输出任意一个。</p><p>$1\leq n \leq 10^6$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>CF评分1900的黑题？？？肯定要来水一下呀（（（</p><p>先观察下移动一次后偏移值的改变：中间一段的 $i$ 全部加一，最后一个数移到最前面。</p><p>移动两次后偏移值的改变：在移动一次后的序列中，中间一段的 $i$ 全部加一，最后一个数移到第二个数。</p><p>那么由此可以推理出移动 $j$ 次后偏移值的改变：在移动 $j-1$ 次后的序列中，所有 $i\in[1,n-1]$ 的数字的 $i$ 全部加一，最后一个数移动到 $j$。</p><p>考虑区间内数字所有 $i$ 加一的操作如何实现。</p><p>可以直接大力分类讨论：</p><ol><li>$p_i &gt;i $，此时只需要记下此种类的个数以及 $p_i-i$ 的和，每次修改的时候只需要把和减去个数即可。</li><li>$p_i\leq i$，此时也只需要记下此种类的个数以及 $i-p_i$ 的和，每次修改的时候只需要把和减去个数即可。</li></ol><p>由于第一个种的数减多次后可能会变成第二种，所以需要为第一种的所有 $p_i-i$ 开个桶计数，注意维护下即可。</p><p>最后一个数移动到 $j$ 可以先考虑不管，那么所有数字都进行一次修改操作，然后把第 $(n+1)$ 个数移到第 $j$ 个即可，注意维护下上文种分类讨论中维护的所有东西。</p><p>思路写起来有点麻烦，但代码还是很简洁的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+10;</span><br><span class="line">int n,k,a[N],cnt[N&lt;&lt;1],c0,c1;//由于存在移动操作，所以桶标记可能会超过 n</span><br><span class="line">LL s0,s1,Ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n),i=1;i&lt;=n;i++) read(a[i]),a[i]&gt;i?++cnt[a[i]-i],++c0,s0+=a[i]-i:(++c1,s1+=i-a[i]);</span><br><span class="line">    Ans=s0+s1;for(i=1;i&lt;=n;i++) s0-=c0,s1+=c1,c0-=cnt[i],c1+=cnt[i],(--c1,s1-=(n+1)-a[n-i+1]),//分类讨论</span><br><span class="line">    a[n-i+1]&gt;1?++cnt[a[n-i+1]-1+i],++c0,s0+=a[n-i+1]-1:++c1,s0+s1&lt;Ans&amp;&amp;(Ans=s0+s1,k=i);//特殊处理最末尾的数</span><br><span class="line">    return write(Ans),pc(&#x27; &#x27;),writeln(k),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分类讨论 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF803G Periodic RMQ Problem</title>
      <link href="/2021/04/28/cf803g-periodic-rmq-problem/"/>
      <url>/2021/04/28/cf803g-periodic-rmq-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="http://codeforces.com/problemset/problem/803/G">CF803G</a></p></blockquote><p>一个序列 ${a_i}$ 由 $k$ 个长度为 $n$ 的序列 ${b_i}$ 拼接而成，支持 $q$ 个操作：</p><ol><li><code>1 l r x</code>，区间赋值</li><li><code>2 l r</code>求区间最小值</li></ol><p>$1\leq n\leq 10^5,1\leq k \leq 10^4,1\leq q \leq 10^5,1\leq b_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>乍一看就是线段树模板题，然后看一眼数据范围，序列 ${a_i}$ 的长度可以高达 $10^9$，所以不能直接开线段树。</p><p>考虑这个序列的特殊性质：由 $k$ 个长度为 $n$ 的序列 ${b_i}$ 拼接而成。</p><p>也就是说其实我们可以把所有操作映射到 ${b_i}$ 上做。</p><p>然后把所有操作离线下来，离散化，拆成每个点以及两个点间的区间，先用 RMQ 预处理出离散化后每个点的初值，然后再套个线段树动态维护一下最小值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,k,b[N],q,o[N&lt;&lt;1],cnt,tot,w[N&lt;&lt;2],id[N&lt;&lt;2];</span><br><span class="line">struct Que&#123;int op,l,r,x;&#125;c[N];</span><br><span class="line">class RMQ&#123;</span><br><span class="line">    private:</span><br><span class="line">        int F[N][20],lg[N];</span><br><span class="line">    public:</span><br><span class="line">        I void B()&#123;</span><br><span class="line">            RI i,j;for(lg[0]=-1,i=1;i&lt;=n;i++) F[i][0]=b[i],lg[i]=lg[i/2]+1;</span><br><span class="line">            for(j=1;(1&lt;&lt;j)&lt;=n;j++) for(i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) F[i][j]=min(F[i][j-1],F[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI l,CI r)&#123;return min(F[l][lg[r-l+1]],F[r-(1&lt;&lt;lg[r-l+1])+1][lg[r-l+1]]);&#125;</span><br><span class="line">&#125;R;</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        struct node&#123;int S,T;&#125;T[N&lt;&lt;3];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT CI x=1,CI l=1,CI r=tot</span><br><span class="line">        #define LT x&lt;&lt;1,l,mid</span><br><span class="line">        #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].S=min(T[x&lt;&lt;1].S,T[x&lt;&lt;11].S))</span><br><span class="line">        #define PD(x) (T[x].T&amp;&amp;(T[x&lt;&lt;1].T=T[x&lt;&lt;11].T=T[x&lt;&lt;1].S=T[x&lt;&lt;11].S=T[x].T,T[x].T=0))</span><br><span class="line">    public:</span><br><span class="line">        I void B(PT)&#123;</span><br><span class="line">            if(l==r) return void(T[x].S=w[l]);</span><br><span class="line">            B(LT),B(RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI L,CI R,CI v,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return void(T[x].T=T[x].S=v);</span><br><span class="line">            PD(x),L&lt;=mid&amp;&amp;(U(L,R,v,LT),0),R&gt;mid&amp;&amp;(U(L,R,v,RT),0),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].S;</span><br><span class="line">            RI S=2e9;return PD(x),L&lt;=mid&amp;&amp;(S=min(S,Q(L,R,LT))),R&gt;mid&amp;&amp;(S=min(S,Q(L,R,RT))),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r;for(read(n,k),i=1;i&lt;=n;i++) read(b[i]);</span><br><span class="line">    for(R.B(),read(q),i=1;i&lt;=q;i++) read(c[i].op,c[i].l,c[i].r),c[i].op&amp;1&amp;&amp;(read(c[i].x),0),o[++cnt]=c[i].l,o[++cnt]=c[i].r;</span><br><span class="line">    #define idx(x) ((x)%n?(x)%n:n)</span><br><span class="line">    sort(o+1,o+cnt+1),cnt=unique(o+1,o+cnt+1)-o-1;for(i=1;i&lt;cnt;i++) if(w[++tot]=b[idx(o[i])],id[i]=tot,o[i+1]&gt;o[i]+1)&#123;//离散化后分情况讨论</span><br><span class="line">        if(o[i+1]-1-(o[i]+1)&gt;=n) w[++tot]=R.Q(1,n);//如果长度超过 n ，其实就是整个 bi 的最小值</span><br><span class="line">        else if((l=idx(o[i]+1))&lt;=(r=idx(o[i+1]-1))) w[++tot]=R.Q(l,r);//如果在一段区间内</span><br><span class="line">        else w[++tot]=min(R.Q(l,n),R.Q(1,r));//如果跨越了两个区间</span><br><span class="line">    &#125;w[++tot]=b[idx(o[cnt])],id[cnt]=tot;</span><br><span class="line">    #define LW(x) (lower_bound(o+1,o+cnt+1,x)-o)</span><br><span class="line">    for(S.B(),i=1;i&lt;=q;i++) c[i].l=LW(c[i].l),c[i].r=LW(c[i].r),c[i].op&amp;1?S.U(id[c[i].l],id[c[i].r],c[i].x):</span><br><span class="line">    writeln(S.Q(id[c[i].l],id[c[i].r]));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1045G AI robots</title>
      <link href="/2021/04/21/cf1045g-ai-robots/"/>
      <url>/2021/04/21/cf1045g-ai-robots/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/CF1045G">Luogu</a> <a href="https://codeforces.com/problemset/problem/1045/G">CF1045G</a></p></blockquote><p>给定 $N$ 个点，每个点的位置为 $X_i$，覆盖半径为 $R_i$，能覆盖 $[X_i-R_i,X_i+R_i]$，权值为 $Q_i$，询问能互相覆盖到并且权值之差不大于 $K$ 的点对的数量。</p><p>$1\leq N\leq 10^5,1\leq K\leq 20,1\leq X_i,R_i,Q_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>2200 的 G 题？？？</p><p>首先转换题目条件，即求 $(x,y)$ 使得：</p><ol><li>$X_x-X_y\leq \min{R_x,R_y}$</li><li>$Q_x-Q_y\leq K$</li></ol><p>由于第一个条件出现了 $\min$，并且较难转化，所以考虑先将所有点按照 $R_i$ 从大到小排序。</p><p>那么就变成了 $x&lt;y ,X_x-X_y\leq R_y,Q_x-Q_y\leq K$，所以我们只要按顺序枚举所有 $y$，对于每个 $Q$ 开一棵线段树，单点修改，区间求和即可（因为 $K$ 很小，所以每次询问可以直接枚举每棵线段树，即枚举 $Q$）。</p><p>然后加个动态开点即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,k,cnt,b[N&lt;&lt;2],g[N],tot,rt[N],Mx;LL Ans;</span><br><span class="line">struct node&#123;int x,r,q;&#125;a[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int id;</span><br><span class="line">        struct Node&#123;int l,r;LL S;&#125;T[N*40];</span><br><span class="line">        #define mid (l+r&gt;&gt;1)</span><br><span class="line">        #define PT int&amp; x,CI l=1,CI r=cnt</span><br><span class="line">        #define LT T[x].l,l,mid</span><br><span class="line">        #define RT T[x].r,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].S=T[T[x].l].S+T[T[x].r].S)</span><br><span class="line">    public:</span><br><span class="line">        I void U(CI p,CI v,PT)&#123;</span><br><span class="line">            if(!x) x=++id;</span><br><span class="line">            if(l==r) return void(T[x].S+=v);</span><br><span class="line">            p&lt;=mid?U(p,v,LT):U(p,v,RT),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I LL Q(CI L,CI R,PT)&#123;</span><br><span class="line">            if(!x) return 0;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].S;</span><br><span class="line">            LL S=0;return L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),S; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,p;for(read(n,k),i=1;i&lt;=n;i++) read(a[i].x,a[i].r,a[i].q),b[++cnt]=a[i].x-a[i].r,b[++cnt]=a[i].x+a[i].r,b[++cnt]=a[i].x,</span><br><span class="line">    g[++tot]=a[i].q,Mx=max(Mx,a[i].q);sort(b+1,b+cnt+1),cnt=unique(b+1,b+cnt+1)-b-1,sort(g+1,g+tot+1),tot=unique(g+1,g+tot+1)-g-1;</span><br><span class="line">    #define LWx(x) (lower_bound(b+1,b+cnt+1,x)-b)</span><br><span class="line">    #define LWy(x) (lower_bound(g+1,g+tot+1,x)-g)</span><br><span class="line">    for(sort(a+1,a+n+1,[&amp;](Cn node&amp; x,Cn node&amp; y)&#123;return x.r&gt;y.r;&#125;),i=1;i&lt;=n;S.U(LWx(a[i].x),1,rt[LWy(a[i].q)]),i++)</span><br><span class="line">    for(j=max(0,a[i].q-k);j&lt;=min(Mx,a[i].q+k);j++) if(p=LWy(j),g[p]==j) Ans+=S.Q(LWx(a[i].x-a[i].r),LWx(a[i].x+a[i].r),rt[p]);</span><br><span class="line">    return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 动态开点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP2542 [AHOI2005] 航线规划</title>
      <link href="/2021/04/17/luogup2542-ahoi2005-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/"/>
      <url>/2021/04/17/luogup2542-ahoi2005-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2542">P2542</a></p></blockquote><p>给定一个 $n$ 个点 $m$ 条边的无向图，定义 $u,v$ 的关键边为从 $u$ 到 $v$ 的所有路径都必须经过的边，给定 $q$ 个操作：</p><ol><li>查询 $u,v$ 两点间的关键边数量。</li><li>删除边 $u,v$，保证合法。</li></ol><p>保证任意时刻任意两点联通，不可能出现重边和自环。</p><p>$1\leq n\leq 3\times 10^4,1\leq m \leq 10^5,1\leq q\leq 4\times 10^4$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑删除操作可以用常见套路转换成离线询问反向加边。</p><p>而每次加边只会使关键边变少，并且只会影响 $u,v$ 之间的边。</p><p>那么可以考虑事先建一棵生成树，初始时每条树边权值均为 $1$，然后对于非树边用树剖剖出一条链，把链上所有边标记为 $0$（即代表不可能是关键边）。</p><p>每次加边的时候也剖一下，标记为 $0$ 即可。</p><p>询问其实就是剖一下，求链权值为 $1$ 的个数。</p><p>最后注意下边权下放时 $LCA$ 的处理即可。</p><p>总时间复杂度 $O(N log N)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=3e4+10,M=1e5+10,Qt=4e4+10;</span><br><span class="line">int n,m,q,fir[N],nxt[M&lt;&lt;1],son[M&lt;&lt;1],tot,mx[N],sz[N],F[N],top[N],id[N],dep[N],Ans[N],cnt;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">struct Que&#123;int op,x,y;&#125;Q[Qt];</span><br><span class="line">#define P pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">map&lt;P,int&gt; mp;</span><br><span class="line">I void Dfs(CI x,CI fa)&#123;</span><br><span class="line">    RI i;for(sz[x]=1,dep[x]=dep[F[x]=fa]+1,i=fir[x];i;i=nxt[i]) !mp[MP(x,to)]&amp;&amp;to^fa&amp;&amp;!sz[to]&amp;&amp;(Dfs(to,x),sz[x]+=sz[to],sz[mx[x]]&lt;sz[to]&amp;&amp;(mx[x]=to));</span><br><span class="line">&#125;</span><br><span class="line">I void Dfs2(CI x,CI Top)&#123;</span><br><span class="line">    if(top[x]=Top,id[x]=++cnt,mx[x]) Dfs2(mx[x],Top);RI i;for(i=fir[x];i;i=nxt[i]) !mp[MP(x,to)]&amp;&amp;to^mx[x]&amp;&amp;F[to]==x&amp;&amp;to^F[x]&amp;&amp;(Dfs2(to,to),0);</span><br><span class="line">&#125;</span><br><span class="line">class Tree&#123;</span><br><span class="line">    private:</span><br><span class="line">        class SegmentTree&#123;</span><br><span class="line">            private:</span><br><span class="line">                struct node&#123;int S,T;&#125;T[N&lt;&lt;2];</span><br><span class="line">                #define mid (l+r&gt;&gt;1)</span><br><span class="line">                #define PT CI x=1,CI l=1,CI r=n</span><br><span class="line">                #define LT x&lt;&lt;1,l,mid</span><br><span class="line">                #define RT x&lt;&lt;11,mid+1,r</span><br><span class="line">                #define PD(x) (T[x].T&amp;&amp;(T[x&lt;&lt;1].S=T[x&lt;&lt;11].S=0,T[x&lt;&lt;1].T=T[x&lt;&lt;11].T=1,T[x].T=0))</span><br><span class="line">                #define PU(x) (T[x].S=T[x&lt;&lt;1].S+T[x&lt;&lt;11].S)</span><br><span class="line">            public:</span><br><span class="line">                I void B(PT)&#123;</span><br><span class="line">                    if(l==r) return void(T[x]=(node)&#123;1,0&#125;);</span><br><span class="line">                    B(LT),B(RT),PU(x);</span><br><span class="line">                &#125;</span><br><span class="line">                I void U(CI L,CI R,PT)&#123;</span><br><span class="line">                    if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].T=1,T[x].S=0,void();</span><br><span class="line">                    PD(x),L&lt;=mid&amp;&amp;(U(L,R,LT),0),R&gt;mid&amp;&amp;(U(L,R,RT),0),PU(x);</span><br><span class="line">                &#125;</span><br><span class="line">                I int Q(CI L,CI R,PT)&#123;</span><br><span class="line">                    if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].S;</span><br><span class="line">                    RI S=0;return PD(x),L&lt;=mid&amp;&amp;(S+=Q(L,R,LT)),R&gt;mid&amp;&amp;(S+=Q(L,R,RT)),S;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;S;</span><br><span class="line">    public:</span><br><span class="line">        I void B()&#123;S.B();&#125;</span><br><span class="line">        I void U(RI x,RI y)&#123;</span><br><span class="line">            W(top[x]^top[y]) dep[top[x]]&lt;dep[top[y]]&amp;&amp;(swap(x,y),0),S.U(id[top[x]],id[x]),x=F[top[x]];</span><br><span class="line">            dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),x^y&amp;&amp;(S.U(id[y]+1,id[x]),0);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(RI x,RI y)&#123;</span><br><span class="line">            RI X=0;W(top[x]^top[y]) dep[top[x]]&lt;dep[top[y]]&amp;&amp;(swap(x,y),0),X+=S.Q(id[top[x]],id[x]),x=F[top[x]];</span><br><span class="line">            return dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),x^y&amp;&amp;(X+=S.Q(id[y]+1,id[x])),X;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">I void B(CI x)&#123;</span><br><span class="line">    RI i;for(i=fir[x];i;i=nxt[i]) !mp[MP(x,to)]&amp;&amp;(F[to]==x&amp;&amp;(B(to),0),to^F[x]&amp;&amp;dep[to]&lt;dep[x]&amp;&amp;(T.U(x,to),0));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,op,x,y;for(read(n,m),i=1;i&lt;=m;i++) read(x,y),Add(x,y),Add(y,x);</span><br><span class="line">    W(read(op),~op) read(x,y),Q[++q].op=op,Q[q].x=x,Q[q].y=y,!op&amp;&amp;(mp[MP(Q[q].y,Q[q].x)]=mp[MP(Q[q].x,Q[q].y)]=1);</span><br><span class="line">    for(Dfs(1,0),Dfs2(1,1),T.B(),B(1),i=q;i;i--) Q[i].op?void(Ans[i]=T.Q(Q[i].x,Q[i].y)):T.U(Q[i].x,Q[i].y);</span><br><span class="line">    for(i=1;i&lt;=q;i++) Q[i].op&amp;&amp;(writeln(Ans[i]),0);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3604 美好的每一天</title>
      <link href="/2021/04/11/luogup3604-%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9/"/>
      <url>/2021/04/11/luogup3604-%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3604">P3604</a></p></blockquote><p>给定一个长度为 $n$ 的字符串（仅包含小写字母），有 $m$ 个询问区间 $[l,r]$，求区间的子区间重排能成为一个回文串的个数。</p><p>$1\leq n,m\leq 6\times 10^4$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数据范围较小，考虑莫队。</p><p>一个字符串重排能成为回文串的条件是出现次数最多有一个是奇数。</p><p>由于是求子区间，很容易想到一个 trick：异或。</p><p>每个数改为该位置字符出现奇偶的异或前缀和。</p><p>那么子区间问题即可转化为在区间 $[l-1,r]$ 中找使得 $a_i\oplus a_j&#x3D;2^p$ 的子区间个数即可。</p><p>那么直接开个 $cnt$ 记录每个前缀和的出现次数。</p><p>然而内存限制为 162MB，所以需要改为 short（因为是前缀异或和，所以相邻的两个不会相同，所以也可以存下）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=6e4+10;</span><br><span class="line">int n,m,S,b[N],Ans[N],ans,bl[N];</span><br><span class="line">short cnt[(1&lt;&lt;26)+5];</span><br><span class="line">char a[N];</span><br><span class="line">struct Que&#123;int l,r,id;&#125;q[N];</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?x.l&lt;y.l:x.r&lt;y.r;&#125; </span><br><span class="line">I void Add(CI x)&#123;ans+=cnt[b[x]]++;RI i;for(i=0;i&lt;26;i++) ans+=cnt[b[x]^(1&lt;&lt;i)];&#125;</span><br><span class="line">I void Del(CI x)&#123;ans-=--cnt[b[x]];RI i;for(i=0;i&lt;26;i++) ans-=cnt[b[x]^(1&lt;&lt;i)];&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l=1,r=0;for(read(n,m),S=sqrt(n),scanf(&quot;%s&quot;,&amp;a),i=1;i&lt;=n;i++) b[i]=1&lt;&lt;(a[i-1]-&#x27;a&#x27;),b[i]^=b[i-1],bl[i]=(i-1)/S+1;</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i,q[i].l--;for(sort(q+1,q+m+1,cmp),i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        W(l&lt;q[i].l) Del(l++);W(l&gt;q[i].l) Add(--l);W(r&gt;q[i].r) Del(r--);W(r&lt;q[i].r) Add(++r);Ans[q[i].id]=ans;</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) writeln(Ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3793 由乃救爷爷</title>
      <link href="/2021/04/08/luogup3793-%E7%94%B1%E4%B9%83%E6%95%91%E7%88%B7%E7%88%B7/"/>
      <url>/2021/04/08/luogup3793-%E7%94%B1%E4%B9%83%E6%95%91%E7%88%B7%E7%88%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3793">P3793</a></p></blockquote><p>给定一个 $n$ 个数的序列，有 $m$ 个询问，每次询问区间最大值。</p><p>$1\leq n,m\leq 2\times 10^7$，保证数据随机。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑分块。</p><p>如果朴素分块肯定是不能过的 $O(N\sqrt{N})$，但是这题并没有修改操作，所以考虑先预处理出第 $l$ 个块到第 $r$ 个块的最大值、第 $i$ 个块的前缀最大值、第 $i$ 个块的后缀最大值。</p><p>每次询问的时候如果 $l,r$ 在同一个块内可以直接暴力，出现此情况应该是 $\frac{1}{\sqrt{N}}$，而单次暴力复杂度为 $O(\sqrt{N})$，所以总期望复杂度是 $O(N)$。</p><p>如果不在同一块内直接利用预处理出的结果 $O(1)$ 即可。</p><p>所以总的时间复杂度是 $O(N)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e7,S=10000,M=N/S;</span><br><span class="line">namespace GenHelper&#123;</span><br><span class="line">unsigned z1,z2,z3,z4,b;</span><br><span class="line">unsigned rand_()&#123;b=((z1&lt;&lt;6)^z1)&gt;&gt;13;z1=((z1&amp;4294967294U)&lt;&lt;18)^b;b=((z2&lt;&lt;2)^z2)&gt;&gt;27;z2=((z2&amp;4294967288U)&lt;&lt;2)^b;b=((z3&lt;&lt;13)^z3)&gt;&gt;21;z3=((z3&amp;4294967280U)&lt;&lt;7)^b;b=((z4&lt;&lt;3)^z4)&gt;&gt;12;z4=((z4&amp;4294967168U)&lt;&lt;13)^b;return (z1^z2^z3^z4);&#125;</span><br><span class="line">&#125;void srand(unsigned x)&#123;using namespace GenHelper;z1=x;z2=(~x)^0x233333333U;z3=x^0x1234598766U;z4=(~x)+51;&#125;</span><br><span class="line">int fread()&#123;using namespace GenHelper;int a=rand_()&amp;32767;int b=rand_()&amp;32767;return a*32768+b;&#125;</span><br><span class="line">int n,m,seed,a[N+5],F[M+5][M+5],G[M+5],L[M+5][S+5],R[M+5][S+5];</span><br><span class="line">unsigned long long Ans;</span><br><span class="line">I int Q(CI l,CI r)&#123;</span><br><span class="line">    RI X=0;if(l/S==r/S)&#123;RI i;for(i=l;i&lt;=r;i++) X=max(X,a[i]);return X;&#125;//直接暴力</span><br><span class="line">    if(l/S+2&lt;=r/S) X=F[l/S+2][r/S];X=max(X,max(R[l/S+1][l%S],L[r/S+1][r%S]));return X; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,l,r;read(n,m,seed),srand(seed);for(i=0;i&lt;n;i++) a[i]=fread(),G[i/S+1]=max(G[i/S+1],a[i]);</span><br><span class="line">    for(i=1;i&lt;=(n-1)/S+1;i++) for(j=i;j&lt;=(n-1)/S+1;j++) F[i][j]=max(F[i][j-1],G[j]);//块间最值</span><br><span class="line">    for(i=0;i&lt;n;i++) !(i%S)?L[i/S+1][i%S]=a[i]:L[i/S+1][i%S]=max(L[i/S+1][i%S-1],a[i]);</span><br><span class="line">    for(i=n-1;~i;i--) R[i/S+1][i%S]=max(R[i/S+1][i%S+1],a[i]);//前缀&amp;后缀最大值</span><br><span class="line">    W(m--) l=fread()%n,r=fread()%n,l&gt;r&amp;&amp;(swap(l,r),0),Ans+=Q(l,r);</span><br><span class="line">    return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3710 方方方的数据结构</title>
      <link href="/2021/04/08/luogup3710-%E6%96%B9%E6%96%B9%E6%96%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/04/08/luogup3710-%E6%96%B9%E6%96%B9%E6%96%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3710">P3710</a></p></blockquote><p>给定一个长度为 $n$ 的序列，一开始序列的数全是 $0$，有 $m$ 个操作。</p><ol><li>区间加</li><li>区间乘</li><li>单点查</li><li>撤销第 $p$ 个操作（保证为加、乘操作）</li></ol><p>$1\leq n,m\leq 150000$，时间限制 $4s$，保证数据随机。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先如果只有前 $3$ 个操作可以使用线段树。</p><p>然后考虑第 $4$ 个操作如何转化。</p><p>由于不是强制在线，所以可以先把所有询问都先离线下来，然后从后往前扫一遍所有第 $4$ 个操作，得出每个 $1,2$ 操作的生效区间。</p><p>然后就转化成了个二维平面问题：</p><ol><li>矩阵加</li><li>矩阵乘</li><li>单点查</li></ol><p>由于本蒟蒻不会 KD-TREE，所以就直接用四叉树啦（虽然四叉树的复杂度貌似是假的）</p><p>然而内存限制为 128MB，所以需要先把所有询问需要使用的区间先找出来，只对这个区间修改&amp;查询即可（这种方法只能针对于单点查询）。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=150010,P=998244353;</span><br><span class="line">int n,m,A[N],rt;</span><br><span class="line">struct Que&#123;int opt,l,r,x;&#125;q[N];</span><br><span class="line">class SegmentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int cnt;</span><br><span class="line">        struct node&#123;int son[4],S,T,sz;&#125;T[N*20];//由于每个询问最多只能扫log的区间，所以只需要开 N*20，S维护和，T为乘懒标记</span><br><span class="line">        #define midX (a+c&gt;&gt;1)</span><br><span class="line">        #define midY (b+d&gt;&gt;1)</span><br><span class="line">        #define S0 T[x].son[0],a,b,midX,midY</span><br><span class="line">        #define S1 T[x].son[1],midX+1,b,c,midY</span><br><span class="line">        #define S2 T[x].son[2],a,midY+1,midX,d</span><br><span class="line">        #define S3 T[x].son[3],midX+1,midY+1,c,d</span><br><span class="line">        I void NW(int&amp; x,CI a,CI b,CI c,CI d)&#123;!x&amp;&amp;(T[x=++cnt].sz=(c-a+1)*(d-b+1),</span><br><span class="line">        T[x].T=1,T[x].S=T[x].son[0]=T[x].son[1]=T[x].son[2]=T[x].son[3]=0);&#125;</span><br><span class="line">        #define PD(x,a,b,c,d) (x&amp;&amp;T[x].sz&gt;1&amp;&amp;(T[x].ST[x].T&gt;1)&amp;&amp;(\</span><br><span class="line">        T[x].son[0]&amp;&amp;(T[T[x].son[0]].T=1LL*T[T[x].son[0]].T*T[x].T%P,T[T[x].son[0]].S=1LL*T[T[x].son[0]].S*T[x].T%P,(T[T[x].son[0]].S+=T[x].S)%=P,0),\</span><br><span class="line">        T[x].son[1]&amp;&amp;(T[T[x].son[1]].T=1LL*T[T[x].son[1]].T*T[x].T%P,T[T[x].son[1]].S=1LL*T[T[x].son[1]].S*T[x].T%P,(T[T[x].son[1]].S+=T[x].S)%=P,0),\</span><br><span class="line">        T[x].son[2]&amp;&amp;(T[T[x].son[2]].T=1LL*T[T[x].son[2]].T*T[x].T%P,T[T[x].son[2]].S=1LL*T[T[x].son[2]].S*T[x].T%P,(T[T[x].son[2]].S+=T[x].S)%=P,0),\</span><br><span class="line">        T[x].son[3]&amp;&amp;(T[T[x].son[3]].T=1LL*T[T[x].son[3]].T*T[x].T%P,T[T[x].son[3]].S=1LL*T[T[x].son[3]].S*T[x].T%P,(T[T[x].son[3]].S+=T[x].S)%=P,0),\</span><br><span class="line">        T[x].S=0,T[x].T=1))</span><br><span class="line">    public:</span><br><span class="line">        I void B(int&amp; x,CI a,CI b,CI c,CI d,CI Qx,CI Qy)&#123;//预先建点</span><br><span class="line">            NW(x,a,b,c,d);if(a==c&amp;&amp;b==d) return ;</span><br><span class="line">            Qx&lt;=midX&amp;&amp;Qy&lt;=midY&amp;&amp;(B(S0,Qx,Qy),0),</span><br><span class="line">            Qx&gt;midX&amp;&amp;Qy&lt;=midY&amp;&amp;(B(S1,Qx,Qy),0),</span><br><span class="line">            Qx&lt;=midX&amp;&amp;Qy&gt;midY&amp;&amp;(B(S2,Qx,Qy),0),</span><br><span class="line">            Qx&gt;midX&amp;&amp;Qy&gt;midY&amp;&amp;(B(S3,Qx,Qy),0);</span><br><span class="line">        &#125;</span><br><span class="line">        I void Add(int&amp; x,CI a,CI b,CI c,CI d,CI Qa,CI Qb,CI Qc,CI Qd,CI v)&#123;//矩阵加</span><br><span class="line">            if(!x) return ;if(Qa&lt;=a&amp;&amp;Qb&lt;=b&amp;&amp;c&lt;=Qc&amp;&amp;d&lt;=Qd) return void((T[x].S+=v)%=P);</span><br><span class="line">            PD(x,a,b,c,d),Qa&lt;=midX&amp;&amp;Qb&lt;=midY&amp;&amp;(Add(S0,Qa,Qb,min(Qc,midX),min(Qd,midY),v),0),</span><br><span class="line">            Qc&gt;midX&amp;&amp;Qb&lt;=midY&amp;&amp;(Add(S1,max(Qa,midX+1),Qb,Qc,min(Qd,midY),v),0),</span><br><span class="line">            Qa&lt;=midX&amp;&amp;Qd&gt;midY&amp;&amp;(Add(S2,Qa,max(Qb,midY+1),min(Qc,midX),Qd,v),0),</span><br><span class="line">            Qc&gt;midX&amp;&amp;Qd&gt;midY&amp;&amp;(Add(S3,max(Qa,midX+1),max(Qb,midY+1),Qc,Qd,v),0);</span><br><span class="line">        &#125;</span><br><span class="line">        I void Mul(int&amp; x,CI a,CI b,CI c,CI d,CI Qa,CI Qb,CI Qc,CI Qd,CI v)&#123;//矩阵乘</span><br><span class="line">            if(!x) return ;if(Qa&lt;=a&amp;&amp;Qb&lt;=b&amp;&amp;c&lt;=Qc&amp;&amp;d&lt;=Qd) return T[x].T=1LL*T[x].T*v%P,void(T[x].S=1LL*T[x].S*v%P);</span><br><span class="line">            PD(x,a,b,c,d),Qa&lt;=midX&amp;&amp;Qb&lt;=midY&amp;&amp;(Mul(S0,Qa,Qb,min(Qc,midX),min(Qd,midY),v),0),</span><br><span class="line">            Qc&gt;midX&amp;&amp;Qb&lt;=midY&amp;&amp;(Mul(S1,max(Qa,midX+1),Qb,Qc,min(Qd,midY),v),0),</span><br><span class="line">            Qa&lt;=midX&amp;&amp;Qd&gt;midY&amp;&amp;(Mul(S2,Qa,max(Qb,midY+1),min(Qc,midX),Qd,v),0),</span><br><span class="line">            Qc&gt;midX&amp;&amp;Qd&gt;midY&amp;&amp;(Mul(S3,max(Qa,midX+1),max(Qb,midY+1),Qc,Qd,v),0);</span><br><span class="line">        &#125;</span><br><span class="line">        I int Q(int &amp;x,CI a,CI b,CI c,CI d,CI Qx,CI Qy)&#123;//单点查</span><br><span class="line">            if(!x) return 0;if(a==c&amp;&amp;b==d) return T[x].S;</span><br><span class="line">            RI S=0;return PD(x,a,b,c,d),Qx&lt;=midX&amp;&amp;Qy&lt;=midY&amp;&amp;((S+=Q(S0,Qx,Qy))%=P),</span><br><span class="line">            Qx&gt;midX&amp;&amp;Qy&lt;=midY&amp;&amp;((S+=Q(S1,Qx,Qy))%=P),</span><br><span class="line">            Qx&lt;=midX&amp;&amp;Qy&gt;midY&amp;&amp;((S+=Q(S2,Qx,Qy))%=P),</span><br><span class="line">            Qx&gt;midX&amp;&amp;Qy&gt;midY&amp;&amp;((S+=Q(S3,Qx,Qy))%=P),S;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n,m),i=1;i&lt;=m;i++) read(q[i].opt),q[i].opt&lt;=2&amp;&amp;(read(q[i].l,q[i].r),0),read(q[i].x),A[i]=m;</span><br><span class="line">    for(i=m;i&gt;=1;i--) q[i].opt==4&amp;&amp;(A[q[i].x]=i);//先找出每个修改操作的生效区间</span><br><span class="line">    for(i=1;i&lt;=m;i++) if(q[i].opt==3) S.B(rt,1,1,m,n,i,q[i].x);//预先建点</span><br><span class="line">    for(i=1;i&lt;=m;i++) if(q[i].opt==1) S.Add(rt,1,1,m,n,i,q[i].l,A[i],q[i].r,q[i].x);</span><br><span class="line">    else if(q[i].opt==2) S.Mul(rt,1,1,m,n,i,q[i].l,A[i],q[i].r,q[i].x);</span><br><span class="line">    else if(q[i].opt==3) writeln(S.Q(rt,1,1,m,n,i,q[i].x));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4117 [Ynoi2018] 五彩斑斓的世界</title>
      <link href="/2021/04/05/p4117-ynoi2018-%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/2021/04/05/p4117-ynoi2018-%E4%BA%94%E5%BD%A9%E6%96%91%E6%96%93%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4117">P4117</a></p></blockquote><p>给定一个长为 $n$ 的序列，有 $m$ 个操作：</p><ol><li>区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。</li><li>查询区间 $[l,r]$ 中 $x$ 的出现次数。</li></ol><p>$1\leq n \leq 10^6,1\leq m \leq 5\times 10^5,1\leq l \leq r\leq n,0\leq a_i,x\leq 10^5+1$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>注意到数值很小，所以可以考虑利用值域。</p><p>首先我们记录每个块的最大值。</p><p>如果 $Max\leq x\times 2$，那么我们直接暴力把所有大于 $x$ 的数减去 $x$，复杂度为 $O(x)$。</p><p>如果 $Max&gt;x\times 2$，那么我们反过来，把小于 $x$ 的数加上 $x$，再打上块内全局减 $x$ 的标记，复杂度为 $O(Max-x)$。</p><p>所以总复杂度为 $O(\sqrt{N}V)$。</p><p>考虑如何快速维护合并、动态查询单点、个数查询，很显然可以用并查集。</p><p>所以时间复杂度为 $O(\sqrt{N}V\alpha(N))$。</p><p>注意到此题的空间只有 64MB。</p><p>所以考虑把询问离线下来，把每个操作拆分到每个块中即可。</p><p>然后稍微卡卡常就过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6,S=1272,M=N/S,V=1e5+1,QQ=5e5;</span><br><span class="line">int n,m,b[M+5][S+5],sz[M+5],tot,F[S+5],G[S+5],H[V+5],mx,T,Ans[QQ+5];</span><br><span class="line">struct Que&#123;int opt,l,r,x,id;&#125;q[QQ+5];</span><br><span class="line">I int find(CI k,CI x)&#123;return x==F[x]?x:F[x]=find(k,F[x]);&#125;</span><br><span class="line">I void Z(CI k,CI l,CI r,CI x)&#123;</span><br><span class="line">    RI i;for(i=0;i&lt;sz[k];i++) G[H[b[k][i]=b[k][find(k,i)]]]=0;for(mx=0,i=0;i&lt;sz[k];i++) H[b[k][i]]=F[i]=-1,b[k][i]-=T;</span><br><span class="line">    for(i=l;i&lt;=r;i++) b[k][i]&gt;x&amp;&amp;(b[k][i]-=x);for(T=0,i=0;i&lt;sz[k];i++) mx=max(mx,b[k][i]),~H[b[k][i]]?++G[F[i]=H[b[k][i]]]:G[F[i]=H[b[k][i]]=i]=1;</span><br><span class="line">&#125;</span><br><span class="line">I void Merge(CI k,CI x,CI y)&#123;~H[y]&amp;&amp;(~H[x]?G[F[H[y]]=H[x]]+=G[H[y]],G[H[y]]=0:b[k][H[x]=H[y]]=x,H[y]=-1);&#125;</span><br><span class="line">I void U(RI l,RI r,CI x)&#123;</span><br><span class="line">    RI i,j,bL=l/S+1,bR=r/S+1;if(l-=(bL-1)*S,r-=(bR-1)*S,lr&lt;sz[bL]-1) return Z(bL,l,r,x);//散块暴力</span><br><span class="line">    if(2*x&gt;mx-T)&#123;for(j=T+x+1;j&lt;=mx;j++) Merge(bL,j-x,j);mx=min(mx,T+x);&#125;</span><br><span class="line">    else&#123;for(j=T+x;j&gt;=T+1;j--) Merge(bL,j+x,j);T+=x;&#125;//分两类情况讨论</span><br><span class="line">&#125;</span><br><span class="line">I int Y(CI k,CI l,CI r,CI x)&#123;RI X=0,i;for(i=l;i&lt;=r;i++) b[k][find(k,i)]==T+x&amp;&amp;++X;return X;&#125;</span><br><span class="line">I int Q(RI l,RI r,CI x)&#123;</span><br><span class="line">    RI i,bL=l/S+1,bR=r/S+1,X=0;if(l-=(bL-1)*S,r-=(bR-1)*S,lr&lt;sz[bL]-1) return Y(bL,l,r,x);//散块暴力</span><br><span class="line">    for(i=bL;i&lt;=bR;i++) T+x&lt;=V&amp;&amp;~H[T+x]&amp;&amp;(X+=G[H[T+x]]);return X;//直接用并查集维护</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,p,k,opt,l,r,x;for(read(n,m),i=0;i&lt;n;i++) read(x),b[i/S+1][sz[i/S+1]++]=x;memset(F,-1,sizeof(F)),memset(H,-1,sizeof(H));</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(q[i].opt,q[i].l,q[i].r,q[i].x),q[i].l--,q[i].r--,q[i].id=i;for(i=1;i&lt;=(n-1)/S+1;i++)&#123;</span><br><span class="line">        memset(H,-1,sizeof(H)),memset(G,0,sizeof(G)),memset(F,-1,sizeof(F));</span><br><span class="line">        for(T=mx=0,j=0;j&lt;sz[i];j++) ~H[b[i][j]]?++G[F[j]=H[b[i][j]]]:G[F[j]=H[b[i][j]]=j]=1,mx=max(mx,b[i][j]);</span><br><span class="line">        for(j=1;j&lt;=m;j++) if((i-1)*S&lt;=q[j].r&amp;&amp;q[j].l&lt;=min(n-1,i*S-1)) if(q[j].opt==1) U(max(q[j].l,(i-1)*S),min(min(n-1,i*S-1),q[j].r),q[j].x);</span><br><span class="line">        else Ans[q[j].id]+=Q(max(q[j].l,(i-1)*S),min(min(n-1,i*S-1),q[j].r),q[j].x);//离线</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) if(q[i].opt==2) writeln(Ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP4168 [Violet]蒲公英</title>
      <link href="/2021/04/04/luogup4168-violet%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
      <url>/2021/04/04/luogup4168-violet%E8%92%B2%E5%85%AC%E8%8B%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4168">P4168</a></p></blockquote><p>给定一个长度为 $n$ 的序列，$m$ 次询问，每次询问输出区间众数，如果出现次数相同，输出编号小的。</p><p><strong>强制在线</strong>。</p><p>$1\leq n\leq 4\times 10^4,1\leq m \leq 5\times 10^4,1\leq a_i\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>看到区间众数，自然而然就想到可以直接分块，时间复杂度 $O((N+M)\sqrt{N})$，空间复杂度 $O(N\sqrt{N})$，足矣通过此题，由于其他题解都写得很详细，这里就不再赘述。</p><p>那有没有更加优秀的算法呢？当然有，可以仿照<a href="https://www.luogu.com.cn/problem/P5048">P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III</a>的思路，预处理出 $[i,j]$ 块的众数出现次数，用 vector 按顺序存储每个数的所有元素出现位置，记录对应下标，每次询问的时候整块直接用预处理中的即可，散块个数最多为 $2\sqrt{N}$ 个，所以最多使答案增加 $2\sqrt{N}$，所以我们只需要扫一遍，判断这些数的出现个数是否能使答案加一即可。</p><p>总时间复杂度 $O((N+M)\sqrt{N})$，空间复杂度 $O(N)$，然而这种做法常数更小，所以跑得飞快，顺手卡一卡就拿到了最优解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>普通分块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=4e4+10,S=500,M=N/S+10;</span><br><span class="line">int n,m,a[N],b[N],cnt,tot,Ans,L[M],R[M],Cnt[M][N],F[M][M],sum[N];</span><br><span class="line">#define GetCnt(i,j,k) (Cnt[(j)][(k)]-Cnt[(i)-1][(k)])</span><br><span class="line">I void Build()&#123;</span><br><span class="line">    RI i,j,k,t,now;for(sort(b,b+n),cnt=unique(b,b+n)-b,i=0;i&lt;n;i++) a[i]=lower_bound(b,b+cnt,a[i])-b;</span><br><span class="line">    for(i=0;i&lt;n;i++) if(i%S==0) R[tot]=i-1,L[++tot]=i;R[tot]=n-1;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(j=L[i];j&lt;=R[i];j++) Cnt[i][a[j]]++;for(i=1;i&lt;=tot;i++) for(j=0;j&lt;cnt;j++) Cnt[i][j]+=Cnt[i-1][j];</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(now=a[j=i];j&lt;=tot;j++) for(k=L[j];k==R[j]+1&amp;&amp;(F[i][j]=now),k&lt;=R[j];k++)</span><br><span class="line">    if(GetCnt(i,j,a[k])&gt;GetCnt(i,j,now)GetCnt(i,j,a[k])==GetCnt(i,j,now)&amp;&amp;a[k]&lt;now) now=a[k];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">I int Query(CI Ll,CI Rr)&#123;</span><br><span class="line">    RI i,j,l,r,now;l=Ll/S+1,r=Rr/S+1;v.clear();memset(sum,0,sizeof(sum));</span><br><span class="line">    if(l==r)&#123;for(i=Ll;i&lt;=Rr;i++) v.push_back(a[i]),now=a[i],sum[a[i]]++;for(auto i:v) if(sum[i]&gt;sum[now]sum[i]==sum[now]&amp;&amp;i&lt;now) now=i;return b[now];&#125;</span><br><span class="line">    if(L[l]^Ll)&#123;for(i=Ll;i&lt;=R[l];i++) v.push_back(a[i]),sum[a[i]]++;l++;&#125;</span><br><span class="line">    if(R[r]^Rr)&#123;for(i=L[r];i&lt;=Rr;i++) v.push_back(a[i]),sum[a[i]]++;r--;&#125;</span><br><span class="line">    now=F[l][r];for(auto i:v) if(sum[i]+GetCnt(l,r,i)&gt;sum[now]+GetCnt(l,r,now)sum[i]+GetCnt(l,r,i)==sum[now]+GetCnt(l,r,now)&amp;&amp;i&lt;now) now=i;</span><br><span class="line">    return b[now];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r,p=0;for(read(n,m),i=0;i&lt;n;i++) read(a[i]),b[i]=a[i];</span><br><span class="line">    for(Build();m--;) read(l,r),l=(l+p-1)%n,r=(r+p-1)%n,l&gt;r&amp;&amp;(swap(l,r),0),writeln(p=Query(l,r));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear()&#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x)&#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=4e4+2,S=106,M=N/S+2;</span><br><span class="line">int n,m,a[N],b[N],cnt,tot,Ans,Cnt[N],F[M][M],pos[N],DP[M][M],SZ[N];</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">I void Build()&#123;</span><br><span class="line">    RI i,j,k,t,now;for(sort(b,b+n),cnt=unique(b,b+n)-b,i=0;i&lt;n;i++)</span><br><span class="line">    a[i]=lower_bound(b,b+cnt,a[i])-b,pos[i]=SZ[a[i]]++,v[a[i]].push_back(i);tot=(n-1)/S+1;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) for(memset(Cnt,0,sizeof(Cnt)),now=a[j=i];j&lt;=tot;j++)</span><br><span class="line">    for(k=(j-1)*S;k==min(j*S-1,n-1)+1&amp;&amp;(F[i][j]=Cnt[now],DP[i][j]=now),k&lt;=min(j*S-1,n-1);k++) if(++Cnt[a[k]],Cnt[a[k]]&gt;Cnt[now](Cnt[a[k]]==Cnt[now]&amp;&amp;a[k]&lt;now)) now=a[k];</span><br><span class="line">&#125;</span><br><span class="line">I int Query(CI Ll,CI Rr)&#123;</span><br><span class="line">    RI i,j,l=Ll/S+1,r=Rr/S+1,now=0,zz=0;if(l==r)&#123;</span><br><span class="line">        for(now=0,i=Ll;i&lt;=Rr;i++)&#123;W(pos[i]+now&lt;SZ[a[i]]&amp;&amp;v[a[i]][pos[i]+now]&lt;=Rr) zz=a[i],now++;if(pos[i]+now-1&lt;SZ[a[i]]&amp;&amp;v[a[i]][pos[i]+now-1]&lt;=Rr&amp;&amp;zz&gt;a[i]) zz=a[i];&#125;</span><br><span class="line">        return b[zz];</span><br><span class="line">    &#125;if(l+1&lt;=r-1) now=F[l+1][r-1],zz=DP[l+1][r-1];</span><br><span class="line">    for(i=Ll;i&lt;=min(l*S-1,n-1);i++)&#123;W(pos[i]+now&lt;SZ[a[i]]&amp;&amp;v[a[i]][pos[i]+now]&lt;=Rr) zz=a[i],now++;if(pos[i]+now-1&lt;SZ[a[i]]&amp;&amp;v[a[i]][pos[i]+now-1]&lt;=Rr&amp;&amp;zz&gt;a[i]) zz=a[i];&#125;</span><br><span class="line">    for(i=(r-1)*S;i&lt;=Rr;i++)&#123;W(pos[i]-now&gt;=0&amp;&amp;v[a[i]][pos[i]-now]&gt;=Ll) zz=a[i],now++;if(pos[i]-(now-1)&gt;=0&amp;&amp;v[a[i]][pos[i]-(now-1)]&gt;=Ll&amp;&amp;zz&gt;a[i]) zz=a[i];&#125;</span><br><span class="line">    return b[zz];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,l,r,p=0;for(read(n,m),i=0;i&lt;n;i++) read(a[i]),b[i]=a[i];</span><br><span class="line">    for(Build();m--;) read(l,r),l=l+p-1,l&gt;=n&amp;&amp;(l%=n,0),r=r+p-1,r&gt;=n&amp;&amp;(r%=n,0),l&gt;r&amp;&amp;(swap(l,r),0),writeln(p=Query(l,r));</span><br><span class="line">    return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP5071 [Ynoi2015] 此时此刻的光辉</title>
      <link href="/2021/04/04/luogup5071-ynoi2015-%E6%AD%A4%E6%97%B6%E6%AD%A4%E5%88%BB%E7%9A%84%E5%85%89%E8%BE%89/"/>
      <url>/2021/04/04/luogup5071-ynoi2015-%E6%AD%A4%E6%97%B6%E6%AD%A4%E5%88%BB%E7%9A%84%E5%85%89%E8%BE%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5071">P5071</a></p></blockquote><p>给定一个长为 $n$ 的序列，有 $m$ 次查询，每次查询一段区间的乘积的约数个数 $\bmod 19260817$ 的值。</p><p>$1\leq n,m \leq 10^5,1\leq a_i \leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>乍看题目，不难想到一种很暴力的做法：先对每个数质因数分解，然后利用<a href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E5%92%8C%E5%AE%9A%E7%90%86/3808428">约数和定理</a>直接莫队即可。</p><p>但一点开题解区发现都过不了，还要用pr&amp;根号分治。</p><p>但是后来经过陈指导的提醒，直接敲了个暴力就跑过去了（</p><p>这里列举一些优化：</p><ol><li>预处理线性求逆元。</li><li>筛素数不一定要筛到 $\sqrt{10^9}$，可以适量调大点。</li><li>有信仰</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int OT;char oc,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear()&#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;x=0;W(!isdigit(oc=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(oc&amp;15),isdigit(oc=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x)&#123;W(OS[++OT]=x%10+48,x/=10);W(OT) pc(OS[OT--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,S=650,M=N/S+10,P=19260817;</span><br><span class="line">int n,m,bl[N],X,p[71625],s[500000],c[N][12],tot,Inv[N*30+10],sz[N],g[N][12],Ans[N];</span><br><span class="line">struct Que&#123;int l,r,id;&#125;q[N];</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?x.l&lt;y.l:x.r&lt;y.r;&#125;</span><br><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">I void Get()&#123;</span><br><span class="line">    for(RI j,t,i=2;i&lt;=71622;i++) for(!p[i]&amp;&amp;(p[++tot]=i,mp[i]=tot),j=1;j&lt;=tot&amp;&amp;(t=i*p[j])&lt;=71622;j++)</span><br><span class="line">    if(p[t]=1,!(i%p[j])) break ;//线性筛质数</span><br><span class="line">&#125;</span><br><span class="line">I void Init(CI x,RI v)&#123;</span><br><span class="line">    for(RI i=1;i&lt;=tot&amp;&amp;1LL*p[i]*p[i]&lt;=v;i++) if(!(v%p[i]))&#123;</span><br><span class="line">        g[x][++sz[x]]=i;W(v/=p[i],c[x][sz[x]]++,!(v%p[i]));//预处理每个数字质因数分解</span><br><span class="line">    &#125;if(v&gt;1) !mp[v]&amp;&amp;(mp[v]=++tot),g[x][++sz[x]]=mp[v],c[x][sz[x]]=1;//注意大质数情况</span><br><span class="line">&#125;</span><br><span class="line">I void U(CI x,CI v)&#123;</span><br><span class="line">    for(RI i=1;i&lt;=sz[x];i++) X=1LL*X*Inv[s[g[x][i]]+1]%P*((s[g[x][i]]+=v*c[x][i])+1)%P;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,l,r;for(Get(),Inv[0]=Inv[1]=1,i=2;i&lt;=30*N;i++) Inv[i]=P-1LL*P/i*Inv[P%i]%P;//线性求逆元</span><br><span class="line">    for(read(n,m),i=1;i&lt;=n;i++) read(x),Init(i,x),bl[i]=(i-1)/S+1;</span><br><span class="line">    for(i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i;for(sort(q+1,q+m+1,cmp),l=1,r=0,X=1,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        W(r&lt;q[i].r) U(++r,1);W(r&gt;q[i].r) U(r--,-1);W(l&gt;q[i].l) U(--l,1);W(l&lt;q[i].l) U(l++,-1);Ans[q[i].id]=X;//莫队</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) writeln(Ans[i]);return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP5356 [Ynoi2017] 由乃打扑克</title>
      <link href="/2021/03/31/luogup5356-ynoi2017-%E7%94%B1%E4%B9%83%E6%89%93%E6%89%91%E5%85%8B/"/>
      <url>/2021/03/31/luogup5356-ynoi2017-%E7%94%B1%E4%B9%83%E6%89%93%E6%89%91%E5%85%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P5356">P5356</a></p></blockquote><p>一个长为 $n$ 的序列 $a$，需要支持 $m$ 次操作，操作有两种：</p><ol><li>查询区间 $[l,r]$ 的第 $k$ 小值。</li><li>区间 $[l,r]$ 加上 $k$。</li></ol><p>$1\leq n,m\leq 10^5,-2\times 10^4\leq$ 每次加上的数和原序列的数 $\leq 2\times 10^4$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>查询第 $k$ 小，直接想到两种方法：</p><ol><li>二分枚举然后再统计次数统计，复杂度 $O(\sqrt{N}log_2V)$</li><li>值域分块，记录前缀和。</li></ol><p>第一种方法显然</p><blockquote><p>很遗憾，被我卡掉了。——lxl</p></blockquote><p>但是却可以AC本题</p><p>考虑第二种方法区间修改有点困难，所以直接上第一种方法，修改时只要整块打上标记，散块暴力修改即可，加上各种优化：</p><ol><li>二分的边界可以先跑一次求出最大最小值。</li><li>二分判断统计时，最大值也小于等于 $mid$，直接加上块长即可，最小值大于 $mid$，直接跳过即可。</li><li>一颗沉稳的心</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,S=250,M=N/S+10;</span><br><span class="line">int n,m,tot,g[M],mn[M],mx[N];</span><br><span class="line">vector&lt;int&gt; b[M],s[M];</span><br><span class="line">I void B(CI x)&#123;s[x]=b[x],sort(s[x].begin(),s[x].end()),mn[x]=*s[x].begin(),mx[x]=*s[x].rbegin();&#125;</span><br><span class="line">I bool check(CI bL,CI bR,CI l,CI r,CI mid,CI k)&#123;</span><br><span class="line">    RI i,S=0;if(bL==bR)&#123;for(i=l;i&lt;=r;i++) if(b[bL][i]+g[bL]&lt;=mid) S++;return S&gt;=k;&#125;</span><br><span class="line">    for(i=l;i&lt;b[bL].size();i++) if(b[bL][i]+g[bL]&lt;=mid) S++;for(i=0;i&lt;=r;i++) if(b[bR][i]+g[bR]&lt;=mid) S++;</span><br><span class="line">    for(i=bL+1;i&lt;=bR-1;i++) if(mx[i]+g[i]&lt;=mid) S+=b[i].size();</span><br><span class="line">    else if(mn[i]+g[i]&lt;=mid) S+=(upper_bound(s[i].begin(),s[i].end(),mid-g[i])-s[i].begin());return S&gt;=k; </span><br><span class="line">&#125;</span><br><span class="line">I int Gmn(RI l,RI r)&#123;</span><br><span class="line">    RI i,bL=1,bR=1,S=2e9;W(l&gt;=b[bL].size()) l-=b[bL++].size();W(r&gt;=b[bR].size()) r-=b[bR++].size();</span><br><span class="line">    if(bL==bR)&#123;for(i=l;i&lt;=r;i++) S=min(S,b[bL][i]+g[bL]);return S;&#125;</span><br><span class="line">    for(i=l;i&lt;b[bL].size();i++) S=min(S,b[bL][i]+g[bL]);for(i=0;i&lt;=r;i++) S=min(S,b[bR][i]+g[bR]);</span><br><span class="line">    for(i=bL+1;i&lt;=bR-1;i++) S=min(S,*s[i].begin()+g[i]);return S;</span><br><span class="line">&#125;</span><br><span class="line">I int Gmx(RI l,RI r)&#123;</span><br><span class="line">    RI i,bL=1,bR=1,S=-2e9;W(l&gt;=b[bL].size()) l-=b[bL++].size();W(r&gt;=b[bR].size()) r-=b[bR++].size();</span><br><span class="line">    if(bL==bR)&#123;for(i=l;i&lt;=r;i++) S=max(S,b[bL][i]+g[bL]);return S;&#125;</span><br><span class="line">    for(i=l;i&lt;b[bL].size();i++) S=max(S,b[bL][i]+g[bL]);for(i=0;i&lt;=r;i++) S=max(S,b[bR][i]+g[bR]);</span><br><span class="line">    for(i=bL+1;i&lt;=bR-1;i++) S=max(S,*s[i].rbegin()+g[i]);return S;</span><br><span class="line">&#125;</span><br><span class="line">I int Q(RI l,RI r,CI k)&#123;</span><br><span class="line">    if(r-l+1&lt;k) return -1;RI i,L=Gmn(l,r),R=Gmx(l,r),S=2e9+1,mid,bL=1,bR=1;W(l&gt;=b[bL].size()) l-=b[bL++].size();W(r&gt;=b[bR].size()) r-=b[bR++].size();</span><br><span class="line">    W(L&lt;=R) check(bL,bR,l,r,mid=(1LL*L+R&gt;&gt;1),k)?(S=mid,R=mid-1):L=mid+1;return S==2e9+1?-1:S;</span><br><span class="line">&#125;</span><br><span class="line">I void U(RI l,RI r,CI k)&#123;</span><br><span class="line">    RI i,bL=1,bR=1;W(l&gt;=b[bL].size()) l-=b[bL++].size();W(r&gt;=b[bR].size()) r-=b[bR++].size();</span><br><span class="line">    if(bL==bR)&#123;for(i=l;i&lt;=r;i++) b[bL][i]+=k;return B(bL);&#125;</span><br><span class="line">    for(i=l;i&lt;b[bL].size();i++) b[bL][i]+=k;B(bL);for(i=0;i&lt;=r;i++) b[bR][i]+=k;B(bR);</span><br><span class="line">    for(i=bL+1;i&lt;=bR-1;i++) g[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123; </span><br><span class="line">    RI i,x,opt,l,r,k;for(read(n,m),i=0;i&lt;n;i++) read(x),b[i/S+1].push_back(x);tot=(n-1)/S+1;</span><br><span class="line">    for(i=1;i&lt;=tot;i++) B(i);for(i=1;i&lt;=m;i++) if(read(opt,l,r,k),opt==1) writeln(Q(l-1,r-1,k));</span><br><span class="line">    else U(l-1,r-1,k);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP4119 [Ynoi2018] 未来日记</title>
      <link href="/2021/03/31/luogup4119-ynoi2018-%E6%9C%AA%E6%9D%A5%E6%97%A5%E8%AE%B0/"/>
      <url>/2021/03/31/luogup4119-ynoi2018-%E6%9C%AA%E6%9D%A5%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://www.luogu.com.cn/problem/P4119">P4119</a></p></blockquote><p>一个长为 $n$ 的序列 $a$，有 $m$ 次操作。</p><ol><li>把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。</li><li>查询区间 $[l,r]$ 内第 $k$ 小值。</li></ol><p>$1\leq n,m,a_i\leq 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>stO 陈指导 Orz，陈指导码了一个下午就做完了，蒟蒻我竟然写了3天。</p><p>首先要对序列分块，对于整块，考虑直接把一种数字直接改成另一种数字，然后可以考虑使用<strong>并查集</strong>。对于散块，我们可以直接暴力枚举修改，暴力重构并查集即可。</p><p>这时候需要分类讨论：</p><ol><li>该块中没有出现 $x$，那么直接跳过即可。</li><li>该块出现了 $x$，没有出现 $y$，那么就直接用并查集映射即可。</li><li>该块出现了 $x$，也出现了 $y$，直接暴力重构。</li></ol><p>然后我们会发现一个细节：如果我们并查集记录的是<strong>每个块的颜色指向的真实颜色</strong>，那么会出现一些问题：如果将块内所有 $1$ 改为 $2$，再将所有 $3$ 改为 $1$ 这种情况就非常难处理。</p><p>所以我们可以选择记录<strong>块内每个位置在块内与其数字相同的编号最小值</strong>，这样就可以完美规避上面的问题了。</p><p>然后我们发现询问还是有点苦难，这时候应该可以想到查找区间第 $k$ 小的常见套路：值域分块，记录每个序列块的前缀和。具体实现方法就是”带插入区间第 $k$ 小”方法。</p><p>这时候敲代码的时候又会发现一个问题：每次修改要更新的是前缀和，复杂度会升到 $O(NM)$。考虑修改的过程中开个桶记录下第 $k$ 个块修改的权值和，修改全部完成后再扫一遍所有的块，更新前缀和即可。</p><p>可以发现暴力重构块的次数是有限的，每次合并时块内权值种类会减少 $1$，而权值种类总共不会超过$n+m$，可以保证复杂度正确性 $O((N+M)\sqrt{N})$。</p><p>然后不知道为什么被lxl卡得很慢</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10,S=452,M=N/S+5,SS=385,MM=N/SS+5;</span><br><span class="line">int n,m,b[M][S+5],sz[M],L[M],cnt[M][N],cntS[M][MM],F[M][S+5],H[M][N],tot,stk[N],top,tcnt[N],tcntS[MM],T[M];</span><br><span class="line">I int Find(CI k,CI x,CI t=0)&#123;return x==F[k][x]?x:F[k][x]=Find(k,F[k][x],t);&#125;//并查集</span><br><span class="line">I void B(CI k,CI x=-1,CI y=-1,CI l=0,CI r=0,CI v=0)&#123;//暴力重构块</span><br><span class="line">    RI i,t;for(i=0;i&lt;sz[k];i++) t=b[k][Find(k,i,1)],b[k][i]=t,H[k][t]=-1;//并查集重置</span><br><span class="line">    if(~x) for(i=(v?l:0);i&lt;=(v?r:sz[k]-1);i++) if(b[k][i]==x) b[k][i]=y,T[k]++;//暴力修改</span><br><span class="line">    for(i=0;i&lt;sz[k];i++) F[k][i]=((~H[k][b[k][i]])?H[k][b[k][i]]:H[k][b[k][i]]=i);//重构并查集</span><br><span class="line">&#125;</span><br><span class="line">I void P(CI k,CI l,CI r,CI x,CI y)&#123;RI i;B(k,x,y,l,r,1);&#125;//边角暴力重构</span><br><span class="line">I void R(CI x,CI y)&#123;RI i,t=0;for(i=1;i&lt;=tot;i++) t+=T[i],cnt[i][x]-=t,cntS[i][x/SS]-=t,cnt[i][y]+=t,cntS[i][y/SS]+=t,T[i]=0;&#125;//开临时数组记录，最后直接扫一遍累加更新前缀和</span><br><span class="line">I void U(RI l,RI r,CI x,CI y)&#123;</span><br><span class="line">    if(x==y) return ;RI i,bL=(l-1)/S+1,bR=(r-1)/S+1;if(l-=L[bL],r-=L[bR],bL==bR) return P(bL,l,r,x,y),R(x,y);</span><br><span class="line">    for(P(bL,l,sz[bL]-1,x,y),P(bR,0,r,x,y),i=bL+1;i&lt;=bR-1;i++) if(cnt[i][x]^cnt[i-1][x]&amp;&amp;cnt[i][y]==cnt[i-1][y]) T[i]+=cnt[i][x]-cnt[i-1][x],F[i][H[i][x]]=H[i][y]=H[i][x],b[i][H[i][x]]=y,H[i][x]=-1;//如果没有y，直接映射</span><br><span class="line">    else if(cnt[i][x]^cnt[i-1][x]&amp;&amp;cnt[i][y]^cnt[i-1][y]) B(i,x,y);return R(x,y);//如果有y，直接暴力重构</span><br><span class="line">&#125;</span><br><span class="line">I void G(CI k,CI l,CI r)&#123;RI i;for(i=l;i&lt;=r;i++) stk[++top]=b[k][Find(k,i)],tcnt[stk[top]]++,tcntS[stk[top]/SS]++;&#125;//散块暴力统计</span><br><span class="line">I void C()&#123;W(top) tcnt[stk[top]]--,tcntS[stk[top]/SS]--,top--;&#125;//记得清空</span><br><span class="line">I int Q(RI l,RI r,RI k)&#123;//值域分块，基本套路</span><br><span class="line">    RI i,j,bL=(l-1)/S+1,bR=(r-1)/S+1;if(l-=L[bL],r-=L[bR],bL==bR) for(G(bL,l,r),i=0;;i++) if(tcntS[i]&lt;k) k-=tcntS[i];</span><br><span class="line">    else for(j=SS*i;;j++) if(k&gt;tcnt[j]) k-=tcnt[j];else return C(),j;</span><br><span class="line">    else for(G(bL,l,sz[bL]-1),G(bR,0,r),i=0;;i++) if(k&gt;tcntS[i]+cntS[bR-1][i]-cntS[bL][i]) k-=tcntS[i]+cntS[bR-1][i]-cntS[bL][i];</span><br><span class="line">    else for(j=SS*i;;j++) if(k&gt;tcnt[j]+cnt[bR-1][j]-cnt[bL][j]) k-=tcnt[j]+cnt[bR-1][j]-cnt[bL][j];else return C(),j;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,opt,l,r,x,y;for(read(n,m),i=1;i&lt;=n;i++) read(x),!((i-1)%S)&amp;&amp;(L[++tot]=i),b[tot][sz[tot]++]=x;</span><br><span class="line">    memset(F,-1,sizeof(F));memset(H,-1,sizeof(H));for(i=1;i&lt;=tot;i++) for(j=0;j&lt;sz[i];j++) for(F[i][j]=((~H[i][b[i][j]])?H[i][b[i][j]]:H[i][b[i][j]]=j),k=i;k&lt;=tot;k++) cnt[k][b[i][j]]++,cntS[k][b[i][j]/SS]++;</span><br><span class="line">    W(m--) if(read(opt,l,r,x),opt==1) read(y),U(l,r,x,y);else writeln(Q(l,r,x));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP4593 [TJOI2018]教科书般的亵渎</title>
      <link href="/2021/03/25/luogup4593-tjoi2018%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/"/>
      <url>/2021/03/25/luogup4593-tjoi2018%E6%95%99%E7%A7%91%E4%B9%A6%E8%88%AC%E7%9A%84%E4%BA%B5%E6%B8%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4593">题目链接</a></p></blockquote><p>小豆喜欢玩游戏，现在他在玩一个游戏遇到这样的场面,每个怪的血量为 $a_i$，且每个怪物血量均不相同，小豆手里有无限张“亵渎”。亵渎的效果是对所有的怪造成 $1$ 点伤害，如果有怪死亡，则再次施放该法术。我们认为血量为 $0$ 怪物死亡。</p><p>小豆使用一张 “亵渎”会获得一定的分数，分数计算如下，在使用一张“亵渎”之后，每一个被亵渎造成伤害的怪会产生 $x^k$,其中 $x$ 是造成伤害前怪的血量为 $x$ 和需要杀死所有怪物所需的“亵渎”的张数 $k$。</p><p>$1\leq n \leq 10^{13},1\leq m \leq 50$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于一段 $[1,m]$ 的怪，显然只需要一次亵渎即可杀死所有怪物，所以我们总共需要 $k&#x3D;m+1$ 次亵渎即可杀死所有怪。</p><p>那么，只需要把怪看成一段一段的，并且用总贡献减去空的贡献即可。</p><p>$$Ans&#x3D;\sum_{i&#x3D;0}^m(\sum_{j&#x3D;1}^{n-a_i}j^k-\sum_{j&#x3D;i+1}^{m}(a_i-a_j)^k)$$</p><p>直接套拉格朗日插值板子即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=64+10,P=1e9+7;</span><br><span class="line">int T,m,k,a[N],pre[N],suf[N],ifac[N];</span><br><span class="line">LL n,y,Ans;</span><br><span class="line">I LL QP(LL A,LL B)&#123;LL S=1;W(B) B&amp;1&amp;&amp;((S*=A)%=P),(A*=A)%=P,B&gt;&gt;=1;return S;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j;ifac[0]=1;for(i=1;i&lt;=57;i++) ifac[i]=1LL*ifac[i-1]*QP(i,P-2)%P;read(T);W(T--)&#123;</span><br><span class="line">        for(read(n,m),k=m+1,Ans=0,i=1;i&lt;=m;i++) read(a[i]);for(sort(a+1,a+m+1),i=0;i&lt;=m;i++)&#123;</span><br><span class="line">            pre[0]=1;for(j=1;j&lt;=k+2;j++) pre[j]=1LL*pre[j-1]*(n-a[i]-j)%P;</span><br><span class="line">            suf[k+3]=1;for(j=k+2;j;j--) suf[j]=1LL*suf[j+1]*(n-a[i]-j)%P;</span><br><span class="line">            for(y=0,j=1;j&lt;=k+2;j++) (Ans+=1LL*((y+=QP(j,k))%=P)*pre[j-1]%P*suf[j+1]%P*ifac[j-1]%P*ifac[k+2-j]%P*(((k-j)&amp;1)?P-1:1)%P)%=P;</span><br><span class="line">            for(j=i+1;j&lt;=m;j++) (Ans+=P-QP(a[j]-a[i],k))%=P;</span><br><span class="line">        &#125;writeln((Ans+P)%P);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拉格朗日插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj3217 ALOEXT</title>
      <link href="/2021/03/21/bzoj3217-aloext/"/>
      <url>/2021/03/21/bzoj3217-aloext/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个序列，有以下 $4$ 种操作：</p><ol><li><code>I x y</code> 插入 $y$ 到第 $x$ 个之前。</li><li><code>D x</code> 删除第 $x$ 个元素。</li><li><code>C x y</code> 修改第 $x$ 个元素为 $y$。</li><li><code>F l r</code> 询问区间 $[l,r]$ 的次大值与区间一个数的异或最大值。</li></ol><p>强制在线，$1\leq N,M \leq 10^5$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这道题显然可以用替罪羊树套 Trie 解决，但是对于不会替罪羊树的选手（比如我）就可以选择块状链表+Trie。</p><p>区间次大值直接用 Multiset 维护即可，异或最大值直接在 Trie 上跑一下即可。</p><p>注意块大小因为套了个 Trie 所以要适量调大。</p><p>然后本人调了一整天，祝你好运~</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e5+10,S=5000,M=N/S+2,P=1048576;</span><br><span class="line">I int RC()&#123;char c=gc();W(c^&#x27;I&#x27;&amp;&amp;c^&#x27;D&#x27;&amp;&amp;c^&#x27;C&#x27;&amp;&amp;c^&#x27;F&#x27;) c=gc();return c==&#x27;I&#x27;?1:c==&#x27;D&#x27;?2:c==&#x27;C&#x27;?3:4;&#125;</span><br><span class="line">int n,m,tot;</span><br><span class="line">vector&lt;int&gt; b[M];</span><br><span class="line">multiset&lt;int&gt; s[M];</span><br><span class="line">#define PA pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">class TrieTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int p[S*100][2],cnt,w[S*100];</span><br><span class="line">        #define nw ((v&gt;&gt;i)&amp;1)</span><br><span class="line">    public:</span><br><span class="line">        I void clear()&#123;cnt=1;memset(p,0,sizeof(p));memset(w,0,sizeof(w));&#125;</span><br><span class="line">        I void A(CI v)&#123;RI i,u=1;for(i=20;~i;i--) !p[u][nw]&amp;&amp;(p[u][nw]=++cnt),w[p[u][nw]]++,u=p[u][nw];&#125;</span><br><span class="line">        I void K(CI v)&#123;RI i,u=1,t;for(i=20;~i;i--) w[p[u][nw]]--,u=p[u][nw];&#125;</span><br><span class="line">        I int Q(CI v)&#123;RI i,u=1,X=0;for(i=20;~i;i--) (p[u][nw^1]&amp;&amp;w[p[u][nw^1]])?X+=(1&lt;&lt;i),u=p[u][nw^1]:u=p[u][nw];return X;&#125;</span><br><span class="line">&#125;T[M];</span><br><span class="line">I void H(PA&amp; X,CI v)&#123;v&gt;X.fi?X.se=X.fi,X.fi=v:X.se=max(X.se,v);&#125;</span><br><span class="line">I PA G(CI l,CI x,CI y)&#123;PA o=MP(0,0);for(auto i=b[l].begin()+x;i!=b[l].begin()+y+1;i++) H(o,*i);return o;&#125;</span><br><span class="line">I int F(CI l,CI x,CI y,CI v)&#123;RI mx=0;for(auto i=b[l].begin()+x;i!=b[l].begin()+y+1;i++) mx=max(mx,(*i)^v);return mx;&#125;</span><br><span class="line">I int Z(CI L,CI R,CI v)&#123;RI i,mx=0;for(i=L;i&lt;=R;i++) mx=max(mx,T[i].Q(v));return mx;&#125;</span><br><span class="line">I void O(PA&amp; o,PA v)&#123;H(o,v.fi),H(o,v.se);&#125;</span><br><span class="line">I PA E(CI L,CI R)&#123;PA o=MP(0,0);RI i;for(i=L;i&lt;=R;i++)&#123;auto it=s[i].rbegin();if(it!=s[i].rend())&#123;H(o,*it);++it;if(it!=s[i].rend()) H(o,*it);&#125;&#125;return o;&#125;</span><br><span class="line">I int Q(RI l,RI r)&#123;</span><br><span class="line">    PA o=MP(0,0);RI bL=1,bR=1;W(l&gt;=b[bL].size()) l-=b[bL++].size();W(r&gt;=b[bR].size()) r-=b[bR++].size();if(bL==bR) return O(o,G(bL,l,r)),F(bL,l,r,o.se);</span><br><span class="line">    else return O(o,G(bL,l,b[bL].size()-1)),O(o,G(bR,0,r)),O(o,E(bL+1,bR-1)),max(Z(bL+1,bR-1,o.se),max(F(bL,l,b[bL].size()-1,o.se),F(bR,0,r,o.se)));</span><br><span class="line">&#125;</span><br><span class="line">I void C(CI i,CI v)&#123;s[i].erase(s[i].find(v)),T[i].K(v);&#125;</span><br><span class="line">I void J(CI i,CI v)&#123;s[i].insert(v),T[i].A(v);&#125;</span><br><span class="line">I void U(RI x,CI v)&#123;RI i,bL=1,t;W(x&gt;=b[bL].size()) x-=b[bL++].size();t=b[bL][x],C(bL,t);b[bL][x]=v,J(bL,v);&#125;</span><br><span class="line">I void A(RI x,CI v)&#123;</span><br><span class="line">    RI i,t,bL=1;W(x&gt;=b[bL].size()) x-=b[bL++].size();b[bL].insert(b[bL].begin()+x,v),J(bL,v);for(i=bL+1;i&lt;=tot;i++) if(b[i-1].size()&lt;=S) break ;</span><br><span class="line">    else t=b[i-1].back(),C(i-1,t),b[i-1].pop_back(),b[i].insert(b[i].begin(),t),J(i,t);if(b[tot].size()&gt;S) ++tot,T[tot].clear();++n;</span><br><span class="line">&#125;</span><br><span class="line">I void K(RI x)&#123;RI i,bL=1,t;W(x&gt;=b[bL].size()) x-=b[bL++].size();t=b[bL][x];b[bL].erase(b[bL].begin()+x),C(bL,t);--n;&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;I.in&quot;,&quot;r&quot;,stdin);freopen(&quot;I.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,x,l,r,p=0;for(read(n,m),tot=n/S+1,i=1;i&lt;=tot;i++) T[i].clear();for(i=0;i&lt;n;i++) read(x),b[i/S+1].push_back(x),s[i/S+1].insert(x),T[i/S+1].A(x);</span><br><span class="line">    W(m--) if((x=RC())==1) read(l,r),l=(l+p)%n,r=(r+p)%P,A(l,r);else if(x==2) read(l),l=(l+p)%n,K(l);</span><br><span class="line">    else if(x==3) read(l,r),l=(l+p)%n,r=(r+p)%P,U(l,r);else if(x==4) read(l,r),l=(l+p)%n,r=(r+p)%n,l&gt;r&amp;&amp;(swap(l,r),0),writeln(p=Q(l,r));return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie </tag>
            
            <tag> 块状链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP2839 [国家集训队]middle</title>
      <link href="/2021/03/17/luogup2839-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Fmiddle/"/>
      <url>/2021/03/17/luogup2839-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9Fmiddle/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2839">题目链接</a></p></blockquote><p>一个长度为 $n$ 的序列 $a$，设其升序排序之后为 $b$，那么序列 $a$ 的中位数定义为 $b_{\lfloor\frac{n}{2}\rfloor}$，其中 $a,b$ 从 $0$ 开始标号，除法取下整。</p><p>给你一个长度为 $n$ 的序列 $s$。回答 $Q$ 个这样的询问：$s$ 的左端点在 $[a,b]$ 之间,右端点在 $[c,d]$ 之间的子序列中，最大的中位数。</p><p>其中 $a&lt;b&lt;c&lt;d$。位置也从 $0$ 开始标号。</p><p>强制在线。</p><p>$1\leq n \leq 20000,1\leq Q\leq 25000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先对于每个询问，我们可以先二分答案。</p><p>考虑二分答案 $mid$ 如何 check。</p><p>如果我们将序列中的所有小于 $mid$ 的数字都标记为 $-1$，所有大于等于 $mid$ 的数字都标记为 $1$，那么我们只需要查询是否存在合法的一个区间内的和大于等于 $0$ 即可。</p><p>那么我们只需要先预处理建出选择所有 $mid$ 的值域线段树，这样每次相邻两个权值实际上只改变了几个位置，所以主席树即可，维护以下几个值：</p><ol><li>区间和</li><li>区间最大前缀和</li><li>区间最大后缀和</li></ol><p>那么合法的区间的最大值就是 $\max_{i&#x3D;a}^{b+1}\sum_{i}^{b}+\sum_{b+1}^{c-1}{p_i}+\max_{i&#x3D;c-1}^{d}\sum_{c}^{i}$。</p><p>用线段树维护即 $Rmax(a,b)+Sum(b+1,c-1)+Lmax(c,d)$。</p><p>所以我们只需要维护一下主席树即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=2e4,M=N+5e3;</span><br><span class="line">int n,q,t[5],rt[N];</span><br><span class="line">struct seq&#123;int v,pos;&#125;a[N];</span><br><span class="line">I bool cmp(Cn seq&amp; x,Cn seq&amp; y)&#123;return x.v&lt;y.v;&#125;</span><br><span class="line">class PresidentTree&#123;</span><br><span class="line">    private:</span><br><span class="line">        int cnt;</span><br><span class="line">        struct node&#123;int l,r,S,L,R;&#125;T[N*30];</span><br><span class="line">        #define mid (l+r&gt;&gt;1) </span><br><span class="line">        #define ls T[x].l,l,mid</span><br><span class="line">        #define rs T[x].r,mid+1,r</span><br><span class="line">        #define PU(x) (T[x].S=T[T[x].l].S+T[T[x].r].S,T[x].L=max(T[T[x].l].L,T[T[x].l].S+T[T[x].r].L),T[x].R=max(T[T[x].r].R,T[T[x].r].S+T[T[x].l].R))</span><br><span class="line">        I int QS(CI x,CI l,CI r,CI L,CI R)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].S;</span><br><span class="line">            RI S=0;return L&lt;=mid&amp;&amp;(S+=QS(ls,L,R)),R&gt;mid&amp;&amp;(S+=QS(rs,L,R)),S;</span><br><span class="line">        &#125;</span><br><span class="line">        I int QL(CI x,CI l,CI r,CI L,CI R)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].L;</span><br><span class="line">            if(R&lt;=mid) return QL(ls,L,R);else if(L&gt;mid) return QL(rs,L,R);</span><br><span class="line">            else return max(QL(ls,L,mid),QS(ls,L,mid)+QL(rs,mid+1,R));//前缀最大值</span><br><span class="line">        &#125;</span><br><span class="line">        I int QR(CI x,CI l,CI r,CI L,CI R)&#123;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return T[x].R;</span><br><span class="line">            if(R&lt;=mid) return QR(ls,L,R);else if(L&gt;mid) return QR(rs,L,R);</span><br><span class="line">            else return max(QR(rs,mid+1,R),QS(rs,mid+1,R)+QR(ls,L,mid));//后缀最大值</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">        I void B(int&amp; x,CI l,CI r)&#123;</span><br><span class="line">            x=++cnt;T[x].S=T[x].L=T[x].R=r-l+1;if(l==r) return ;</span><br><span class="line">            B(ls),B(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        I void U(CI pre,int&amp; x,CI l,CI r,CI p,CI v)&#123;</span><br><span class="line">            T[x=++cnt]=T[pre];if(l==r) return void(T[x].S=T[x].L=T[x].R=v);</span><br><span class="line">            p&lt;=mid?U(T[pre].l,ls,p,v):U(T[pre].r,rs,p,v),PU(x);</span><br><span class="line">        &#125;</span><br><span class="line">        I int check(CI k,CI a,CI b,CI c,CI d)&#123;</span><br><span class="line">            RI S=0;if(b+1&lt;=c-1) S+=QS(rt[k],1,n,b+1,c-1);//查询[b+1,c-1]的和，注意特判区间不存在的情况</span><br><span class="line">            S+=QR(rt[k],1,n,a,b)+QL(rt[k],1,n,c,d);return S&gt;=0;//如果大于等于0即合法</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,l,r,p=0;for(read(n),i=1;i&lt;=n;i++) read(a[i].v),a[i].pos=i;sort(a+1,a+n+1,cmp);</span><br><span class="line">    for(S.B(rt[1],1,n),i=2;i&lt;=n+1;i++) S.U(rt[i-1],rt[i],1,n,a[i-1].pos,-1);for(read(q),i=1;i&lt;=q;i++)&#123;//预处理，建树</span><br><span class="line">        for(j=0;j&lt;4;j++) read(t[j]),t[j]+=p,t[j]%=n,t[j]++;</span><br><span class="line">        sort(t,t+4);l=0,r=n;W(l&lt;=r) S.check(mid,t[0],t[1],t[2],t[3])?(p=mid,l=mid+1):r=mid-1;writeln(p=a[p].v);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈莫队</title>
      <link href="/2021/03/09/%E6%B5%85%E8%B0%88%E8%8E%AB%E9%98%9F/"/>
      <url>/2021/03/09/%E6%B5%85%E8%B0%88%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>莫队算法是由莫涛提出的算法。在莫涛提出莫队算法之前，莫队算法已经在 Codeforces 的高手圈里小范围流传，但是莫涛是第一个对莫队算法进行详细归纳总结的人。莫涛提出莫队算法时，只分析了普通莫队算法，但是经过 OIer 和 ACMer 的集体智慧改造，莫队有了多种扩展版本。</p><p>莫队算法可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。</p><p>-- OI wiki</p></blockquote><h2 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h2><h3 id="引例：区间不同数"><a href="#引例：区间不同数" class="headerlink" title="引例：区间不同数"></a>引例：区间不同数</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>有一个长度为 $n$ 的序列，有 $m$ 次询问，每次询问某个区间内出现过的数值种类数。</p><p>$1\leq n \leq 5\times 10^4,1\leq m \leq 2\times 10^5,0\leq a_i \leq 10^6$</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>首先考虑暴力，如果对于每一个询问，直接暴力枚举区间每个数，开个桶统计每个数字是否出现过，显然这种做法会超时，复杂度为 $O(NM)$。</p><p>这时候就要用到莫队算法了。</p><p>那么莫队是什么呢？</p><p>其实就是<strong>优雅的暴力</strong>。</p><p>我们现在可以思考一个问题，如果你已经得知区间 $[l,r]$ 的答案，那么如何求区间 $[l,r+1]$ 的答案呢？</p><p>显然区间 $[l,r+1]$ 只比 $[l,r]$ 多了元素 $a[r]$，那么我们只需要判断 $a[r]$ 对答案是否有贡献即可。</p><p>那么什么时候 $a[r]$ 对答案有贡献呢？</p><p>显然只有当区间 $[l,r]$ 中 $a[r]$ 的出现次数为 $0$。</p><p>那么事情就很好办了，我们只需要开一个 $cnt$ 数组统计每个数字目前出现的次数，每次对答案造成贡献的条件是 $cnt[a[r]]&#x3D;&#x3D;0$。</p><p>同理，我们如果知道了区间 $[l,r]$ 的答案，我们就可以知道 $[l-1,r],[l+1,r],[l,r-1]$ 的答案。</p><p>而且这个复杂度是 $O(1)$ 的，那么处理下一个询问的复杂度就是 $O(r_i-r_{i-1}+l_i-l_{i-1})$ 的。</p><p>这样的复杂度在随机数据中表现很好，但是<strong>毒瘤的出题人</strong>也不难卡你。</p><p>那么此时就需要莫队优化的精髓来减小复杂度了。</p><p>我们考虑进行分块，不妨设块大小为 $\sqrt{N}$，把每个点分入一个块内，然后将所有询问按照<strong>左端点所在块为第一关键字排序，右端点的序号为第二关键字排序</strong>。</p><p>下面我们来解释下为什么要这么做：</p><ol><li>所在块相同时，右端点递增是 $O(N)$ 的，块共有个 $O(\sqrt{N})$，复杂度为 $O(N^{1.5})$</li><li>分块转移时，右端点最多变化 $N$，块共有 $O(\sqrt{N})$ 个，复杂度为 $O(N^{1.5})$</li><li>块相同时，左端点最多变化 $\sqrt{N}$，块转移时，左端点最多变化 $2\sqrt{N}$，共有 $N$ 个询问，复杂度为 $O(N^{1.5})$</li></ol><p>所以总时间复杂度为 $O(N^{1.5})$。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=5e4+10,M=2e5+10,C=1e6+10;</span><br><span class="line">int n,m,S,a[N],bl[N],cnt[C],Ans,ans[M],tot,l,r;</span><br><span class="line">struct Que&#123;int l,r,id;&#125;q[M];</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?x.r&lt;y.r:x.l&lt;y.l;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n),S=sqrt(n),i=1;i&lt;=n;i++) read(a[i]);for(read(m),i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!((i-1)%S)) bl[i]=++tot;else bl[i]=tot;for(sort(q+1,q+m+1,cmp),l=1,r=0,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        W(l&lt;q[i].l) !(--cnt[a[l++]])&amp;&amp;Ans--;</span><br><span class="line">        W(l&gt;q[i].l) !(cnt[a[--l]]++)&amp;&amp;Ans++;</span><br><span class="line">        W(r&lt;q[i].r) !(cnt[a[++r]]++)&amp;&amp;Ans++;</span><br><span class="line">        W(r&gt;q[i].r) !(--cnt[a[r--]])&amp;&amp;Ans--;</span><br><span class="line">        ans[q[i].id]=Ans;</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) writeln(ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫队的劣处"><a href="#莫队的劣处" class="headerlink" title="莫队的劣处"></a>莫队的劣处</h3><p>不难发现，莫队只支持离线区间询问，对于在线问题，我们并不能采用莫队来解决。</p><p>并且使用莫队需要一些卡常技巧，才能战胜出题人。</p><h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><p>一般的莫队是不支持修改的，但是如果我们稍微修改一下，就可以让莫队资瓷修改啦~</p><p>就像 DP 一样，可以强行加上一维<strong>时间维</strong>, 表示这次操作的时间。</p><p>时间维表示经历的修改次数。</p><p>即把询问 $[l,r]$ 变成 $[l,r,time]$。</p><p>那么我们的坐标也可以在时间维上移动，即 $[l,r,time]$ 多了一维可以移动的方向。</p><p>这样的转移也是 $O(1)$ 的，但是我们排序又多了一个关键字，再搞搞就行了。</p><p>可以用和普通莫队类似的方法排序转移，做到 $O(N^{\frac{5}{3}})$。</p><p>这一次我们排序的方式是以 $N^{\frac{2}{3}}$ 为一块，分成了 $N^{\frac{1}{3}}$ 块，第一关键字是左端点所在块，第二关键字是右端点所在块，第三关键字是时间。</p><p>还是来证明一下时间复杂度：</p><ul><li>左右端点所在块不变，时间在排序后单调向右移，这样的复杂度是 $O(N)$；</li><li>若左右端点所在块改变，时间一次最多会移动 $N$ 个格子，时间复杂度 $O(N)$；</li><li>左端点所在块一共有 $N^{\frac{1}{3}}$ 中，右端点也是 $N^{\frac{1}{3}}$ 种，一共 $N^{\frac{1}{3}}$ 种，每种乘上移动的复杂度 $O(N)$，总复杂度 $O(N^{\frac{5}{3}})$。</li></ul><h3 id="例题：LuoguP1903-国家集训队-数颜色-x2F-维护队列"><a href="#例题：LuoguP1903-国家集训队-数颜色-x2F-维护队列" class="headerlink" title="例题：LuoguP1903 [国家集训队]数颜色 &#x2F; 维护队列"></a>例题：<a href="https://www.luogu.com.cn/problem/P1903">LuoguP1903 [国家集训队]数颜色 &#x2F; 维护队列</a></h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>有一个长度为 $n$ 的序列，要支持 $m$ 次询问或修改。</p><p>题目需要你进行的操作有：</p><ol><li><code>Q l r</code> 表示询问 $[l,r]$ 中出现过的数值种类数。</li><li><code>R p col</code> 表示把第 $p$ 个数替换成颜色 $col$。</li></ol><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>带修莫队模板</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e4+10,M=1e6+10;</span><br><span class="line">int n,m,S,a[N],l,r,t,cnt[M],bl[N],tot,Ans,ans[N],cntp,cntq,lst[M];</span><br><span class="line">struct Que&#123;int l,r,lst,t;&#125;p[N],q[N];</span><br><span class="line">I int RC()&#123;char c=gc();W(c^&#x27;Q&#x27;&amp;&amp;c^&#x27;R&#x27;) c=gc();return c^&#x27;Q&#x27;;&#125;</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?x.l&lt;y.l:bl[x.r]^bl[y.r]?x.r&lt;y.r:x.t&lt;y.t;&#125;</span><br><span class="line">I void Upd(CI x,CI col)&#123;l&lt;=p[x].l&amp;&amp;p[x].l&lt;=r&amp;&amp;(!(--cnt[a[p[x].l]])&amp;&amp;Ans--,!(cnt[col]++)&amp;&amp;Ans++),a[p[x].l]=col;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;for(read(n,m),i=1;i&lt;=n;i++) read(a[i]),lst[i]=a[i];for(i=1;i&lt;=m;i++)</span><br><span class="line">    RC()?(p[++cntp].t=cntq,read(p[cntp].l,p[cntp].r),p[cntp].lst=lst[p[cntp].l],lst[p[cntp].l]=p[cntp].r,0)</span><br><span class="line">    :(q[++cntq].t=cntp,read(q[cntq].l,q[cntq].r),q[cntq].lst=cntq,0);</span><br><span class="line">    for(S=pow(n,2.0/3),i=1;i&lt;=n;i++) bl[i]=!((i-1)%S)?++tot:tot;for(sort(q+1,q+cntq+1,cmp),t=-1,r=0,l=i=1;i&lt;=cntq;i++)&#123;</span><br><span class="line">        W(t&lt;q[i].t) ++t,Upd(t,p[t].r);W(t&gt;q[i].t) Upd(t,p[t].lst),t--;</span><br><span class="line">        W(l&lt;q[i].l) !(--cnt[a[l++]])&amp;&amp;Ans--;W(l&gt;q[i].l) !(cnt[a[--l]]++)&amp;&amp;Ans++;</span><br><span class="line">        W(r&lt;q[i].r) !(cnt[a[++r]]++)&amp;&amp;Ans++;W(r&gt;q[i].r) !(--cnt[a[r--]])&amp;&amp;Ans--;</span><br><span class="line">        ans[q[i].lst]=Ans;</span><br><span class="line">    &#125;for(i=1;i&lt;=cntq;i++) writeln(ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><p>直接类似于树分块，直接在 $Dfs$ 时，如果子树大小超过块大小就直接合成一个块即可。</p><p>其他操作类似于普通莫队。</p><p>显然，如果直接这样操作肯定是不行的。</p><p>因为两个端点还是需要计数的。</p><p>容易想到，只有 $LCA$ 才可能重复，所以每次不标记 $LCA$，询问答案时再标记，最后撤销即可。</p><h3 id="例题：LuoguP4074-WC2013-糖果公园"><a href="#例题：LuoguP4074-WC2013-糖果公园" class="headerlink" title="例题：LuoguP4074 [WC2013] 糖果公园"></a>例题：<a href="https://www.luogu.com.cn/problem/P4074">LuoguP4074 [WC2013] 糖果公园</a></h3><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">//#define D isdigit(c=gc())</span><br><span class="line">//#define pc(c) putchar((c))</span><br><span class="line">//#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">//#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    #define FS 100000</span><br><span class="line">    #define tc() (FA==FB&amp;&amp;(FB=(FA=FI)+fread(FI,1,FS,stdin),FA==FB)?EOF:*FA++)</span><br><span class="line">    #define pc(c) (FC==FE&amp;&amp;(clear(),0),*FC++=c)</span><br><span class="line">    int T;char c,FI[FS],FO[FS],OS[FS],*FA=FI,*FB=FI,*FC=FO,*FE=FO+FS;</span><br><span class="line">    I void clear() &#123;fwrite(FO,1,FC-FO,stdout),FC=FO;&#125;</span><br><span class="line">    Tp I void read(Ty&amp; x) &#123;x=0;W(!isdigit(c=tc()));W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),isdigit(c=tc()));&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y) &#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void writeln(Ty x) &#123;W(OS[++T]=x%10+48,x/=10);W(T) pc(OS[T--]);pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e6+10;</span><br><span class="line">int n,m,q,S,a[N],w[N],col[N],lst[N],fir[N],nxt[N&lt;&lt;1],son[N&lt;&lt;1],tot,cnt,cts,dep[N],dfn[N],bl[N],stk[N],tp,f[N],cnte,cntp,t,vis[N],tim[N],lca,mx[N],top[N],sz[N];</span><br><span class="line">LL Ans,ans[N];</span><br><span class="line">struct Edit&#123;int lst,x,y;&#125;e[N];</span><br><span class="line">struct Que&#123;int l,r,t,id;&#125;p[N];</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?bl[x.l]&lt;bl[y.l]:bl[x.r]^bl[y.r]?bl[x.r]&lt;bl[y.r]:x.t&lt;y.t;&#125;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I int Dfs(CI x,CI fa)&#123;</span><br><span class="line">    RI i,sum=0;for(sz[x]=1,dep[x]=dep[f[x]=fa]+1,dfn[x]=++cnt,i=fir[x];i;i=nxt[i])</span><br><span class="line">    if(to^fa&amp;&amp;(sum+=Dfs(to,x),sz[x]+=sz[to],sz[to]&gt;sz[mx[x]]&amp;&amp;(mx[x]=to,0),sum&gt;=S))&#123;</span><br><span class="line">        ++cts;W(sum--) bl[stk[tp--]]=cts;</span><br><span class="line">    &#125;return stk[++tp]=x,sum+1;</span><br><span class="line">&#125;</span><br><span class="line">I void Dfs2(CI x,CI Top)&#123;</span><br><span class="line">    RI i;if(top[x]=Top,mx[x]) Dfs2(mx[x],Top);</span><br><span class="line">    for(i=fir[x];i;i=nxt[i]) to^f[x]&amp;&amp;mx[x]^to&amp;&amp;(Dfs2(to,to),0);</span><br><span class="line">&#125;</span><br><span class="line">I int Lca(RI x,RI y)&#123;</span><br><span class="line">    W(top[x]^top[y]) dep[top[x]]&lt;dep[top[y]]&amp;&amp;(swap(x,y),0),x=f[top[x]];</span><br><span class="line">    return dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line">I int PU(RI x)&#123;return (vis[x]?Ans-=1LL*w[tim[col[x]]--]*a[col[x]]:Ans+=1LL*w[++tim[col[x]]]*a[col[x]]),vis[x]^=1,0;&#125;</span><br><span class="line">I void Upd(CI x,CI v)&#123;vis[x]?(PU(x),col[x]=v,PU(x)):col[x]=v;&#125;</span><br><span class="line">I void Chg(RI x,RI y)&#123;W(x^y) dep[x]&lt;dep[y]&amp;&amp;(swap(x,y),0),PU(x),x=f[x];&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,x,y;for(read(n,m,q),S=pow(n,0.60),i=1;i&lt;=m;i++) read(a[i]);for(i=1;i&lt;=n;i++) read(w[i]);for(i=1;i&lt;n;i++) read(x,y),Add(x,y),Add(y,x);</span><br><span class="line">    for(i=1;i&lt;=n;i++) read(col[i]),lst[i]=col[i];Dfs(1,0),Dfs2(1,1);if(top)&#123;++cts;W(tp) bl[stk[tp--]]=cts;&#125;for(i=1;i&lt;=q;i++)</span><br><span class="line">    if(read(j,x,y),!j) e[++cnte]=(Edit)&#123;lst[x],x,y&#125;,lst[x]=y;else dfn[x]&gt;dfn[y]&amp;&amp;(swap(x,y),0),p[++cntp]=(Que)&#123;x,y,cnte,cntp&#125;;</span><br><span class="line">    for(sort(p+1,p+cntp+1,cmp),i=1;i&lt;=(t=p[1].t);i++) Upd(e[i].x,e[i].y);</span><br><span class="line">    for(Chg(p[1].l,p[1].r),PU(lca=Lca(p[1].l,p[1].r)),ans[p[1].id]=Ans,PU(lca),i=2;i&lt;=cntp;i++)&#123;</span><br><span class="line">        W(t&lt;p[i].t) ++t,Upd(e[t].x,e[t].y);W(t&gt;p[i].t) Upd(e[t].x,e[t].lst),t--;</span><br><span class="line">        Chg(p[i-1].l,p[i].l),Chg(p[i-1].r,p[i].r),PU(lca=Lca(p[i].l,p[i].r)),ans[p[i].id]=Ans,PU(lca);</span><br><span class="line">    &#125;for(i=1;i&lt;=cntp;i++) writeln(ans[i]);return clear(),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2><h3 id="例题：AT1219-歴史の研究"><a href="#例题：AT1219-歴史の研究" class="headerlink" title="例题：AT1219 歴史の研究"></a>例题：<a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></h3><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>回滚莫队类似于普通莫队进行排序。</p><p>查询直接枚举每一个块，而该块所有右端点都是单调递增的，而左端点都在同一个块内移动，从而计算每个询问的值。</p><p>每次到下个块的左端点直接全部清空即可。</p><h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,m,sz,bl[N],tot,cnt[N],lsh[N],a[N];</span><br><span class="line">LL Ans,ans[N],lst=0;</span><br><span class="line">struct Que&#123;int l,r,id;&#125;q[N];</span><br><span class="line">I bool cmp(Cn Que&amp; x,Cn Que&amp; y)&#123;return bl[x.l]^bl[y.l]?bl[x.l]&lt;bl[y.l]:x.r&lt;y.r;&#125;</span><br><span class="line">I void Add(RI x,CI v)&#123;cnt[a[x]]+=v,Ans=max(Ans,1LL*cnt[a[x]]*lsh[a[x]]);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;H.in&quot;,&quot;r&quot;,stdin);freopen(&quot;H.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    RI i,j,l,r;for(read(n,m),sz=sqrt(n),i=1;i&lt;=n;i++) read(a[i]),lsh[i]=a[i],bl[i]=(i-1)/sz+1;for(i=1;i&lt;=m;i++) read(q[i].l,q[i].r),q[i].id=i;</span><br><span class="line">    for(sort(lsh+1,lsh+n+1),tot=unique(lsh+1,lsh+n+1)-lsh-1,i=1;i&lt;=n;i++) a[i]=lower_bound(lsh+1,lsh+tot+1,a[i])-lsh;</span><br><span class="line">    for(sort(q+1,q+m+1,cmp),l=i=1,r=0;i&lt;=m;i++)&#123;</span><br><span class="line">        if(l=min(n,sz*bl[q[i].l]),bl[q[i].l]^bl[q[i-1].l]) lst=Ans=0,r=l-1,memset(cnt,0,sizeof(cnt));//每次从块的最右端出发</span><br><span class="line">        Ans=lst;W(r&gt;q[i].r) Add(r--,-1);W(r&lt;q[i].r) Add(++r,1);</span><br><span class="line">        lst=Ans;W(l&gt;q[i].l) Add(--l,1);ans[q[i].id]=Ans;</span><br><span class="line">        for(j=min(n,sz*bl[q[i].l])-1;j&gt;=l;j--) cnt[a[j]]--;</span><br><span class="line">    &#125;for(i=1;i&lt;=m;i++) writeln(ans[i]);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3209 [HNOI2010] 平面图判定</title>
      <link href="/2021/03/01/luogup3209-hnoi2010-%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%88%A4%E5%AE%9A/"/>
      <url>/2021/03/01/luogup3209-hnoi2010-%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%88%A4%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图是否是平面图，图中存在一个包含所有顶点的环，即存在哈密顿回路。</p><p>对于一个无向图 $G&#x3D;(V,E)$，如果能够做到把它画在同一个平面上，使得 $\forall (a,b)(c,d)$，$a,b,c,d$ 两两不等的情况下，边 $(a,b)$ 和边 $(c,d)$ 没有交点，则称 $G$ 是平面图。</p><p>哈密顿回路指的是：在一个有 $n$ 个点的图中，一条从点 $x$ 出发，最后回到点 $x$，并且除点 $x$ 外所有点都只出现一次，总长度为 $n$ 的路径。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单给出平面图的定义：无向图画在同一个平面上，任意两边没有交点。</p><p>对于每一条边，只有两种情况：</p><ol><li>在哈密顿回路上，那么这条边无需其他判断。</li><li>在哈密顿回路外&#x2F;里，那么这条边有两种选择：要么在外部，要么在里面。</li></ol><p>由于第二种情况的两种选择，以及平面图的限制，这就转化为了个经典的 2-SAT 问题。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/pic/image-20210301204343887.png" alt="image-20210301204343887"></p><p>显然如果边 $(x,y)$ 与边 $(u,v)$ 都在环内时，这个图就不是平面图。</p><p>那么我们只要顺次枚举两条边，判断是否有限制即可。</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;=p;i++) for(j=i+1;j&lt;=p;j++)&#123;//枚举两条边</span><br><span class="line">    u=rk[e[i].x],v=rk[e[i].y],x=rk[e[j].x],y=rk[e[j].y];//rk表示点在哈密顿回路上的序号</span><br><span class="line">    if(u&gt;v) swap(u,v);if(x&gt;y) swap(x,y);</span><br><span class="line">    if((u&lt;x&amp;&amp;v&gt;x&amp;&amp;v&lt;y)(u&gt;x&amp;&amp;u&lt;y&amp;&amp;v&gt;y)) Add(i,j+p),Add(i+p,j),Add(j,i+p),Add(j+p,i);//判断是否有限制，并建图</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而发现这种方法的建图复杂度会高达 $O(M^2)$，对于 $1\leq M\leq 10^4$ 的本题是完全不能通过的。</p><p>那么接下来就要利用到平面图的一个重要性质：$m\leq 3n+6$。</p><p>具体性质的证明，楼上楼下都解释得很清楚了，这里就不再赘述。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=210,M=10010,P=3*N+6;</span><br><span class="line">int T,n,m,p,C[N],G[N][N],fir[P&lt;&lt;1],nxt[P*P&lt;&lt;2],son[P*P&lt;&lt;2],tot,dfn[P&lt;&lt;1],low[P&lt;&lt;1],stk[P&lt;&lt;1],col[P&lt;&lt;1],cnt,top,cc,rk[N];</span><br><span class="line">struct Edge&#123;int x,y;&#125;e[P],E[M];</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Tarjan(CI x)&#123;</span><br><span class="line">    dfn[x]=low[x]=++cnt,stk[++top]=x;RI i;</span><br><span class="line">    for(i=fir[x];i;i=nxt[i]) if(!dfn[to]) Tarjan(to),low[x]=min(low[x],low[to]);else if(!col[to]) low[x]=min(low[x],dfn[to]);</span><br><span class="line">    if(dfn[x]==low[x])&#123;col[x]=++cc;W(stk[top]^x) col[stk[top--]]=cc;top--;&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,u,v,x,y,flg;read(T);W(T--)&#123;</span><br><span class="line">        for(memset(G,0,sizeof(G)),memset(dfn,0,sizeof(dfn)),read(n,m),i=1;i&lt;=m;i++) read(E[i].x,E[i].y),E[i].x&gt;E[i].y&amp;&amp;(swap(E[i].x,E[i].y),0);//所有边按照编号小连向编号大，便于去掉哈密顿回路上的边</span><br><span class="line">        for(i=1;i&lt;=n;i++) read(C[i]),rk[C[i]]=i,i&gt;1&amp;&amp;(G[min(C[i-1],C[i-1])][max(C[i-1],C[i])]=1,0);G[min(C[1],C[n])][max(C[1],C[n])]=1;//哈密顿回路上的边打上标记</span><br><span class="line">        if(m&gt;3*n+6)&#123;puts(&quot;NO&quot;);continue ;&#125;//利用平面图的性质</span><br><span class="line">        for(memset(col,0,sizeof(col)),flg=cnt=top=cc=p=0,i=1;i&lt;=m;i++) if(!G[E[i].x][E[i].y]) e[++p]=E[i];</span><br><span class="line">        for(memset(fir,0,sizeof(fir)),tot=0,i=1;i&lt;=p;i++) for(j=i+1;j&lt;=p;j++)&#123;</span><br><span class="line">            u=rk[e[i].x],v=rk[e[i].y],x=rk[e[j].x],y=rk[e[j].y];</span><br><span class="line">            if(u&gt;v) swap(u,v);if(x&gt;y) swap(x,y);</span><br><span class="line">            if((u&lt;x&amp;&amp;v&gt;x&amp;&amp;v&lt;y)(u&gt;x&amp;&amp;u&lt;y&amp;&amp;v&gt;y)) Add(i,j+p),Add(i+p,j),Add(j,i+p),Add(j+p,i);//建图</span><br><span class="line">        &#125;for(i=1;i&lt;=(p&lt;&lt;1);i++) if(!dfn[i]) Tarjan(i);for(i=1;i&lt;=p;i++) if(col[i]==col[i+p])&#123;puts(&quot;NO&quot;);flg=1;break ;&#125;if(!flg) puts(&quot;YES&quot;);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3007 [USACO11JAN] The Continental Cowngress G</title>
      <link href="/2021/03/01/luogup3007-usaco11jan-the-continental-cowngress-g/"/>
      <url>/2021/03/01/luogup3007-usaco11jan-the-continental-cowngress-g/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给出 $n$ 个法案，$m$ 头牛的意见， 每头牛会表决两次。<br>每次表决格式为 <code>i Y</code> 表示“支持 $i$ 号法案”或 <code>i N</code> 表示“反对 $i$ 号法案”。<br>最终，每头牛至少要有一个表决被满足。不可能成立的话输出 <code>IMPOSSIBLE</code>，否则输出方案。</p><p>$1\leq N \leq 1,000,1\leq M \leq 4,000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然是 $2-SAT$。</p><p>对于每头牛的表决，只要根据“若某个表决是错误的，那么另一个表决一定是对的“条件来建图即可。</p><p>然后判断一下是否合法（只要每个法案的两种状态均不在同一个连通块即可）</p><p>最后对于每个法案，暴力枚举该法案是否成立，然后跑一次 $DFS$ 判断下是否有矛盾即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1010,M=4010;</span><br><span class="line">int n,m,fir[N&lt;&lt;1],nxt[M&lt;&lt;1],son[M&lt;&lt;1],tot,dfn[N&lt;&lt;1],low[N&lt;&lt;1],stk[N&lt;&lt;1],col[N&lt;&lt;1],top,cnt,cc,vis[N&lt;&lt;1];</span><br><span class="line">I int opp(CI x)&#123;return x&gt;n?x-n:x+n;&#125;</span><br><span class="line">I void Add(CI x,CI y)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Tarjan(CI x)&#123;</span><br><span class="line">    dfn[x]=low[x]=++cnt,stk[++top]=x;</span><br><span class="line">    RI i;for(i=fir[x];i;i=nxt[i]) if(!dfn[to]) Tarjan(to),low[x]=min(low[x],low[to]);else if(!col[to]) low[x]=min(low[x],dfn[to]);</span><br><span class="line">    if(dfn[x]==low[x])&#123;col[x]=++cc;W(stk[top]^x) col[stk[top--]]=cc;top--;&#125;</span><br><span class="line">&#125;</span><br><span class="line">I void dfs(CI x)&#123;</span><br><span class="line">    if(vis[x]) return ;</span><br><span class="line">    vis[x]=1;RI i;for(i=fir[x];i;i=nxt[i]) if(!vis[to]) dfs(to);</span><br><span class="line">&#125;</span><br><span class="line">I int check(CI x)&#123;</span><br><span class="line">    RI i;memset(vis,0,sizeof(vis));dfs(x);for(i=1;i&lt;=n;i++) if(vis[i]&amp;&amp;vis[i+n]) return 0;return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,x,y;char a,b;for(read(n,m),i=1;i&lt;=m;i++) scanf(&quot;%d %c %d %c&quot;,&amp;x,&amp;a,&amp;y,&amp;b),x+=(a==&#x27;Y&#x27;)*n,y+=(b==&#x27;Y&#x27;)*n,Add(x,opp(y)),Add(y,opp(x));</span><br><span class="line">    for(i=1;i&lt;=(n&lt;&lt;1);i++) if(!dfn[i]) Tarjan(i);for(i=1;i&lt;=n;i++) if(col[i]==col[i+n]) return puts(&quot;IMPOSSIBLE&quot;),0;</span><br><span class="line">    for(i=1;i&lt;=n;i++) x=check(i),y=check(i+n),(x&amp;&amp;y)?(pc(&#x27;?&#x27;),0):x?(pc(&#x27;Y&#x27;),0):(pc(&#x27;N&#x27;),0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Manacher</title>
      <link href="/2021/02/27/%E6%B5%85%E8%B0%88-manacher/"/>
      <url>/2021/02/27/%E6%B5%85%E8%B0%88-manacher/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>回文子串</strong>：字符串中反转后与反转前相同的子串。</p><p><strong>最长回文子串</strong>：字符串中长度最大的回文子串。</p><p><strong>第 $i$ 位回文半径</strong>：以字符串第 $i$ 位为中心的回文子串的最大长度的一半。</p><p>在处理回文子串的问题时，一般需要求出字符串每一位的回文半径。</p><p>为了避免奇偶讨论和边界问题，我们可以在每一位字符两侧添加同一个特殊字符，在字符串的首尾各添加一个不同的特殊字符，如将 <code>abbabcba</code> 变为 <code>$#a#b#b#a#b#c#b#a#@</code>。</p><h2 id="Manacher-算法流程"><a href="#Manacher-算法流程" class="headerlink" title="Manacher 算法流程"></a>Manacher 算法流程</h2><p>在 Manacher 算法中，我们需要添加两个辅助变量 $mx$ 和 $p$，分别表示已有的回文半径覆盖到的最右边界（边界不含）和该回文子串的中心位置，显然有 $mx&#x3D;p+R[p]$。（$R_i$ 表示第 $i$ 位的回文半径）</p><p>计算 $R_i$ 时，我们可以先给它定一个下界，这样可以节省时间复杂度。</p><p>令 $j&#x3D;2p-i$，分以下三种情况讨论：</p><ol><li>$mx\leq i$，向右覆盖最远的回文串没有覆盖到 $i$ 位置，而因为恒有 $R_i\ge 1$，所以 $R_i$ 的下界为 $1$。</li><li>$mx-i&gt;R_j$，以第 $j$ 位为中心的回文子串包含于以第 $p$ 位为中心的回文子串，由于 $i$ 和 $j$ 关于 $p$ 对称，那么以第 $i$ 位为中心的回文子串必也包含于以第 $p$ 位为中心的回文子串，故有 $R_i&#x3D;R_j$。</li><li>$mx-i\leq R_j$，以第 $j$ 位为中心的回文子串不一定包含于以第 $p$ 位为中心的回文子串，但由对称可知，$R_i\ge mx-i$。</li></ol><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/pic/Snipaste_2021-02-27_20-57-23.png" alt="Snipaste_2021-02-27_20-57-23"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>例题：不交回文串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">char s[N&lt;&lt;1],str[N];</span><br><span class="line">LL pre[N&lt;&lt;1],suf[N&lt;&lt;1],sum[N&lt;&lt;1];</span><br><span class="line">int len,p[N&lt;&lt;2],L;</span><br><span class="line">I void init()&#123;</span><br><span class="line">    RI i;for(s[0]=&#x27;$&#x27;,s[1]=&#x27;#&#x27;,L=2,i=0;i&lt;len;i++) s[L++]=str[i],s[L++]=&#x27;#&#x27;;s[L]=&#x27;\0&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">I void Manacher()&#123;</span><br><span class="line">    RI mx=0,id=0,i;for(init(),i=1;i&lt;L;i++)&#123;</span><br><span class="line">        if(i&lt;mx) p[i]=min(p[2*id-i],mx-i);</span><br><span class="line">        else p[i]=1;</span><br><span class="line">//        p[i]=min(mx-i,p[id*2-i]);</span><br><span class="line">        W(s[i-p[i]]==s[i+p[i]]) p[i]++;</span><br><span class="line">        if(mx&lt;i+p[i]) id=i,mx=i+p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i;W(~scanf(&quot;%s&quot;,&amp;str))&#123;</span><br><span class="line">        len=strlen(str);for(i=0;i&lt;=len;i++) suf[i]=pre[i]=sum[i]=0;</span><br><span class="line">        for(Manacher(),i=2;i&lt;=len*2;i++) suf[(i+1)/2]++,suf[(i+1)/2+p[i]/2]--;</span><br><span class="line">        for(i=len*2;i&gt;=2;i--) pre[i/2]++,pre[i/2-p[i]/2]--;</span><br><span class="line">        for(i=len;i&gt;=1;i--) pre[i]+=pre[i+1];</span><br><span class="line">        for(i=1;i&lt;=len;i++) suf[i]+=suf[i-1],sum[i]=sum[i-1]+suf[i];</span><br><span class="line">        LL Ans=0;for(i=1;i&lt;=len;i++) Ans+=(LL)pre[i]*sum[i-1];</span><br><span class="line">        writeln(Ans);</span><br><span class="line">    &#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YbtOJ 维护集合 题解</title>
      <link href="/2021/02/26/ybtoj-%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/26/ybtoj-%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>你需要维护一个可重集，初始集合为空，支持 $4$ 种操作：</p><ul><li><code>I k</code> 向集合内插入元素 $k$。</li><li><code>A k</code> 将集合内所有元素加上 $k$。</li><li><code>S k</code> 将集合内所有元素减去 $k$。</li><li><code>F k</code> 查询集合内第 $k$ 大。</li></ul><p>你需要进行 $n$ 次操作。</p><p>一开始给出一个下界 $Minv$，表示集合内的所有元素都必须大于等于 $Minv$，在任何时刻，小于 $Minv$ 的所有元素会被立刻删除。</p><p>最后还要输出被删除的元素个数。</p><p>$1\leq n \leq 3\times 10^5,0\leq Minv\leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑用 fhq Treap 维护该可重集。</p><p>对于操作一，只需要直接插入即可。</p><p>对于操作二、三，由于是对当前集合内所有元素统一操作，所以考虑记录一个全局变量 $Sum$，表示当前集合内所有元素实际大小应该加上 $Sum$。</p><p>那么每次操作一需要注意插入的值要减去 $Sum$。</p><p>查询第 $k$ 大还是基本操作，只是最后要加上 $Sum$。</p><p>注意与 $Minv$ 的判断即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1e5+10;</span><br><span class="line">int n,Minv,Sum,root,tot,x,y,Ans;</span><br><span class="line">struct node&#123;int ch[2],sz,val,rand_val;&#125;tr[N];</span><br><span class="line">I int New_Node(CI v)&#123;return tr[++tot]=(node)&#123;&#123;0,0&#125;,1,v,rand()&#125;,tot;&#125;</span><br><span class="line">#define PU(x) (tr[x].sz=tr[tr[x].ch[0]].sz+tr[tr[x].ch[1]].sz+1)</span><br><span class="line">int Merge(int x,int y)&#123;</span><br><span class="line">    if(!x!y) return x+y;</span><br><span class="line">    if(tr[x].rand_val&lt;tr[y].rand_val)&#123;</span><br><span class="line">        tr[x].ch[1]=Merge(tr[x].ch[1],y);</span><br><span class="line">        PU(x);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        tr[y].ch[0]=Merge(x,tr[y].ch[0]);</span><br><span class="line">        PU(y);</span><br><span class="line">        return y;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Split(int now,int k,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(!now) x=y=0;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(tr[now].val&lt;=k) x=now,Split(tr[now].ch[1],k,tr[now].ch[1],y);</span><br><span class="line">        else y=now,Split(tr[now].ch[0],k,x,tr[now].ch[0]);</span><br><span class="line">        PU(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Rank(int now,int k)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if(k&lt;=tr[tr[now].ch[0]].sz) now=tr[now].ch[0];</span><br><span class="line">        else&#123;</span><br><span class="line">            if(k==tr[tr[now].ch[0]].sz+1) return now;</span><br><span class="line">            else&#123;</span><br><span class="line">                k-=tr[tr[now].ch[0]].sz+1;</span><br><span class="line">                now=tr[now].ch[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,a;for(read(n,Minv),i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        string str;cin&gt;&gt;str;if(read(a),str==&quot;I&quot;)  a&gt;=Minv&amp;&amp;(Split(root,a-Sum,x,y),root=Merge(Merge(x,New_Node(a-Sum)),y),0);</span><br><span class="line">        else if(str==&quot;A&quot;) Sum+=a;else if(str==&quot;S&quot;) Sum-=a,Split(root,Minv-Sum-1,x,y),root=y,Ans+=tr[x].sz;</span><br><span class="line">        else if(str==&quot;F&quot;) writeln(tr[root].sz&lt;a?-1:tr[Rank(root,tr[root].sz-a+1)].val+Sum);</span><br><span class="line">    &#125;return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF724G Xor-matic Number of the Graph 题解</title>
      <link href="/2021/02/24/cf724g-xor-matic-number-of-the-graph-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/24/cf724g-xor-matic-number-of-the-graph-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://codeforces.com/problemset/problem/724/G">题目链接</a></p></blockquote><p>给你一个无向图，有 $n$ 个顶点和 $m$ 条边，每条边上都有一个非负权值。</p><p>我们称一个三元组 $(u,v,s)$ 是有趣的，当且仅当对于 $u,v\in [1,n]$，有一条从 $u$ 到 $v$ 的路径(可以经过相同的点和边多次)，其路径上的权值异或和为 $s$。对于一条路径，如果一条边经过了多次，则计算异或和时也应计算多次。不难证明，这样的三元组是有限的。</p><p>计算所有有趣的三元组中 $s$ 的和对于 $10^9+7$ 的模数</p><p>$1\leq n \leq 10^5,1\leq m \leq 2\times 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于所有的环，先把所有路径的异或和建一个线性基 $P$，那么点 $u$ 到点 $v$ 的路径和就是 $d_u\oplus d_v \oplus P$，其中 $d_x$ 表示 $x$ 到根路径的异或和。</p><p>考虑按位拆开来做，对于线性基 $P$，有 $S$ 元素，某二进制位为 $w$，则 $P$ 可以表示出 $2^S$ 个不同的数。</p><ul><li>如果 $P$ 中存在 $w$ 位为 $1$ 的数，则 $2^S$ 个数中恰有 $2^{S-1}$ 个数的二进制第 $w$ 位为 $1$，另外一半二进制第 $w$ 位为 $0$。</li><li>如果 $P$ 中不存在 $w$ 位为 $0$ 的数，显然不能表示出二进制第 $w$ 位为 $1$ 的数，所有 $2^S$ 个数的二进制第 $w$ 位均为 $0$。</li></ul><p>那么我们只需要统计每一位有多少种被表示出来的方式，统计答案即可。</p><p>考虑直接枚举二进制位 $w$，看下线性基 $P$ 中是否存在二进制位第 $w$ 位为 $1$ 的数即可。</p><ul><li>如果存在，那么选择两个点的二进制第 $w$ 位无论是几都可符合题意，并且此时存在 $2^{S-1}$ 条路径使得其异或和该二进制位为 $1$。那么对答案的贡献就是 $2^w\times 2^{S-1}\times C_{n}^2$。</li><li>如果不存在，那么选择两个点的二进制第 $w$ 位必须恰有一个为 $1$，并且此时存在 $2^S$ 条路径的异或和第 $w$ 位为 $1$。记第 $w$ 位为 $1$ 的 $d_x$ 的个数为 $x$，那么对答案的贡献就是 $2^w\times 2^S\times x\times(n-x)$。</li></ul><p>时间复杂度 $O(n\log^2t_i)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=100010,M=400010,Mod=1e9+7;</span><br><span class="line">int n,m,fir[N],nxt[M],son[M],tot,vis[N],dfn[N];</span><br><span class="line">LL w[M],dis[N],d[65],C,Ans,cnt;</span><br><span class="line">I void Add(CI x,CI y,LL z)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z;&#125;</span><br><span class="line">I void Insert(LL x)&#123;</span><br><span class="line">    RI i;for(i=63;~i;i--) if(x&gt;&gt;i&amp;1LL)</span><br><span class="line">    if(!d[i])&#123;++C,d[i]=x;return ;&#125;</span><br><span class="line">    else x^=d[i];</span><br><span class="line">&#125;</span><br><span class="line">#define to son[i]</span><br><span class="line">I void Dfs(CI x,LL sum)&#123;</span><br><span class="line">    RI i;for(vis[x]=1,dis[x]=sum,dfn[++cnt]=x,i=fir[x];i;i=nxt[i]) if(!vis[to]) Dfs(to,sum^w[i]);</span><br><span class="line">    else Insert(sum^dis[to]^w[i]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,k,x,y;LL z;for(read(n,m),i=1;i&lt;=m;i++) read(x,y,z),Add(x,y,z),Add(y,x,z);</span><br><span class="line">    for(i=1;i&lt;=n;i++) if(!vis[i])&#123;</span><br><span class="line">        for(memset(d,0,sizeof(d)),cnt=C=0,Dfs(i,0),j=0;j&lt;=63;j++)&#123;</span><br><span class="line">            LL t=1LL&lt;&lt;j;t%=Mod;</span><br><span class="line">            bool flg=0;</span><br><span class="line">            for(k=0;k&lt;=63;k++) if(d[k]&gt;&gt;j&amp;1LL) flg=1;</span><br><span class="line">            if(flg) Ans+=cnt*(cnt-1)/2%Mod*((1LL&lt;&lt;C-1)%Mod)%Mod*t%Mod,Ans%=Mod;</span><br><span class="line">            else&#123;</span><br><span class="line">                LL x=0;for(k=1;k&lt;=cnt;k++) if(dis[dfn[k]]&gt;&gt;j&amp;1LL) ++x;</span><br><span class="line">                Ans+=x*(cnt-x)%Mod*((1LL&lt;&lt;C)%Mod)%Mod*t%Mod,Ans%=Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return writeln(Ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈线性基</title>
      <link href="/2021/02/24/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2021/02/24/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>线性基是竞赛中常用来解决子集异或一类题目的算法。</p><p>基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。</p><p>同样的，线性基是一种特殊的基，它通常会在异或运算中出现，它的意义是：通过原集合S的某一个最小子集S1使得S1内元素相互异或得到的值域与原集合S相互异或得到的值域相同。</p><p>——百度百科</p></blockquote><p>要了解何为线性基，首先你<strong>不需要</strong>掌握基是什么。</p><p>你只要知道：线性基是由一个数的集合构造出来的另一个数的集合，并且满足一些性质，使其能解决有关<strong>异或</strong>的一些题目。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>原集合里的任何数都可以用线性基中某些数的<strong>异或和</strong>表示。</li><li>线性基中任意数的**异或和不等于 $0$**。</li><li>线性基的大小之和原集合的大小有关，并且是满足性质 $1,2$ 的前提下，大小最小的。换句话说，就是<strong>线性基的大小固定且最小</strong>。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果有一集合 $A&#x3D;{110,011,101}$，那么 $A$ 的线性基可以为 ${110,011},{110,101},{011,10}$。</p><p>如果有一集合 $B&#x3D;{10,11}$，那么 $B$ 的线性基可以为 ${10,11},{10,01},{01,11}$。</p><p>很显然，以上均是合法的线性基，满足所有线性基的性质。</p><p>由此可见，<strong>集合的线性基可能不唯一</strong>，<strong>线性基中的元素可以不在原集合中</strong>。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们可以采用反证法：（可能不太严谨）</p><p>设线性基 $S&#x3D;{a_1,a_2,\dots,a_n}$，若有其子集 $P&#x3D;{a_1,a_2,\dots,a_k}$，并且满足 $a_1\oplus a_2 \oplus \dots \oplus a_k&#x3D;0$，那么 $a_1&#x3D;a_2\oplus a_3\oplus \dots \oplus a_k$，则舍弃 $a_1$ 后一定可以通过剩余的元素异或出所有 $a_1$ 所需要参与的异或值。</p><p>那么 $a_1$ 就可以舍弃，用别的数来代替 $a_1$，使线性基的个数减少。</p><p>而线性基又是大小最小的（性质 $3$），与假设矛盾，证毕。</p><h2 id="线性基的构造"><a href="#线性基的构造" class="headerlink" title="线性基的构造"></a>线性基的构造</h2><p>讲完了何为线性基，那么问题来了，给定一个集合，我们如何构造它的线性基呢？</p><p>设数组 $d$ 表示线性基，下标从 $0$ 开始，不难得出其构造的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I void Add(LL x)&#123;</span><br><span class="line">    RI i;for(i=60;~i;i--) if(x&gt;&gt;i&amp;1)//从高到低枚举二进制数的每一位，如果该位为1</span><br><span class="line">        if(d[i]) x^=d[i];</span><br><span class="line">        else&#123;d[i]=x;break ;&#125; //插入成功后直接退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据此，我们可以得到一个关于 $d$ 数组的性质：存入 $d[i]$ 的元素的第 $i$ 位为 $1$，并且 $d[i]<em>{(2)}$ 的最高位就是第 $i$ 位。（假设 $x</em>{(2)}$ 表示 $x$ 的二进制表示）</p><h3 id="构造的正确性证明"><a href="#构造的正确性证明" class="headerlink" title="构造的正确性证明"></a>构造的正确性证明</h3><p>略（只要分别证明其三个基本性质即可。</p><h2 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h2><ol><li>给定一个集合，询问某个数能否被表示成集合中某些元素的异或和。</li><li>给定一个集合，求取一些数异或和的最大值&#x2F;最小值。</li><li>给定一个集合，取任意多个数字异或，求异或和的第 $k$ 小。</li><li>线性基的删除操作</li></ol><p>我们来一个一个分析。</p><h3 id="1-能否表示成集合中某些元素的异或和"><a href="#1-能否表示成集合中某些元素的异或和" class="headerlink" title="1. 能否表示成集合中某些元素的异或和"></a>1. 能否表示成集合中某些元素的异或和</h3><p>这个问题其实十分简单，首先构造出这个集合的线性基，然后尝试把这个数插入线性基，如果可以，就表明不能；否则肯定可以选取某些线性基内的数异或得到该数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I int Add(LL x)&#123;</span><br><span class="line">    RI i,flg=0;for(i=60;~i;i--) if(x&gt;&gt;i&amp;1)</span><br><span class="line">        if(d[i]) x^=d[i];</span><br><span class="line">        else&#123;flg=1;break ;&#125; </span><br><span class="line">    return !flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求最大值-x2F-最小值"><a href="#2-求最大值-x2F-最小值" class="headerlink" title="2. 求最大值&#x2F;最小值"></a>2. 求最大值&#x2F;最小值</h3><p>很显然，如果能使高位为 $1$，那么宁可舍弃低位的 $1$，所以只要从高到低枚举每一位是否能使答案的该位变为 $1$ 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I LL GetAns()&#123;</span><br><span class="line">    LL Ans=0;RI i;for(i=60;~i;i--) if((Ans^d[i])&gt;Ans) Ans^=d[i];</span><br><span class="line">    return Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是求最小值，那么只要先判断下是否能构成 $0$，即线性基的大小如果小于集合的大小，那么存在某些数的异或和为 $0$，那么 $0$ 就是最小值。</p><p>如果线性基的大小刚好等于集合的大小，那么最小值一定是最小的 $d[i]$。</p><p>因为我们在构造线性基的时候保证了每一位的 $d[i]$ 的最高位必定是 $i$，因此用最小的 $d[i]$ 异或别的数，得到的结果必定大于 $d[i]$，证毕。</p><h3 id="3-求异或和第-k-小"><a href="#3-求异或和第-k-小" class="headerlink" title="3. 求异或和第 $k$ 小"></a>3. 求异或和第 $k$ 小</h3><p>首先我们可以把我们现有的线性基变换一下。</p><p>具体地，枚举每个 $d[i]$，再枚举 $j$（从 $i-1$ 到 $0$），如果 $d[i]_{(2)}$ 的第 $j$ 位是 $1$，那么令 $d[i]\oplus&#x3D;d[j]$。根据线性基的三个性质，不难证明，处理过后的集合仍然是集合的线性基，只是对于每个 $d[i]$，把 $i$ 位之后的所有都异或成了 $0$。</p><p>新的线性基大致长成这样：（$x$ 表示可能是 $0$ 或 $1$）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1xxxx0xxx0x</span><br><span class="line">000001xxx0x</span><br><span class="line">0000000001x</span><br></pre></td></tr></table></figure><p>不难发现，这个线性基使每个 $d[i]$ 只有其第 $i$ 位为 $1$，那么只要使 $k$ 的每一位和 $d[i]$ 相对应，异或上第 $i$ 大的元素，即可求出最终的 $Ans$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I void Work()&#123;</span><br><span class="line">    RI i,j;for(i=1;i&lt;=60;i++) for(j=i-1;~j;j--) if(d[i]&amp;(1LL&lt;&lt;j)) d[i]^=d[j];</span><br><span class="line">&#125;</span><br><span class="line">I LL K_th(LL k)&#123;</span><br><span class="line">    if(tot&lt;n&amp;&amp;!--k) return 0;//tot表示线性基中的元素的个数，n表示序列长度。注意可以异或出0的情况</span><br><span class="line">    LL Ans=0;RI i;for(Work(),i=0;i&lt;=60;i++) if(d[i]) k&amp;1&amp;&amp;(Ans^=d[i],0),k&gt;&gt;=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线性基的删除操作"><a href="#4-线性基的删除操作" class="headerlink" title="4. 线性基的删除操作"></a>4. 线性基的删除操作</h3><h4 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h4><p>如果要求删除的 $x$ 刚好在线性基外，即删除后对线性基没有任何影响，那么直接删除即可。</p><p>如果要求删除的 $x$ 在线性基内，此时，我们需要构造出一个集合 $P$，记录线性基中这个数插入进来时异或过那些数，然后找到线性基中最小的并且 $P$ 包含 $x$ 的数，让他异或线性基中其他包含 $x$ 的数即可（包括自己），这样就消去了 $x$ 在线性基中的影响，即用最小的数代替了他。</p><h4 id="离线"><a href="#离线" class="headerlink" title="离线"></a>离线</h4><p>上面的问题并没有强制在线，所以也可以离线做，离线的话其实更简单。</p><p>我们可以找到线性基中对于每一个数，可以代替他们的那些数，那么可以使线性基优先存删除时间晚的，那么就消除了上面的<code>把他删掉之后可能序列中其他的数可以填进来</code>这样的问题，其余操作一样。</p><p>具体实现起来就是在插入一个新数的时候，对比一下这个数的删除时间和当前枚举到的线性基的某一位的删除时间，假如比他晚就直接替换掉，否则异或它然后继续枚举。这样就少维护了一个集合。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>[checkbox checked&#x3D;”true”]LuoguP3812 【模板】线性基[&#x2F;checkbox] [checkbox checked&#x3D;”true”]【例题1】彩灯[&#x2F;checkbox] [checkbox checked&#x3D;”true”]【例题2】元素[&#x2F;checkbox] [checkbox checked&#x3D;”true”]K小异或和[&#x2F;checkbox] [checkbox checked&#x3D;”true”]路径最大异或和[&#x2F;checkbox] [checkbox checked&#x3D;”true”]有趣的三元组[&#x2F;checkbox] [checkbox checked&#x3D;”true”]出现位置[&#x2F;checkbox]</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA1104 芯片难题 Chips Challenge 题解</title>
      <link href="/2021/02/21/uva1104-%E8%8A%AF%E7%89%87%E9%9A%BE%E9%A2%98-chips-challenge-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/21/uva1104-%E8%8A%AF%E7%89%87%E9%9A%BE%E9%A2%98-chips-challenge-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/UVA1104">题目链接</a></p></blockquote><p>有一个 $N \times N$ 的棋盘，可以在上面放棋子。</p><p>有些格子不能放棋子，有些格子必须放棋子，剩下的格子随意。</p><p>要求放好棋子之后满足如下两条要求：</p><ol><li>第 $i$ 行和第 $i$ 列的棋子数目必须一样多。$(1\leq i \leq N)$</li><li>第 $i$ 行的棋子数目不能超过总的棋子数目的 $\frac{A}{B}$。$(1\leq i \leq N)$</li></ol><p>求最多可以另外放多少个棋子（就是除掉必须放的）。如果无解输出 <code>impossible</code>。</p><p>$1\leq N \leq 40,1\leq A\leq B\leq 1000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们可以考虑<strong>补集</strong>思想。</p><p>考虑如果一开始把所有可以放的格子不管三七二十一都放上棋子。</p><p>那么题目就转化为<strong>至少从中除掉多少个棋子，使其满足题目条件</strong>。</p><p>但问题来了，我们既不知道棋子的总个数，也不知道每一行的个数。</p><p>既然是要求最少，那么我们可以先枚举每一行最多的棋子的个数，然后跑一遍费用流，计删掉一个棋子的花费为 $i$，那么问题就转化为求最小费用最大流。</p><p>考虑如何建图，</p><p>首先将超级源点 $S$ 连向 $i$ 一条流量为 $sumx[i]$（表示该行的可以放的棋子数量），费用为 $0$ 的边，表示该行一开始就可以有 $sumx[i]$ 个棋子。</p><p>再将每一列 $i+n$ 连向超级汇点 $T$ 一条流量为 $sumy[i]$，费用为 $0$ 的边，表示该列最多可以放置 $sumy[i]$。</p><p>然后将每一行 $i$ 与对应的列 $i+n$ 连一条流量为 $flow$（表示枚举到的对多流量），费用为 $0$ 的边，表示每一行每一列的放置棋子的个数应该相等。</p><p>然后考虑如果第 $i$ 行 $j$ 列是 <code>&#39;.&#39;</code>，表示可以放也可以不放，那么我们就可以 $i$ 连一条 $j+n$ 的边，流量为 $1$，费用为 $1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,A,B,sum,used,sumx[N],sumy[N],s[N][N],S,T,fir[N&lt;&lt;1],nxt[N*N&lt;&lt;1],son[N*N&lt;&lt;1],w[N*N&lt;&lt;1],cost[N*N&lt;&lt;1],tot=1,Ans,Cost,Max=-1,inf=2e9,dis[N&lt;&lt;1],vis[N&lt;&lt;1],Case;</span><br><span class="line">I int Read_char()&#123;char c=gc();W(c^&#x27;/&#x27;&amp;&amp;c^&#x27;.&#x27;&amp;&amp;c^&#x27;C&#x27;) c=gc();return c==&#x27;/&#x27;?-1:c==&#x27;C&#x27;;&#125;</span><br><span class="line">I void Add(CI x,CI y,CI z,CI c)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,cost[tot]=c;nxt[++tot]=fir[y],fir[y]=tot,son[tot]=x,w[tot]=0,cost[tot]=-c;&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">#define to son[i]</span><br><span class="line">struct Edge&#123;int son,id;&#125;pre[N&lt;&lt;1];</span><br><span class="line">I bool bfs()&#123;</span><br><span class="line">W(!q.empty()) q.pop();q.push(S);memset(dis,63,sizeof(dis));inf=dis[0];dis[S]=0;memset(vis,0,sizeof(vis));W(!q.empty())&#123;</span><br><span class="line">RI u=q.front(),i;q.pop();for(i=fir[u];i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;dis[to]&gt;dis[u]+cost[i]) dis[to]=dis[u]+cost[i],pre[to]=(Edge)&#123;u,i&#125;,!vis[to]&amp;&amp;(q.push(to),vis[to]=1);vis[u]=0;&#125;return dis[T]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">I void EK()&#123;Ans=Cost=0;RI Min=inf,i;W(bfs())&#123;Min=inf;for(i=T;i^S;i=pre[i].son) Min=min(Min,w[pre[i].id]);for(i=T;i^S;i=pre[i].son) w[pre[i].id]-=Min,w[pre[i].id^1]+=Min;Ans+=Min,Cost+=Min*dis[T];&#125;return ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,k;W(read(n,A,B),memset(sumx,0,sizeof(sumx)),memset(sumy,0,sizeof(sumy)),S=sum=sum=used=0,T=n&lt;&lt;11,nAB)&#123;</span><br><span class="line">for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) s[i][j]=Read_char();for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(s[i][j]&gt;=0) sum++,sumx[i]++,sumy[j]++,used+=s[i][j];for(Max=-1,k=0;k&lt;=n;k++)&#123;</span><br><span class="line">for(memset(fir,0,sizeof(fir)),tot=1,i=1;i&lt;=n;i++) for(Add(S,i,sumx[i],0),Add(i+n,T,sumy[i],0),Add(i,i+n,k,0),j=1;j&lt;=n;j++) !s[i][j]&amp;&amp;(Add(i,j+n,1,1),0);</span><br><span class="line">EK();if(Ans==sum&amp;&amp;k*B&lt;=(sum-Cost)*A) Max=max(Max,sum-Cost);</span><br><span class="line">&#125;printf(&quot;Case %d: &quot;,++Case);if(~Max) writeln(Max-used);else puts(&quot;impossible&quot;);</span><br><span class="line">&#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP2223 [HNOI2001]软件开发 题解</title>
      <link href="/2021/02/20/luogup2223-hnoi2001%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/20/luogup2223-hnoi2001%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>某软件公司正在规划一项n天的软件开发计划，根据开发计划第i天需要ni个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种，A种方式的消毒需要a天时间，B种方式的消毒需要b天（b&gt;a），A种消毒方式的费用为每块毛巾fA, B种消毒方式的费用为每块毛巾fB，而买一块新毛巾的费用为f（新毛巾是已消毒的，当天可以使用）；而且f&gt;fA&gt;fB。公司经理正在规划在这n天中，每天买多少块新毛巾、每天送多少块毛巾进行A种消毒和每天送多少块毛巾进行B种消毒。当然，公司经理希望费用最低。你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行A种消毒和多少毛巾进行B种消毒，使公司在这项n天的软件开发中，提供毛巾服务的总费用最低。</p><p>$1\leq f,fA,fB\leq 60,1\leq n\leq 1000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，拆点，把每个点拆成入点和出点，分别为 $i$ 和 $i+n$。</p><p>考虑每天有且只有 $n_i$ 个毛巾，故建立超级源点 $S$ 和超级汇点 $T$，并在 $S$ 和 $i$ 之间、$i+n$ 和 $T$ 之间连接容量 $inf$，费用 $0$ 的边。</p><p>接下来考虑各个方法。</p><p>对于 $a$ 和 $b$ 只要在 $i$ 天和 $i+a$ 天之间连一条容量为 $inf$，费用为 $fa$ 的边，$b$ 同理。</p><p>每天的新毛巾可以留到明天，所以 $i$ 和 $i+1$ 之间连接一条容量为 $inf$，费用为 $0$ 的边。</p><p>最后每天可以进货，所以 $S$ 和 $i+n$ 连 $inf,f$。</p><p>最后跑一遍费用流。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=1010;</span><br><span class="line">int n,a,b,f,fa,fb,c[N],cnt,S,T,in[N],out[N],inf=2e9,fir[N&lt;&lt;1],son[N&lt;&lt;4],nxt[N&lt;&lt;4],w[N&lt;&lt;4],cost[N&lt;&lt;4],tot=1,dis[N&lt;&lt;1],vis[N&lt;&lt;1],Cost;</span><br><span class="line">I void add(CI x,CI y,CI z,CI c)&#123;nxt[++tot]=fir[x],fir[x]=tot,son[tot]=y,w[tot]=z,cost[tot]=c;&#125;</span><br><span class="line">#define Add(x,y,z,c) (add(x,y,z,c),add(y,x,0,-c))</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">#define to son[i]</span><br><span class="line">struct Edge&#123;int son,id;&#125;pre[N&lt;&lt;1];</span><br><span class="line">I bool bfs()&#123;</span><br><span class="line">W(!q.empty()) q.pop();memset(dis,63,sizeof(dis));inf=dis[0];dis[S]=0;memset(vis,0,sizeof(vis));q.push(S);W(!q.empty())&#123;</span><br><span class="line">RI u=q.front(),i;q.pop();for(i=fir[u];i;i=nxt[i]) if(w[i]&gt;0&amp;&amp;dis[to]&gt;dis[u]+cost[i]) dis[to]=dis[u]+cost[i],</span><br><span class="line">pre[to]=(Edge)&#123;u,i&#125;,!vis[to]&amp;&amp;(q.push(to),vis[to]=1);vis[u]=0;</span><br><span class="line">&#125;return dis[T]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">I void EK()&#123;</span><br><span class="line">Cost=0;W(bfs())&#123;</span><br><span class="line">RI i,Min=inf;for(i=T;i^S;i=pre[i].son) Min=min(Min,w[pre[i].id]);</span><br><span class="line">for(i=T;i^S;i=pre[i].son) w[pre[i].id]-=Min,w[pre[i].id^1]+=Min;</span><br><span class="line">Cost+=Min*dis[T];</span><br><span class="line">&#125;return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i;for(S=++cnt,T=++cnt,read(n,a,b,f,fa,fb),i=1;i&lt;=n;i++) read(c[i]),in[i]=++cnt,out[i]=++cnt,Add(S,in[i],c[i],0),Add(out[i],T,c[i],0),Add(S,out[i],inf,f);</span><br><span class="line">for(a++,b++,i=1;i&lt;=n;i++) i+a&lt;=n&amp;&amp;(Add(in[i],out[i+a],inf,fa),0),i+b&lt;=n&amp;&amp;(Add(in[i],out[i+b],inf,fb),0),i&lt;n&amp;&amp;(Add(in[i],in[i+1],inf,0),0);</span><br><span class="line">return EK(),writeln(Cost),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP2605 [ZJOI2010]基站选址 题解</title>
      <link href="/2021/02/14/luogup2605-zjoi2010%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/14/luogup2605-zjoi2010%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2605">题目链接</a></p></blockquote><p>有 $N$ 个村庄坐落在一条直线上，第 $i(i&gt;1)$ 个村庄距离第 $1$ 个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 $K$ 个通讯基站，在第 $i$ 个村庄建立基站的费用为 $C_i$。如果在距离第 $i$ 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么村庄就被通讯信号覆盖。如果第 $i$ 个村庄没有被通讯信号覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。</p><p>求出最小的总费用。</p><p>$1\leq N \leq 2\times 10^4,1\leq K \leq 100$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先很容易就可以列出一个暴力 $DP$ 方程：</p><p>设 $dp[i][j]$ 表示前 $i$ 个村庄，造 $j$ 个通讯基站的最小花费。</p><p>$$dp[i][j]&#x3D;\min\{dp[k][j-1]+cost[k,i]\}+C_i$$</p><p>很显然，这题的瓶颈主要在求解 $cost[k,i]$ 上。</p><p>我们可以令 $st[i]$ 表示如果在村庄 $i$ 造基站，向左最多能覆盖到哪个村庄，$ed[i]$ 表示向右最多能覆盖到哪个村庄。</p><p>考虑用线段树维护下 $\min\{dp[k][j-1]+cost[k,i]\}$</p><p>我们每次更新 $dp[i][j]$ 时，可以把 $ed[k]$ 刚好为 $i$ 的 $k$ 的 $[1,st[k]-1]$ 的 $cost$ 全部加上 $w[k]$（代表这些村庄需要补偿）。</p><p>因为所有后面的点，如果要从 $[1,st[k]-1]$ 的点转移过来，$k$ 必定无法被覆盖到，所以要加上赔偿费用。</p><p>然后更新的时候直接取用 $[1,j-1]$ 的最小值即可。</p><p>最后可以在无穷远处开个费用为 $0$ 的点，便于统计答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define CI Cn int&amp;</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=20010;</span><br><span class="line">int n,m,d[N],c[N],s[N],w[N],inf=2e9,f[N],tr[N&lt;&lt;2],tag[N&lt;&lt;2],st[N],ed[N];</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">#define IT vector&lt;int&gt;::iterator</span><br><span class="line">#define LW(x) lower_bound(d+1,d+n+1,x)-d</span><br><span class="line">#define mid (l+r&gt;&gt;1)</span><br><span class="line">#define ls x&lt;&lt;1,l,mid</span><br><span class="line">#define rs x&lt;&lt;11,mid+1,r</span><br><span class="line">#define UP(x) tr[x]=min(tr[x&lt;&lt;1],tr[x&lt;&lt;11])</span><br><span class="line">#define PD(x) tag[x]&amp;&amp;(Add(x&lt;&lt;1,tag[x]),Add(x&lt;&lt;11,tag[x]),tag[x]=0)</span><br><span class="line">IT It;</span><br><span class="line">I void Add(CI x,CI val)&#123;tr[x]+=val;tag[x]+=val;return ;&#125;</span><br><span class="line">I void build(CI x,CI l,CI r)&#123;if(tag[x]=0,l==r) return void(tr[x]=f[l]);build(ls),build(rs),UP(x);&#125;</span><br><span class="line">I void update(CI x,CI l,CI r,CI L,CI R,CI val)&#123;if(L&gt;R) return ;if(L&lt;=l&amp;&amp;r&lt;=R) return Add(x,val);PD(x);if(L&lt;=mid) update(ls,L,R,val);if(R&gt;mid) update(rs,L,R,val);UP(x);&#125;</span><br><span class="line">I int query(CI x,CI l,CI r,CI L,CI R)&#123;if(L&gt;R) return inf;if(L&lt;=l&amp;&amp;r&lt;=R) return tr[x];PD(x);RI res=inf;if(L&lt;=mid) res=min(res,query(ls,L,R));if(R&gt;mid) res=min(res,query(rs,L,R));return res;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,S;read(n,m);for(d[1]=0,i=2;i&lt;=n;i++) read(d[i]);for(i=1;i&lt;=n;i++) read(c[i]);for(i=1;i&lt;=n;i++) read(s[i]);for(i=1;i&lt;=n;i++) read(w[i]);++m,++n,d[n]=w[n]=inf;</span><br><span class="line">for(i=1;i&lt;=n;i++) st[i]=LW(d[i]-s[i]),ed[i]=LW(d[i]+s[i]),d[ed[i]]&gt;d[i]+s[i]&amp;&amp;ed[i]--,v[ed[i]].push_back(i);for(S=0,i=1;i&lt;=n;i++) for(f[i]=S+c[i],It=v[i].begin();It!=v[i].end();It++) S+=w[*It];</span><br><span class="line">for(S=f[n],i=2;i&lt;=m;S=min(S,f[n]),i++) for(build(1,1,n),j=1;j&lt;=n;j++) for(f[j]=query(1,1,n,1,j-1)+c[j],It=v[j].begin();It!=v[j].end();It++) update(1,1,n,1,st[*It]-1,w[*It]);return writeln(S),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 线段树优化DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP3104 [USACO14MAR]Counting Friends G 题解</title>
      <link href="/2021/02/09/luogup3104-usaco14marcounting-friends-g-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/09/luogup3104-usaco14marcounting-friends-g-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3104">题目链接</a></p></blockquote><p>$n(1\leq n\leq 500)$ 头奶牛都有一个或一个以上的朋友。$FJ$ 记录每头牛的朋友数，但他傻不小心混入了一个错的数字，请找出。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不得不说O2大法好（</p><p><img src="https://i.loli.net/2021/02/09/gQz3knJMipAGfbo.png" alt="image.png"></p><p>所以我们要多吸氧（bushi</p><p>然而为啥我是跑得最慢的呀（</p><p>首先我们可以考虑一下暴力怎么打。</p><p>直接枚举哪一个点是多余的，然后暴力判断。</p><p>可是暴力判断怎么写呢（别跟我说你要写 $dfs$</p><p>显然对于每一个需要匹配的点来说，肯定贪心地优先匹配剩下的需要匹配最多的那个点。</p><p>那么只要开个堆，每次找剩下匹配最大的即可。</p><p>然后我写了个暴力交上去，开了个O2就过了</p><p>然后这个暴力的最劣复杂度为 $O(N^3logN)$。</p><p>所以接下来考虑正解，最起码得把这个 $log$ 优掉。</p><p>显然我们可以开一个桶来代替堆，每次直接从大到小枚举，能合并的直接合并即可。</p><p>注意合并的时候要先记录下，不然下传的时候会产生冲突。</p><p>然后就一瞬拿到了最优解つ﹏⊂。</p><p><img src="https://i.loli.net/2021/02/09/jFRbTMcQhYy691l.png" alt="image.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=510;</span><br><span class="line">int n,a[N],vis[N],b[N],g[N];</span><br><span class="line">vector&lt;int&gt; Ans;</span><br><span class="line">#define P pair&lt;int,int&gt;</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define Dx(x) a[(x)]-vis[(x)]</span><br><span class="line">#define p j.second</span><br><span class="line">priority_queue&lt;P&gt; q;</span><br><span class="line">vector&lt;P&gt;t;</span><br><span class="line">I void find(int x)&#123;if(Dx(x)&gt;min(n-x+1,q.size())) return ;t.clear();P j;W(vis[x]&lt;a[x]&amp;&amp;!q.empty()) j=q.top(),q.pop(),p^x&amp;&amp;Dx(p)&gt;0&amp;&amp;((++vis[p])^a[p]&amp;&amp;(t.push_back(MP(Dx(p),p)),0),vis[x]++);for(auto o:t) o.second&gt;x&amp;&amp;(q.push(o),0);&#125;//寻找可以匹配的点</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,flg;read(n);for(i=1;i&lt;=n+1;i++) read(a[i]),g[a[i]]=-1;for(i=1;i&lt;=n+1;i++) if(~g[a[i]]) g[a[i]]&amp;&amp;(Ans.push_back(i),0);else&#123;//开个桶，记忆化是否之前做过</span><br><span class="line">W(!q.empty()) q.pop();for(memset(vis,0,sizeof(vis)),vis[i]=a[i],j=1;j&lt;=n+1;j++) vis[j]&lt;a[j]&amp;&amp;(q.push(make_pair(Dx(j),j)),0);</span><br><span class="line">for(flg=0,j=1;j&lt;=n+1;j++)&#123;vis[j]&lt;a[j]&amp;&amp;(find(j),0);if(vis[j]^a[j])&#123;flg=1;break ;&#125;&#125;;g[a[i]]=!flg;if(!flg) Ans.push_back(i);</span><br><span class="line">&#125;sort(Ans.begin(),Ans.end()),write(Ans.size()),pc(&#x27;\n&#x27;);for(auto j:Ans) write(j),pc(&#x27;\n&#x27;);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=510;</span><br><span class="line">int n,a[N],b[N],g[N],stk[N],top,f[N];</span><br><span class="line">vector&lt;int&gt; Ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">RI i,j,k,flg,d,t;read(n);for(i=1;i&lt;=n+1;i++) read(a[i]),g[a[i]]=-1;for(i=1;i&lt;=n+1;i++) if(~g[a[i]]) g[a[i]]&amp;&amp;(Ans.push_back(i),0);else&#123;</span><br><span class="line">for(top=0,memset(stk,0,sizeof(stk)),j=1;j&lt;=n+1;j++) i^j&amp;&amp;(stk[a[j]]++,top=max(top,a[j]));</span><br><span class="line">for(flg=0,j=top;j&gt;=1;j--) W(stk[j]--)&#123;</span><br><span class="line">for(k=j,t=j;k&gt;=1&amp;&amp;t;k--) f[k]=min(stk[k],t),stk[k]-=f[k],t-=f[k];</span><br><span class="line">for(k=j;k&gt;=1;k--) stk[k-1]+=f[k],f[k]=0;if(t)&#123;flg=1;break ;&#125;</span><br><span class="line">&#125;if(g[a[i]]=!flg) Ans.push_back(i);</span><br><span class="line">&#125;write(Ans.size()),pc(&#x27;\n&#x27;);for(auto j:Ans) write(j),pc(&#x27;\n&#x27;);return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 桶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LuoguP4893 GodFly的求导工具 题解</title>
      <link href="/2021/02/08/luogup4893-godfly%E7%9A%84%E6%B1%82%E5%AF%BC%E5%B7%A5%E5%85%B7-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/02/08/luogup4893-godfly%E7%9A%84%E6%B1%82%E5%AF%BC%E5%B7%A5%E5%85%B7-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4893">题目链接</a></p></blockquote><p>给定一个 $n$ 次整系数函数 $f(x)$，问 $f(x)$ 的 $k$ 阶导在 $x_i$ 处的导数。</p><p>$1\leq n \leq 100,k\leq n,m\leq 10,a_i\leq 10^5,x_i\leq 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很好奇这题是怎么评紫的（？</p><p>咳咳，对于这道题，你先要有<strong>亿</strong>点<strong>简单</strong>高等数学知识。</p><ul><li>$f(x)&#x3D;x^p$ 的 $k$ 阶导函数为 $f^{(k)}(x)&#x3D;\prod_{i&#x3D;1}^k(p-i+1)x^{p-k}$</li><li>$f(x)&#x3D;g(x)+h(x)$ 的 $k$ 阶导函数为 $f^{(k)}(x)&#x3D;g^{(k)}(x)+h^{(k)}(x)$</li></ul><p>证明略（</p><p>假设你已经熟知了以上结论，那么就可以愉快的把这道题切掉了。</p><p>直接暴力拆出每一项的系数，暴力进行求导，找到其 $k$ 阶导函数，对于每个询问，直接暴力带入即可。</p><p>因为 $a_i\leq 10^5,x_i \leq 10^5$ 可能会导致答案爆 $int$，所以你还要耐心地写一个高精套一个高精模板。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define gc getchar</span><br><span class="line">#define DD isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">    Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">    Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">    Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">    #define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">    Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!DD) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),DD);x*=f;&#125;</span><br><span class="line">    Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">    Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">    Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;using namespace FastIO;</span><br><span class="line">Cn int N=110;</span><br><span class="line">class Int&#123;//Manchery的高精模板</span><br><span class="line">    #define BASE 1000000000</span><br><span class="line">    public:</span><br><span class="line">    typedef long long value;</span><br><span class="line">    void New(size_t l)&#123;</span><br><span class="line">        if (a!=NULL)delete[] a;a=new value[l];</span><br><span class="line">        len=1;a[0]=0;sign=1;</span><br><span class="line">    &#125;</span><br><span class="line">    Int():a(NULL),base(BASE)&#123;New(1);&#125;</span><br><span class="line">    Int(value x):a(NULL),base(BASE)&#123;New(1);*this=x;&#125;</span><br><span class="line">    Int(value x,value _base):a(NULL),base(_base)&#123;New(1);*this=x;&#125;</span><br><span class="line">    Int(const Int &amp;B):a(NULL),base(BASE)&#123;New(1);*this=B;&#125;</span><br><span class="line">    ~Int()&#123;delete[] a;&#125;</span><br><span class="line">    Int&amp; operator =(value x)&#123;</span><br><span class="line">        size_t l=1;for (value x1=max(x,-x);x1&gt;=base;++l,x1/=base);New(l);</span><br><span class="line">        if (x&lt;0)x=-x,sign=0;else sign=1;</span><br><span class="line">        len=0;while (x)a[len++]=x%base,x/=base;</span><br><span class="line">        if (!len)a[len++]=0;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    Int&amp; operator =(const Int &amp;A)&#123;</span><br><span class="line">        New(A.len);len=A.len;memcpy(a,A.a,sizeof(value)*len);</span><br><span class="line">        base=A.base;sign=A.sign;return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int operator -(Int A)&#123;A.sign=1-A.sign;return A;&#125;</span><br><span class="line">    bool operator !()&#123;if (len==1&amp;&amp;a[0]==0)return 1;else return 0;&#125;</span><br><span class="line">    friend Int operator +(Int A,Int B)&#123;</span><br><span class="line">        if (A.sign!=B.sign)&#123;B.sign=1-B.sign;return A-B;&#125;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        Int res;res.set_base(A.base); int len=A.len&gt;B.len?A.len:B.len;</span><br><span class="line">        res.New(len+1);res.sign=A.sign;</span><br><span class="line">        memset(res.a,0,(len+1)*sizeof(value));</span><br><span class="line">        for (int i=0;i&lt;len;++i)&#123;</span><br><span class="line">            if (i&lt;A.len)res.a[i]+=A.a[i];</span><br><span class="line">            if (i&lt;B.len)res.a[i]+=B.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0;i&lt;len;++i)</span><br><span class="line">            if (res.a[i]&gt;=res.base)++res.a[i+1],res.a[i]-=res.base;</span><br><span class="line">        if (res.a[len])res.len=len+1;else res.len=len;</span><br><span class="line">        if (!res)res.sign=1;return res;</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int operator -(Int A,Int B)&#123;</span><br><span class="line">        if (A.sign!=B.sign)&#123;B.sign=1-B.sign;return A+B;&#125;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        if (small(A,B))swap(A,B),A.sign=1-A.sign;</span><br><span class="line">        Int res;res.set_base(A.base); int len=A.len&gt;B.len?A.len:B.len;</span><br><span class="line">        res.New(len);res.sign=A.sign;</span><br><span class="line">        memset(res.a,0,len*sizeof(value));</span><br><span class="line">        for (int i=0;i&lt;len;++i)&#123;</span><br><span class="line">            if (i&gt;=B.len)res.a[i]+=A.a[i];</span><br><span class="line">            else res.a[i]+=A.a[i]-B.a[i];</span><br><span class="line">            if (res.a[i]&lt;0)res.a[i]+=res.base,--res.a[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        while (len&gt;1&amp;&amp;!res.a[len-1])--len;res.len=len;</span><br><span class="line">        if (!res)res.sign=1;return res;</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int operator *(Int A,Int B)&#123;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        Int res;res.set_base(A.base); int len=A.len+B.len;</span><br><span class="line">        res.New(len);res.sign=(A.sign==B.sign);</span><br><span class="line">        memset(res.a,0,len*sizeof(value));</span><br><span class="line">        for (int i=0;i&lt;A.len;++i)</span><br><span class="line">            for (int j=0;j&lt;B.len;++j)&#123;</span><br><span class="line">                res.a[i+j]+=A.a[i]*B.a[j];</span><br><span class="line">                res.a[i+j+1]+=res.a[i+j]/res.base;</span><br><span class="line">                res.a[i+j]%=res.base;</span><br><span class="line">            &#125;</span><br><span class="line">        /*</span><br><span class="line">        for (int i=0;i&lt;A.len;++i)</span><br><span class="line">            for (int j=0;j&lt;B.len;++j)res.a[i+j]+=A.a[i]*B.a[j];</span><br><span class="line">        for (int i=0;i&lt;len-1;++i)res.a[i+1]+=res.a[i]/res.base,res.a[i]%=res.base;</span><br><span class="line">        */</span><br><span class="line">        while (len&gt;1&amp;&amp;!res.a[len-1])--len;res.len=len;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    friend pair&lt;Int,Int&gt; divide(Int A,Int B)&#123;</span><br><span class="line">        if (!B)&#123;puts(&quot;error:div zero!&quot;);for (;;);&#125;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        if (small(A,B))return make_pair(Int(0),A);</span><br><span class="line">        Int C,D;C.set_base(A.base);D.set_base(A.base);C.New(A.len);C.len=A.len;</span><br><span class="line">        bool Csign=(A.sign==B.sign),Dsign=A.sign;A.sign=B.sign=1;</span><br><span class="line">        for (int i=A.len-1;i&gt;=0;--i)&#123;</span><br><span class="line">            C.a[i]=0;D=D*D.base;D.a[0]=A.a[i];</span><br><span class="line">            int l=0,r=A.base-1,mid;</span><br><span class="line">            while (l&lt;r)&#123;</span><br><span class="line">                mid=(l+r+1)&gt;&gt;1;</span><br><span class="line">                if (small(B*mid,D+1))l=mid;</span><br><span class="line">                    else r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            C.a[i]=l;D=D-B*l;</span><br><span class="line">        &#125;</span><br><span class="line">        C.sign=Csign;D.sign=Dsign;if (!D)D.sign=1;</span><br><span class="line">        while (C.len&gt;1&amp;&amp;!C.a[C.len-1])--C.len;</span><br><span class="line">        return make_pair(C,D);</span><br><span class="line">    &#125;</span><br><span class="line">    Int operator /(value x)&#123;</span><br><span class="line">        if (!x)&#123;puts(&quot;error:div zero!&quot;);for (;;);&#125;</span><br><span class="line">        value d=0;Int res;res.set_base(base);res.New(len);res.len=len;</span><br><span class="line">        if (x&lt;0)x=-x,res.sign=(sign==0);</span><br><span class="line">        else res.sign=(sign==1);</span><br><span class="line">        for (int i=len-1;i&gt;=0;--i)</span><br><span class="line">            d=d*base+a[i],res.a[i]=d/x,d%=x;</span><br><span class="line">        while (res.len&gt;1&amp;&amp;!res.a[res.len-1])--res.len;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    Int operator %(value x)&#123;</span><br><span class="line">        value d=0;if (x&lt;0)x=-x;</span><br><span class="line">        for (int i=len-1;i&gt;=0;--i)d=(d*base+a[i])%x;</span><br><span class="line">        return d;</span><br><span class="line">    &#125;</span><br><span class="line">    friend Int abs(Int A)&#123;A.sign=1;return A;&#125;</span><br><span class="line">    friend bool small(Int A,Int B)&#123;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        if (A.len!=B.len)return A.len&lt;B.len;</span><br><span class="line">        for (int i=A.len-1;i&gt;=0;--i)</span><br><span class="line">            if (A.a[i]!=B.a[i])return A.a[i]&lt;B.a[i];</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    friend bool operator &lt;(Int A,Int B)&#123;</span><br><span class="line">        if (A.sign!=B.sign)return A.sign&lt;B.sign;</span><br><span class="line">        return A.sign==1?small(A,B):small(B,A);</span><br><span class="line">    &#125;</span><br><span class="line">    friend bool operator ==(Int A,Int B)&#123;</span><br><span class="line">        if (A.base!=B.base)</span><br><span class="line">            if (A.base&gt;B.base)B.set_base(A.base);</span><br><span class="line">            else A.set_base(B.base);</span><br><span class="line">        if (A.sign!=B.signA.len!=B.len)return 0;</span><br><span class="line">        for (int i=0;i&lt;A.len;++i)if (A.a[i]!=B.a[i])return 0;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    friend bool operator !=(Int A,Int B)&#123;return !(A==B);&#125;</span><br><span class="line">    friend bool operator &gt;(Int A,Int B)&#123;return !(A&lt;BA==B);&#125;</span><br><span class="line">    friend bool operator &lt;=(Int A,Int B)&#123;return A&lt;BA==B;&#125;</span><br><span class="line">    friend bool operator &gt;=(Int A,Int B)&#123;return A&gt;BA==B;&#125;</span><br><span class="line">    Int operator /(Int B)&#123;return divide(*this,B).first;&#125;</span><br><span class="line">    Int operator %(Int B)&#123;return divide(*this,B).second;&#125;</span><br><span class="line">    Int&amp; operator +=(Int B)&#123;*this=*this+B;return *this;&#125;</span><br><span class="line">    Int&amp; operator -=(Int B)&#123;*this=*this-B;return *this;&#125;</span><br><span class="line">    Int&amp; operator *=(Int B)&#123;*this=*this*B;return *this;&#125;</span><br><span class="line">    Int&amp; operator /=(Int B)&#123;*this=*this/B;return *this;&#125;</span><br><span class="line">    Int&amp; operator %=(Int B)&#123;*this=*this%B;return *this;&#125;</span><br><span class="line">    Int&amp; operator ++()&#123;*this=*this+1;return *this;&#125;</span><br><span class="line">    Int&amp; operator --()&#123;*this=*this-1;return *this;&#125;</span><br><span class="line">    Int operator ++(int)&#123;Int res(*this);*this=*this+1;return res;&#125;</span><br><span class="line">    Int operator --(int)&#123;Int res(*this);*this=*this-1;return res;&#125;</span><br><span class="line">    Int operator +(value x)&#123;return *this+Int(x,this-&gt;base);&#125;</span><br><span class="line">    Int operator -(value x)&#123;return *this-Int(x,this-&gt;base);&#125;</span><br><span class="line">    Int operator *(value x)&#123;return *this*Int(x,this-&gt;base);&#125;</span><br><span class="line">    //Int operator /(value x)&#123;Int T;T=x;return *this/T;&#125;</span><br><span class="line">    //Int operator %(value x)&#123;Int T;T=x;return *this%T;&#125;</span><br><span class="line">    Int&amp; operator *=(value x)&#123;*this=*this*x;return *this;&#125;</span><br><span class="line">    Int&amp; operator +=(value x)&#123;*this=*this+x;return *this;&#125;</span><br><span class="line">    Int&amp; operator -=(value x)&#123;*this=*this-x;return *this;&#125;</span><br><span class="line">    Int&amp; operator /=(value x)&#123;*this=*this/x;return *this;&#125;</span><br><span class="line">    Int&amp; operator %=(value x)&#123;*this=*this%x;return *this;&#125;</span><br><span class="line">    bool operator ==(value x)&#123;return *this==Int(x,this-&gt;base);&#125;</span><br><span class="line">    bool operator !=(value x)&#123;return *this!=Int(x,this-&gt;base);&#125;</span><br><span class="line">    bool operator &lt;=(value x)&#123;return *this&lt;=Int(x,this-&gt;base);&#125;</span><br><span class="line">    bool operator &gt;=(value x)&#123;return *this&gt;=Int(x,this-&gt;base);&#125;</span><br><span class="line">    bool operator &lt;(value x)&#123;return *this&lt;Int(x,this-&gt;base);&#125;</span><br><span class="line">    bool operator &gt;(value x)&#123;return *this&gt;Int(x,this-&gt;base);&#125;</span><br><span class="line">    friend Int gcd(Int x,Int y)&#123;</span><br><span class="line">        Int t;int cnt=0;</span><br><span class="line">        while (1)&#123;</span><br><span class="line">            if (x&lt;y)t=x,x=y,y=t;</span><br><span class="line">            if (y==0)&#123;</span><br><span class="line">                while (cnt--)x*=2;</span><br><span class="line">                return x;</span><br><span class="line">            &#125;</span><br><span class="line">            if (x%2==0&amp;&amp;y%2==0)x/=2,y/=2,++cnt;</span><br><span class="line">            else if (x%2==0)x/=2;</span><br><span class="line">            else if (y%2==0)y/=2;</span><br><span class="line">            else &#123;t=x;x=y;y=t-y;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void to_arr(char *c)&#123;</span><br><span class="line">        char *c1=c;</span><br><span class="line">        for (int i=0;i&lt;len-1;++i)</span><br><span class="line">            for (value x=a[i],b=base/10;b&gt;=1;b/=10)*c1++=&#x27;0&#x27;+x%10,x/=10;</span><br><span class="line">        for (value x=a[len-1];x&gt;0;x/=10)*c1++=&#x27;0&#x27;+x%10;</span><br><span class="line">        if (len==1&amp;&amp;a[len]==0)*c1++=&#x27;0&#x27;;</span><br><span class="line">        if (sign==0)*c1++=&#x27;-&#x27;;*c1=0;reverse(c,c1);</span><br><span class="line">    &#125;</span><br><span class="line">    void from_arr(char *c)&#123;</span><br><span class="line">        size_t base_l=get_basel(),b=1;int cl=strlen(c);value x=0;</span><br><span class="line">        New((cl+base_l-1)/base_l);len=0;</span><br><span class="line">        if (*c==&#x27;-&#x27;)sign=0,++c,--cl;else sign=1;</span><br><span class="line">        while (--cl&gt;=0)&#123;</span><br><span class="line">            x+=(c[cl]-&#x27;0&#x27;)*b;b*=10;if (b==base)a[len++]=x,x=0,b=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!lenx)a[len++]=x;</span><br><span class="line">        while (len&gt;1&amp;&amp;!a[len-1])--len;</span><br><span class="line">    &#125;</span><br><span class="line">    void set_base(int _base)&#123;</span><br><span class="line">        if (base==_base)return;</span><br><span class="line">        char *c=new char[len*get_basel()+1];</span><br><span class="line">        to_arr(c);base=_base;from_arr(c);</span><br><span class="line">        delete[] c;</span><br><span class="line">    &#125;</span><br><span class="line">    void set_basel(int _l)&#123;</span><br><span class="line">        size_t _base=1;while (_l--)_base*=10;set_base(_base);</span><br><span class="line">    &#125;</span><br><span class="line">    void read()&#123;</span><br><span class="line">        vector&lt;char&gt; s;char ch;</span><br><span class="line">        scanf(&quot; %c&quot;,&amp;ch);if (ch==&#x27;-&#x27;)s.push_back(&#x27;-&#x27;),ch=getchar();</span><br><span class="line">        for (;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar())s.push_back(ch);</span><br><span class="line">        char *c=new char[s.size()+1];</span><br><span class="line">        for (int i=0;i&lt;s.size();++i)c[i]=s[i];c[s.size()]=0;</span><br><span class="line">        from_arr(c);delete[] c;</span><br><span class="line">        if (!*this)this-&gt;sign=1;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()&#123;</span><br><span class="line">        if (!sign)putchar(&#x27;-&#x27;);</span><br><span class="line">        printf(&quot;%d&quot;,int(a[len-1]));</span><br><span class="line">        for (int i=len-2;i&gt;=0;--i)&#123;</span><br><span class="line">            for (int j=base/10;j&gt;=10;j/=10)</span><br><span class="line">                if (a[i]&lt;j)putchar(&#x27;0&#x27;);</span><br><span class="line">                    else break;</span><br><span class="line">            printf(&quot;%d&quot;,(int)a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void println()&#123;print();putchar(&#x27;\n&#x27;);&#125;</span><br><span class="line">    private:</span><br><span class="line">    value *a,base;int len;bool sign;  //0=&quot;-&quot;</span><br><span class="line">    size_t get_basel()const&#123;</span><br><span class="line">        size_t res=0;for (int b=base/10;b&gt;=1;b/=10,++res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    #undef BASE</span><br><span class="line">&#125;;</span><br><span class="line">Int num[N],Ans[N],top=1,ans;</span><br><span class="line">int n,m,k,len;</span><br><span class="line">string str;</span><br><span class="line">I Int fpow(int a,int b)&#123;Int A=a,s=1;W(b!=0)&#123;if(b%2==1) s*=A;A*=A;b=b/2;&#125;return s;&#125;//高精快速幂</span><br><span class="line">int main()&#123;</span><br><span class="line">    RI i,j,s;for(read(n,k),cin&gt;&gt;str,len=str.length(),i=5;i&lt;len;)</span><br><span class="line">        if(isdigit(str[i]))&#123;j=i+1;s=str[i]-&#x27;0&#x27;;W(j&lt;len&amp;&amp;isdigit(str[j])) s=s*10+str[j]-&#x27;0&#x27;,j++;top=s,i=j;&#125;//处理系数</span><br><span class="line">        else if(str[i]==&#x27;x&#x27;)&#123;j=i+1;s=0;W(j&lt;len&amp;&amp;str[j]!=&#x27;^&#x27;) ++j;j++;W(j&lt;len&amp;&amp;isdigit(str[j])) s=s*10+str[j]-&#x27;0&#x27;,++j;num[s]+=top;top=1;i=j;&#125;//处理次数</span><br><span class="line">        else i++;</span><br><span class="line">    for(i=0;i&lt;=n;i++)</span><br><span class="line">        if(i-k&gt;=0) for(Ans[i-k]=num[i],j=1;j&lt;=k;j++) Ans[i-k]*=i-j+1;//直接求导套公式</span><br><span class="line">    for(read(m);m--;)&#123;for(read(s),ans=j=0;j&lt;=n;j++) ans=ans+Ans[j]*fpow(s,j);ans.println();&#125;//对于每个询问直接暴力计算</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高精 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ1019 Number Sequence 题解</title>
      <link href="/2021/01/29/poj1019-number-sequence-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/01/29/poj1019-number-sequence-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="http://poj.org/problem?id=1019">题目链接</a></p></blockquote><p>给定一串有规律的数：11212312341234512345612345671234567812345678912345678910123456789101112345678910，问从左往右数第 $i$ 个数字是多少？</p><p>$1\leq i \leq 2147483647$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直接把这串数字分组：$1,12,123,1234,12345,123456\dots$</p><p>暴力打表求出每一组的数字的个数，对于每一个询问，只要先扫一遍，判断出是哪一组哪一个数字即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define Cn const</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">I int read()&#123;int x=0,f=1;char c;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);return x*f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">const int N=100010,sz=35000;</span><br><span class="line">int T,n,a[sz+10],sum[sz+10],pw[20];</span><br><span class="line">I void init()&#123;a[1]=sum[1]=pw[0]=1;for(int i=1;i&lt;=11;i++) pw[i]=pw[i-1]*10;for(int i=2;i&lt;=sz;i++) a[i]=a[i-1]+log10(i)+1,sum[i]=sum[i-1]+a[i];&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">init();T=read();W(T--)&#123;</span><br><span class="line">n=read();register int i=1;W(sum[i]&lt;n) i++;--i;</span><br><span class="line">int p=n-sum[i],j=0;for(i=1;j&lt;p;i++) j+=log10(i)+1;</span><br><span class="line">write((i-1)/pw[j-p]%10),pc(&#x27;\n&#x27;);</span><br><span class="line">&#125;return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 找规律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ1850 Code 题解</title>
      <link href="/2021/01/29/poj1850-code-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/01/29/poj1850-code-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="http://poj.org/problem?id=1850">题目链接</a></p></blockquote><p>将由小写字母组成的字符串按照以下条件排序：</p><ul><li>长度按升序排序</li><li>相同长度按字典序排序</li></ul><p>我们将这些字符串标上序号，问一字符串对应的序号是多少？</p><p>$1\leq len \leq 10$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很明显，这题也可以分两类组合起来。</p><ul><li>字符串长度为 $[1,len-1]$，这时可以通过组合数公式易知其数量。</li><li>字符串长度为 $len$，这是只要保证字符串是严格递增，并且不能超过输入的字符串即可。</li></ul><p>$$Ans&#x3D;\sum_{i&#x3D;1}^{i&lt;len}C_{26}^i+\sum_{i&#x3D;1}^{i&lt;&#x3D;n}\sum_{j&#x3D;s[i-1]+1}^{j&lt;s[i]} C_{‘z’-j}^{n-i}$$<br>注意处理下边界即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define Cn const</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I int read()&#123;int x=0,f=1;char c;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);return x*f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">const int N=55;</span><br><span class="line">int n,C[N][N],Ans;</span><br><span class="line">char s[N];</span><br><span class="line">I void init()&#123;</span><br><span class="line">for(int i=0;i&lt;=53;i++) C[i][0]=C[i][i]=1;</span><br><span class="line">for(int i=1;i&lt;=53;i++)</span><br><span class="line">for(int j=1;j&lt;i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();cin&gt;&gt;s+1;n=strlen(s+1);</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">if(s[i]&gt;s[i+1]) return puts(&quot;0&quot;),0;</span><br><span class="line">for(int i=1;i&lt;n;i++) Ans+=C[26][i];</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=i==1?&#x27;a&#x27;:s[i-1]+1;j&lt;s[i];j++) Ans+=C[&#x27;z&#x27;-j][n-i];</span><br><span class="line">return write(Ans+1),pc(&#x27;\n&#x27;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ3252 Round Numbers 题解</title>
      <link href="/2021/01/28/poj-round-numbers-%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/01/28/poj-round-numbers-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="http://poj.org/problem?id=3252">题目链接</a></p></blockquote><p>定义 Round Numbers 为在二进制下，0 的个数大于等于 1 的个数的数。</p><p>求范围内 Round Numbers 的个数。</p><p>$1 ≤ Start &lt; Finish ≤ 2,000,000,000 $</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然问题可以转化成求 $[1,N]$ 的 Round Numbers 的个数。</p><p>此时我们可以把 $N$ 转化成长度为 $m$ 的二进制数。</p><p>而 Round Numbers 的个数就由两部分组成：</p><ul><li>二进制数字长度为 $[0,m-1]$，此时直接组合数计算即可。</li><li>二进制数字长度为 $m$，此时要注意该二进制数字不能比 $N$ 本身大，需要处理一下边界。</li></ul><p>注意当二进制数字的长度确定时，其最高位<strong>不能</strong>为 $1$，所以算组合数的时候不能算进去。</p><p>$$Ans&#x3D;\sum_{i&#x3D;1}^{m-2}\sum_{j&#x3D;i&#x2F;2+1}^{j&lt;&#x3D;i}C_i^j+\sum_{i&#x3D;m-1}^{i&gt;&#x3D;1}\sum_{j&#x3D;(m+1)&#x2F;2-cnt-1}^{j&lt;i}C_{i-1}^j$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define Cn const</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">I int read()&#123;int x=0,f=1;char c;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);return x*f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">const int N=210;</span><br><span class="line">int A,B,C[N][N],a[N],cnt,m;</span><br><span class="line">I void Init()&#123;</span><br><span class="line">for(int i=0;i&lt;=100;i++) C[i][0]=C[i][i]=1;</span><br><span class="line">for(int i=1;i&lt;=100;i++)</span><br><span class="line">for(int j=1;j&lt;i;j++) C[i][j]=C[i-1][j]+C[i-1][j-1];</span><br><span class="line">&#125;</span><br><span class="line">I int Get(int x)&#123;</span><br><span class="line">cnt=m=0;W(x)&#123;a[++m]=x%2,x/=2;&#125;</span><br><span class="line">int Ans=0;for(int i=1;i&lt;m-1;i++)</span><br><span class="line">for(int j=i/2+1;j&lt;=i;j++) Ans+=C[i][j];</span><br><span class="line">for(int i=m-1;i&gt;=1;i--)</span><br><span class="line">if(a[i]) for(int j=(m+1)/2-cnt-1;j&lt;i;j++) Ans+=C[i-1][j];</span><br><span class="line">else cnt++;</span><br><span class="line">return Ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;return Init(),A=read(),B=read(),write(Get(B+1)-Get(A)),0;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 4491. 我也不知道题目名字是什么 题解</title>
      <link href="/2020/11/17/bzoj-4491-%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8D%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/11/17/bzoj-4491-%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8D%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote><p><a href="https://darkbzoj.tk/problem/4491">题目链接</a></p></blockquote><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个序列A[i]，每次询问l,r，求[l,r]内最长子串，使得该子串为不上升子串或不下降子串</p><p>N,Q&lt;&#x3D;50000</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $L[i]$ 表示以 $i$ 为起点，往左最多能成为子串的长度，$R[i]$ 表示以 $i$ 为起点，往右最多能成为子串的长度。</p><p>那么很显然区间 $[l,r]$ 答案就是 $\max\{R[l],R[l+1],\dots,R[r-L[r]],L[r]\}$（处理边界）</p><p>那么再套一个线段树就好了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">class FileInput&#123;</span><br><span class="line">private:</span><br><span class="line">#define FS 100000</span><br><span class="line">#define tc() (A==B&amp;&amp;(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)</span><br><span class="line">int f;char c,*A,*B,FI[FS];</span><br><span class="line">public:</span><br><span class="line">I FileInput()&#123;A=B=FI;&#125;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;x=0,f=1;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;));&#125;</span><br><span class="line">&#125;F;</span><br><span class="line">Cn int N=50010;</span><br><span class="line">int n,a[N],q,l,r,L[N],R[N],T[N],tr[N];</span><br><span class="line">I void build(int x,int l,int r)&#123;</span><br><span class="line">if(l==r) return void(tr[x]=R[l]);</span><br><span class="line">int mid=l+r&gt;&gt;1;</span><br><span class="line">build(x&lt;&lt;1,l,mid),build(x&lt;&lt;11,mid+1,r);</span><br><span class="line">tr[x]=max(tr[x&lt;&lt;1],tr[x&lt;&lt;11]);</span><br><span class="line">&#125;</span><br><span class="line">I int query(int x,int l,int r,int L,int R)&#123;</span><br><span class="line">if(L&lt;=l&amp;&amp;r&lt;=R) return tr[x];</span><br><span class="line">int mid=l+r&gt;&gt;1,res=0;</span><br><span class="line">if(L&lt;=mid) res=max(res,query(x&lt;&lt;1,l,mid,L,R));</span><br><span class="line">if(R&gt;mid) res=max(res,query(x&lt;&lt;11,mid+1,r,L,R));</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">F.read(n);for(int i=1;i&lt;=n;i++) F.read(a[i]);</span><br><span class="line">for(int i=1;i&lt;=n;i++) T[i]=(a[i-1]&lt;=a[i])*T[i-1]+1,L[i]=max(L[i],T[i]);</span><br><span class="line">for(int i=1;i&lt;=n;i++) T[i]=(a[i-1]&gt;=a[i])*T[i-1]+1,L[i]=max(L[i],T[i]);</span><br><span class="line">for(int i=n;i&gt;=1;i--) T[i]=(a[i+1]&lt;=a[i])*T[i+1]+1,R[i]=max(R[i],T[i]);</span><br><span class="line">for(int i=n;i&gt;=1;i--) T[i]=(a[i+1]&gt;=a[i])*T[i+1]+1,R[i]=max(R[i],T[i]);</span><br><span class="line">build(1,1,n);F.read(q);for(int l,r;q--;)&#123;</span><br><span class="line">F.read(l),F.read(r);</span><br><span class="line">if(L[r]&gt;=r-l+1) F.write(r-l+1);</span><br><span class="line">else F.write(max(L[r],query(1,1,n,l,r-L[r])));</span><br><span class="line">pc(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4088 [USACO18FEB]Slingshot P 题解</title>
      <link href="/2020/11/03/luogu-p4088-usaco18febslingshot-p-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/11/03/luogu-p4088-usaco18febslingshot-p-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4088">题目链接</a></p></blockquote><p>rua!调了半天发现原来是 $id$ 的问题。。。</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有一个数轴，上面有 $n$ 个传送门，使用第 $i$ 个传送门，你可以从 $x_i$​ 走到 $y_i$​，花费的时间为 $t_i$ 秒。你的速度为 $1$ 格&#x2F;秒，有 $m$ 次询问，每次你要从 $a_i$​ 走到 $b_i$​，最多使用一次传送门，问最少需要多少秒。</p><p>$1\leq n ,m \leq 10^5 ,0 \leq a_i ,b_i \leq 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，对于第 $j$ 个询问使用第 $i$ 个传送门，需要 $x_i -a_j +y_i - b_j+t_i$ 秒的时间。</p><p>考虑这个绝对值很像曼哈顿距离，于是可以把这道题转化：</p><p>平面上有 $n$ 个点，第 $i$ 个点位于 $(x_i,y_i)$，有点权为 $t_i$。有 $m$ 次询问，要求与 $(a_i,b_i)$ 的曼哈顿距离加上点权最小的点。</p><p>所以直接二维数点，暴力将绝对值拆开，分四类讨论即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Problem: P4088 [USACO18FEB]Slingshot P</span><br><span class="line">// Contest: Luogu</span><br><span class="line">// URL: https://www.luogu.com.cn/problem/P4088</span><br><span class="line">// Memory Limit: 125 MB</span><br><span class="line">// Time Limit: 1000 ms</span><br><span class="line">// Powered by CP Editor (https://github.com/cpeditor/cpeditor)</span><br><span class="line"></span><br><span class="line">// Auther: yzxoi</span><br><span class="line">// Site: yzxoi.top </span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define Tp template&lt;typename Ty&gt;</span><br><span class="line">#define Ts template&lt;typename Ty,typename... Ar&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define RI register int</span><br><span class="line">#define LL long long</span><br><span class="line">#define Cn const</span><br><span class="line">#define gc getchar</span><br><span class="line">#define D isdigit(c=gc())</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">using namespace std;</span><br><span class="line">namespace Debug&#123;</span><br><span class="line">Tp I void _debug(Cn char* f,Ty t)&#123;cerr&lt;&lt;f&lt;&lt;&#x27;=&#x27;&lt;&lt;t&lt;&lt;endl;&#125;</span><br><span class="line">Ts I void _debug(Cn char* f,Ty x,Ar... y)&#123;W(*f!=&#x27;,&#x27;) cerr&lt;&lt;*f++;cerr&lt;&lt;&#x27;=&#x27;&lt;&lt;x&lt;&lt;&quot;,&quot;;_debug(f+1,y...);&#125;</span><br><span class="line">Tp ostream&amp; operator&lt;&lt;(ostream&amp; os,Cn vector&lt;Ty&gt;&amp; V)&#123;os&lt;&lt;&quot;[&quot;;for(Cn auto&amp; vv:V) os&lt;&lt;vv&lt;&lt;&quot;,&quot;;os&lt;&lt;&quot;]&quot;;return os;&#125;</span><br><span class="line">#define gdb(...) _debug(#__VA_ARGS__,__VA_ARGS__)</span><br><span class="line">&#125;</span><br><span class="line">using namespace Debug;</span><br><span class="line">namespace FastIO&#123;</span><br><span class="line">Tp I void read(Ty&amp; x)&#123;char c;int f=1;x=0;W(!D) f=c^&#x27;-&#x27;?1:-1;W(x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),D);x*=f;&#125;</span><br><span class="line">Ts I void read(Ty&amp; x,Ar&amp;... y)&#123;read(x),read(y...);&#125;</span><br><span class="line">Tp I void write(Ty x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">Tp I void writeln(Cn Ty&amp; x)&#123;write(x),pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace FastIO;</span><br><span class="line">Cn int N=100010;</span><br><span class="line">int n,m,lsh[2][N&lt;&lt;1];</span><br><span class="line">LL tr[N&lt;&lt;4],Ans[N&lt;&lt;1];</span><br><span class="line">struct node&#123;int x,y,t,id;&#125;a[N&lt;&lt;1];</span><br><span class="line">I int cmp(Cn node&amp; x,Cn node&amp; y)&#123;return x.x&lt;y.x(x.x==y.x&amp;&amp;x.y&lt;y.y);&#125;</span><br><span class="line">I void update(int x,int l,int r,int pos,LL v)&#123;</span><br><span class="line">if(l==r) return void(tr[x]=min(tr[x],v));</span><br><span class="line">int mid=l+r&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) update(x&lt;&lt;1,l,mid,pos,v);</span><br><span class="line">else update(x&lt;&lt;11,mid+1,r,pos,v);</span><br><span class="line">tr[x]=min(tr[x&lt;&lt;1],tr[x&lt;&lt;11]);</span><br><span class="line">&#125;</span><br><span class="line">I LL query(int x,int l,int r,int L,int R)&#123;</span><br><span class="line">if(L&lt;=l&amp;&amp;r&lt;=R) return tr[x];</span><br><span class="line">int mid=l+r&gt;&gt;1;LL res=2e18;</span><br><span class="line">if(L&lt;=mid) res=min(res,query(x&lt;&lt;1,l,mid,L,R));</span><br><span class="line">if(R&gt;mid) res=min(res,query(x&lt;&lt;11,mid+1,r,L,R));</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">read(n,m);for(RI i=1;i&lt;=n;i++) a[i].id=-1,read(a[i].x,a[i].y,a[i].t),lsh[0][++lsh[0][0]]=a[i].x,lsh[1][++lsh[1][0]]=a[i].y;</span><br><span class="line">for(RI i=n+1;i&lt;=m+n;i++) a[i].id=i-n,read(a[i].x,a[i].y),Ans[a[i].id]=abs(a[i].x-a[i].y),lsh[0][++lsh[0][0]]=a[i].x,lsh[1][++lsh[1][0]]=a[i].y;</span><br><span class="line">for(RI i=0;i&lt;2;i++) sort(lsh[i]+1,lsh[i]+1+lsh[i][0]),lsh[i][0]=unique(lsh[i]+1,lsh[i]+1+lsh[i][0])-lsh[i]-1;</span><br><span class="line">for(RI i=1;i&lt;=m+n;i++) a[i].x=lower_bound(lsh[0]+1,lsh[0]+1+lsh[0][0],a[i].x)-lsh[0],a[i].y=lower_bound(lsh[1]+1,lsh[1]+1+lsh[1][0],a[i].y)-lsh[1];</span><br><span class="line">sort(a+1,a+m+n+1,cmp);</span><br><span class="line">memset(tr,127,sizeof(tr));for(RI t,i=1;i&lt;=m+n;i++)</span><br><span class="line">if(~a[i].id) Ans[a[i].id]=min(Ans[a[i].id],query(1,1,n+m,1,a[i].y)+lsh[0][a[i].x]+lsh[1][a[i].y]);</span><br><span class="line">else update(1,1,n+m,a[i].y,-lsh[0][a[i].x]-lsh[1][a[i].y]+a[i].t);</span><br><span class="line">memset(tr,127,sizeof(tr));for(RI i=m+n;i&gt;=1;i--)</span><br><span class="line">if(~a[i].id) Ans[a[i].id]=min(Ans[a[i].id],query(1,1,n+m,a[i].y,n+m)-lsh[0][a[i].x]-lsh[1][a[i].y]);</span><br><span class="line">else update(1,1,n+m,a[i].y,lsh[0][a[i].x]+lsh[1][a[i].y]+a[i].t);</span><br><span class="line">memset(tr,127,sizeof(tr));for(RI i=1;i&lt;=m+n;i++)</span><br><span class="line">if(~a[i].id) Ans[a[i].id]=min(Ans[a[i].id],query(1,1,n+m,a[i].y,n+m)+lsh[0][a[i].x]-lsh[1][a[i].y]);</span><br><span class="line">else update(1,1,n+m,a[i].y,-lsh[0][a[i].x]+lsh[1][a[i].y]+a[i].t);</span><br><span class="line">memset(tr,127,sizeof(tr));for(RI i=m+n;i&gt;=1;i--)</span><br><span class="line">if(~a[i].id) Ans[a[i].id]=min(Ans[a[i].id],query(1,1,n+m,1,a[i].y)-lsh[0][a[i].x]+lsh[1][a[i].y]);</span><br><span class="line">else update(1,1,n+m,a[i].y,lsh[0][a[i].x]-lsh[1][a[i].y]+a[i].t);</span><br><span class="line">for(RI i=1;i&lt;=m;i++) writeln(Ans[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二维数点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1225 黑白棋游戏 题解</title>
      <link href="/2020/10/27/luogu-p1225-%E9%BB%91%E7%99%BD%E6%A3%8B%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/10/27/luogu-p1225-%E9%BB%91%E7%99%BD%E6%A3%8B%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p><a href="https://www.luogu.com.cn/problem/P1225">题目链接</a></p><p>这题真的恶心，状压写错了调半天。。。</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个 $4\times 4$ 的棋盘，每一格放一个棋子，共有 $8$ 个黑棋，$8$ 个白棋。每次可以交换相邻两个格子的棋子，问最少要多少步才能从初始状态到达最终状态。并且需要输出交换方法。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于棋盘十分小（只有 $4\times 4$ ），所以考虑食用 $bfs$。</p><p>这道题主要问题是状态如何考虑。</p><p>由于只有黑棋和白棋，所以很自然的就想到了状压的思想。</p><p>我们可以考虑将整个棋盘直接状压成一个 $16$ 位二进制数，再进行 $bfs$ 转移。</p><blockquote><p>$2^0$ $2^1$ $2^2$ $2^3$<br>$2^4$ $2^5$ $2^6$ $2^7$<br>$2^8$ $2^9$ $2^{10}$ $2^{11}$<br>$2^{12}$ $2^{13}$ $2^{14}$ $2^{15}$</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">    for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">        char c=gc();W(c!=&#x27;0&#x27;&amp;&amp;c!=&#x27;1&#x27;) c=gc();</span><br><span class="line">        S=(c&amp;15)&lt;&lt;i*4+j;//直接状压</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么在 $bfs$ 的时候，只需要根据这个状压方法提取出需要交换的两位，并且暴力交换后再压回去即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I int v(int p,int x,int y)&#123;return p&gt;&gt;x*4+y&amp;1;&#125;//获取该状态下的该位置权值</span><br><span class="line">I int swp(int p,int x,int y,int xx,int yy)&#123;</span><br><span class="line">    int v1=v(p,x,y),v2=v(p,xx,yy);//获取这两位的权值</span><br><span class="line">    p&amp;=((1&lt;&lt;16)-1)^1&lt;&lt;x*4+y,p&amp;=((1&lt;&lt;16)-1)^1&lt;&lt;xx*4+yy,//把该状态下的这两位清空</span><br><span class="line">    p=v2&lt;&lt;x*4+y,p=v1&lt;&lt;xx*4+yy;//赋值</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在 $bfs$ 的过程中，记录一下父亲及路径即可，最后递归输出。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// Problem: P1225 黑白棋游戏</span><br><span class="line">// Contest: Luogu</span><br><span class="line">// URL: https://www.luogu.com.cn/problem/P1225</span><br><span class="line">// Memory Limit: 125 MB</span><br><span class="line">// Time Limit: 1000 ms</span><br><span class="line"></span><br><span class="line">// Auther: yzxoi</span><br><span class="line">// Site: yzxoi.top </span><br><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define LL long long</span><br><span class="line">#define gc getchar</span><br><span class="line">#define ig(c) (&#x27;0&#x27;&lt;=(c)&amp;&amp;(c)&lt;=&#x27;9&#x27;)</span><br><span class="line">#define pc(c) putchar((c))</span><br><span class="line">#define min(x,y) ((x)&lt;(y)?(x):(y))</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">I int read()&#123;int x=0,f=1;char c=gc();W(!ig(c)) f=c==&#x27;-&#x27;?-1:f,c=gc();W(ig(c)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),c=gc();return x*f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(pc(&#x27;-&#x27;),x=-x,0),x&lt;10?(pc(x+&#x27;0&#x27;),0):(write(x/10),pc(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">const int N=114514;</span><br><span class="line">const int dx[]=&#123;0,0,1,-1&#125;,</span><br><span class="line">          dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int S,T,dis[N],vis[N],pre[N];</span><br><span class="line">struct node&#123;int x,y,xx,yy;&#125;pp[N];</span><br><span class="line">std::queue&lt;int&gt; q;</span><br><span class="line">I int v(int p,int x,int y)&#123;return p&gt;&gt;x*4+y&amp;1;&#125;</span><br><span class="line">I int swp(int p,int x,int y,int xx,int yy)&#123;int v1=v(p,x,y),v2=v(p,xx,yy);p&amp;=((1&lt;&lt;16)-1)^1&lt;&lt;x*4+y,p&amp;=((1&lt;&lt;16)-1)^1&lt;&lt;xx*4+yy,p=v2&lt;&lt;x*4+y,p=v1&lt;&lt;xx*4+yy;return p;&#125;</span><br><span class="line">I void print(int p)&#123;</span><br><span class="line">    for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;,p&gt;&gt;i*4+j&amp;1);</span><br><span class="line">        &#125;</span><br><span class="line">        pc(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void bfs(int x)&#123;</span><br><span class="line">    W(!q.empty()) q.pop();</span><br><span class="line">    q.push(x);</span><br><span class="line">    memset(dis,63,sizeof(dis));</span><br><span class="line">    dis[x]=0;</span><br><span class="line">    W(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">            for(int j=0;j&lt;4;j++)</span><br><span class="line">                for(int k=0;k&lt;4;k++)&#123;</span><br><span class="line">                    int xx=i+dx[k],yy=j+dy[k],p;</span><br><span class="line">                    if(xx&gt;=0&amp;&amp;xx&lt;4&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;4&amp;&amp;v(u,i,j)^v(u,xx,yy)) dis[p=swp(u,i,j,xx,yy)]&gt;dis[u]+1&amp;&amp;(dis[p]=dis[u]+1,pre[p]=u,pp[p]=(node)&#123;i,j,xx,yy&#125;,!vis[p]&amp;&amp;(vis[p]=1,q.push(p),0),0);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">I void printpre(int x)&#123;</span><br><span class="line">    if(pre[x]) printpre(pre[x]);</span><br><span class="line">    else return ;</span><br><span class="line">    write(pp[x].x+1),write(pp[x].y+1),write(pp[x].xx+1),write(pp[x].yy+1),pc(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">        for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">            char c=gc();W(c!=&#x27;0&#x27;&amp;&amp;c!=&#x27;1&#x27;) c=gc();</span><br><span class="line">            S=(c&amp;15)&lt;&lt;i*4+j;</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">        for(int j=0;j&lt;4;j++)&#123;</span><br><span class="line">            char c=gc();W(c!=&#x27;0&#x27;&amp;&amp;c!=&#x27;1&#x27;) c=gc();</span><br><span class="line">            T=(c&amp;15)&lt;&lt;i*4+j;</span><br><span class="line">        &#125;</span><br><span class="line">    bfs(S);</span><br><span class="line">    write(dis[T]),pc(&#x27;\n&#x27;);</span><br><span class="line">    printpre(T);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1168 中位数 题解</title>
      <link href="/2020/10/24/luogu-p1168-%E4%B8%AD%E4%BD%8D%E6%95%B0-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/10/24/luogu-p1168-%E4%B8%AD%E4%BD%8D%E6%95%B0-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1168">题目链接</a></p></blockquote><p>给出一个长度为 $N$ 的非负整数序列 $A_i$，对于所有 $1 ≤ k ≤ (N + 1) &#x2F; 2$，输出 $A_1, A_1 \sim A_3, …,A_1 \sim A_{2k - 1}$ ​的中位数。即前 $1,3,5,…$ 个数的中位数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>众所周知，$vector$ 可以当平衡树来用。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int N=100010;</span><br><span class="line">int n,a[N];</span><br><span class="line">std::vector&lt;int&gt; v;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">v.insert(lower_bound(v.begin(),v.end(),a[i]),a[i]);</span><br><span class="line">if(i&amp;1) printf(&quot;%d\n&quot;,v[i/2]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 2006. [NOI2010]超级钢琴 题解</title>
      <link href="/2020/10/15/bzoj-2006-noi2010%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/10/15/bzoj-2006-noi2010%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://darkbzoj.tk/problem/2006">题目链接</a></p></blockquote><p>给定一个长度为 $n$ 的序列，选出 $k$ 个长度在 $[L,R]$ 之间的子段（不可重复），求 $k$ 个子段和的最大值。</p><p>$N\leq 500,000,k\leq 500,000,-1000\leq A_i \leq 1000,1\leq L\leq R\leq N$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由于 $n$ 十分巨大，我们不可能把所有符合条件的子段都列举出来再比较她们的大小，由于 $k$ 比较小，于是我们需要考虑如何贪心选择最大满足的子段，选择 $k$ 次即是答案。</p><p>定义 $f(i,l,r)$ 表示以 $i$ 为右端点，左端点在 $[L,R]$ 区间内的最大子段和，${sum}_i$ 表示前缀和。那么显然可知：</p><p>$$f(i,l,r)&#x3D;\max\</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3237 [HNOI2014]米特运输 题解</title>
      <link href="/2020/10/12/luogu-p3237-hnoi2014%E7%B1%B3%E7%89%B9%E8%BF%90%E8%BE%93-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/10/12/luogu-p3237-hnoi2014%E7%B1%B3%E7%89%B9%E8%BF%90%E8%BE%93-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3237">题目链接</a></p></blockquote><p>又臭又长的题面差评</p><p>给定一棵树，该树满足一定的性质：</p><ol><li>节点 $x$ 的所有子节点权值必须相等</li><li>节点 $x$ 的所有子节点的权值之和等于 $x$ 的权值</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设第 $x$ 个节点的权值为 $v$，它有 $sz[x]$ 个直系子节点，显然，这 $sz[x]$ 个直系子节点的权值均为 $\frac{v}{sz[x]}$。</p><p>考虑设 $f[i]$ 表示第 $i$ 个节点不修改时的根节点的权值。</p><p>显然可得根节点的权值为：</p><p>$$ v[i] \times \prod sz[x] (x \in {fa}_v)$$</p><p>那么只要计算出 $1$ 到 $n$ 的 $f[i]$，判断相等个数即可。</p><p>由于乘法可能会爆 $long$ $long$，所以开个 $map$ 并 $mod$ 一下。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">#define max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="line">#define W while</span><br><span class="line">#define I inline</span><br><span class="line">#define ig(c) (&#x27;0&#x27;&lt;=(c)&amp;&amp;(c)&lt;=&#x27;9&#x27;)</span><br><span class="line">#define gc getchar</span><br><span class="line">I int read()&#123;int x=0,f=1;char c=gc();W(!ig(c)) f=c==&#x27;-&#x27;?-1:f,c=gc();W(ig(c)) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c&amp;15),c=gc();return x*f;&#125;</span><br><span class="line">I void write(int x)&#123;x&lt;0&amp;&amp;(putchar(&#x27;-&#x27;),x=-x,0),x&lt;10?(putchar(x+&#x27;0&#x27;),0):(write(x/10),putchar(x%10+&#x27;0&#x27;),0);&#125;</span><br><span class="line">const int N=500010,mod=19260817;</span><br><span class="line">int n,a[N],f[N],ans;</span><br><span class="line">std::vector&lt;int&gt; v[N];</span><br><span class="line">std::map&lt;int,int&gt; mp;</span><br><span class="line">I void dfs(int x,int fa,int sum)&#123;</span><br><span class="line">int s=0;for(auto i:v[x]) (i^fa)&amp;&amp;(s++,0);</span><br><span class="line">++mp[(int)(1ll*sum*a[x]%mod)];</span><br><span class="line">ans=max(ans,mp[(int)(1ll*sum*a[x]%mod)]);</span><br><span class="line">sum=1ll*sum*s%mod;</span><br><span class="line">for(auto i:v[x]) (i^fa)&amp;&amp;(dfs(i,x,sum),0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read();for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">for(int x,y,i=1;i&lt;n;i++) x=read(),y=read(),v[x].push_back(y),v[y].push_back(x);</span><br><span class="line">mp.clear();dfs(1,0,1ll);</span><br><span class="line">return write(n-ans),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3203 [HNOI2010]弹飞绵羊 题解</title>
      <link href="/2020/09/27/luogu-p3203-hnoi2010%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/09/27/luogu-p3203-hnoi2010%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3203">题目链接</a></p></blockquote><p>某天，Lostmonkey 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。</p><p>游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$​，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$​ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$​ 个装置，则绵羊被弹飞。</p><p>绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>构建一个虚点 $n+1$，如果绵羊会被弹飞就直接连一条边 $(x,n+1)$，否则直接连向下一个点 $(x,x+a[x])$。</p><p>针对每个询问操作，只需要查询下 $n+1$ 的子树大小即可，直接 $split(x,n+1)$，输出 $tr[n+1].sz-1$ 即可(不包括 $n+1$ 这个节点)。</p><p>针对每个修改操作，只需要把原先的那条边断掉再重新按照上述方法连一条新边即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#define N 200010</span><br><span class="line">#define min(x,y) ((x)&gt;(y)?(y):(x))</span><br><span class="line">#define ls tr[x].ch[0]</span><br><span class="line">#define rs tr[x].ch[1]</span><br><span class="line">int n,m,a[N];</span><br><span class="line">struct node&#123;int fa,ch[2],sz,tag;&#125;tr[N];</span><br><span class="line">inline int get(int x)&#123;return (tr[tr[x].fa].ch[0]==x?0:(tr[tr[x].fa].ch[1]==x?1:-1));&#125;</span><br><span class="line">inline void add(int x,int y,int k)&#123;tr[x].fa=y,(~k&amp;&amp;(tr[y].ch[k]=x,0));&#125;</span><br><span class="line">inline void pushup(int x)&#123;tr[x].sz=tr[ls].sz+tr[rs].sz+1;&#125;</span><br><span class="line">inline void pushdown(int x)&#123;if(!tr[x].tag) return ;ls^=rs^=ls^=rs;tr[ls].tag^=1,tr[rs].tag^=1,tr[x].tag=0;&#125;</span><br><span class="line">inline void pushall(int x)&#123;if(~get(x)) pushall(tr[x].fa);pushdown(x);&#125;</span><br><span class="line">inline void rotate(int x)&#123;int y=tr[x].fa,z=tr[y].fa,kx=get(x),ky=get(y);add(tr[x].ch[kx^1],y,kx),add(y,x,kx^1),add(x,z,ky),pushup(y),pushup(x);&#125;</span><br><span class="line">inline void splay(int x)&#123;pushall(x);while(~get(x))&#123;if(~get(tr[x].fa)) rotate(get(x)^get(tr[x].fa)?x:tr[x].fa);rotate(x);&#125;&#125;</span><br><span class="line">inline void access(int x)&#123;for(int y=0;x;x=tr[y=x].fa) splay(x),rs=y,pushup(x);&#125;</span><br><span class="line">inline void makeroot(int x)&#123;access(x),splay(x),tr[x].tag^=1,pushdown(x);&#125;</span><br><span class="line">inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;</span><br><span class="line">inline int findroot(int x)&#123;access(x),splay(x);while(ls) pushdown(x),x=ls;splay(x);return x;&#125;</span><br><span class="line">inline void link(int x,int y)&#123;makeroot(x);tr[x].fa=y;&#125;</span><br><span class="line">inline void cut(int x,int y)&#123;split(x,y);tr[x].fa=tr[y].ch[0]=0,pushup(x);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n+1;i++) tr[i].sz=1;</span><br><span class="line">for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),link(i,min(i+a[i],n+1));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int op,x,y,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;op);</span><br><span class="line">if(op==1) scanf(&quot;%d&quot;,&amp;x),x++,split(x,n+1),printf(&quot;%d\n&quot;,tr[n+1].sz-1);</span><br><span class="line">else scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x++,cut(x,min(x+a[x],n+1)),link(x,min(x+y,n+1)),a[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3591 [POI2015]ODW 题解</title>
      <link href="/2020/09/24/luogu-p3591-poi2015odw-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/09/24/luogu-p3591-poi2015odw-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3591">题目链接</a></p></blockquote><p>给定一棵n个点的树，树上每条边的长度都为1，第i个点的权值为a[i]。Byteasar想要走遍这整棵树，他会按照某个1到n的全排列b走n-1次，第i次他会从b[i]点走到b[i+1]点，并且这一次的步伐大小为c[i]。对于一次行走，假设起点为x，终点为y，步伐为k，那么Byteasar会从x开始，每步往前走k步，如果最后不足k步就能到达y，那么他会一步走到y。请帮助Byteasar统计出每一次行走时经过的所有点的权值和。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设一个阈值$S&#x3D;\sqrt N$。</p><p>若$c\leq S$，则预处理出答案，前缀和一下即可。</p><p>若$c&gt;S$，则直接暴力跳。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#define S 225</span><br><span class="line">int n,a[50010],b[50010],c[50010],fir[50010],nxt[50010&lt;&lt;1],son[50010&lt;&lt;1],tot,sum[50010],dep[50010],f[50010][20],s[50010][233];</span><br><span class="line">inline void add(int x,int y)&#123;++tot,nxt[tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">inline void dfs0(int x)&#123;</span><br><span class="line">sum[x]+=a[x];</span><br><span class="line">for(int i=0;i&lt;16;i++) f[x][i+1]=f[f[x][i]][i];</span><br><span class="line">for(int to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">to=son[i];</span><br><span class="line">if(dep[to]) continue ;</span><br><span class="line">dep[to]=dep[x]+1;</span><br><span class="line">f[to][0]=x;</span><br><span class="line">sum[to]=sum[x];</span><br><span class="line">dfs0(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline int getlca(int x,int y)&#123;</span><br><span class="line">if(dep[x]&lt;dep[y]) x^=y^=x^=y;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];</span><br><span class="line">if(x==y) return x;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(f[x][i]^f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line">inline int getfa(int x,int d)&#123;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(d&gt;&gt;i&amp;1) x=f[x][i];</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">inline void dfs(int x)&#123;</span><br><span class="line">int fa=f[x][0];</span><br><span class="line">for(int i=2;i&lt;=S;i++) fa=f[fa][0],s[x][i]=s[fa][i]+a[x];</span><br><span class="line">for(int to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">to=son[i];</span><br><span class="line">if(dep[x]&lt;dep[to]) dfs(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">for(int x,y,i=1;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">for(int i=1;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;c[i]);</span><br><span class="line">dep[1]=1;dfs0(1);</span><br><span class="line">dfs(1);</span><br><span class="line">for(int x,y,k,lca,i=1;i&lt;n;i++)&#123;</span><br><span class="line">x=b[i],y=b[i+1],k=c[i],lca=getlca(x,y);</span><br><span class="line">if(k==1) printf(&quot;%d\n&quot;,sum[x]+sum[y]-sum[lca]-sum[f[lca][0]]);</span><br><span class="line">else if(k&lt;=S)&#123;</span><br><span class="line">int Ans=s[x][k],d=(dep[x]-dep[lca])%k==0?k:(dep[x]-dep[lca])%k;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(dep[f[x][i]]-dep[lca]&gt;=d) x=f[x][i];</span><br><span class="line">Ans+=a[x]-s[x][k];</span><br><span class="line">if(dep[x]+dep[y]-(dep[lca]&lt;&lt;1)&gt;=k)&#123;</span><br><span class="line">d=k-dep[x]+dep[lca];</span><br><span class="line">x=y;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(dep[f[x][i]]-dep[lca]&gt;=d) x=f[x][i];</span><br><span class="line">d=(dep[y]-dep[x])%k;</span><br><span class="line">if(d) Ans+=a[y];</span><br><span class="line">y=getfa(y,d);</span><br><span class="line">Ans+=s[y][k]-s[x][k]+a[x];</span><br><span class="line">&#125;else Ans+=a[y];</span><br><span class="line">printf(&quot;%d\n&quot;,Ans);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">int Ans=0;</span><br><span class="line">while(dep[x]-dep[lca]&gt;k) Ans+=a[x],x=getfa(x,k);</span><br><span class="line">Ans+=a[x];</span><br><span class="line">if(dep[x]+dep[y]-(dep[lca]&lt;&lt;1)&gt;=k)&#123;</span><br><span class="line">int d=k-dep[x]+dep[lca];</span><br><span class="line">x=y;</span><br><span class="line">for(int i=16;~i;i--)</span><br><span class="line">if(dep[f[x][i]]-dep[lca]&gt;=d) x=f[x][i];</span><br><span class="line">d=(dep[y]-dep[x])%k;</span><br><span class="line">if(d) Ans+=a[y];</span><br><span class="line">y=getfa(y,d);</span><br><span class="line">while(dep[y]-dep[x]&gt;=k) Ans+=a[y],y=getfa(y,k);</span><br><span class="line">Ans+=a[y];</span><br><span class="line">&#125;else Ans+=a[y];</span><br><span class="line">printf(&quot;%d\n&quot;,Ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4772 灰化肥，会挥发 题解</title>
      <link href="/2020/09/17/luogu-p4772-%E7%81%B0%E5%8C%96%E8%82%A5%EF%BC%8C%E4%BC%9A%E6%8C%A5%E5%8F%91-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/09/17/luogu-p4772-%E7%81%B0%E5%8C%96%E8%82%A5%EF%BC%8C%E4%BC%9A%E6%8C%A5%E5%8F%91-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>在Farmer Justin的农场中有许多灰化肥，它们都堆积在A仓库里。为了方便施肥，Farmer Justin需要修一些公路使得他能用拖拉机把这些灰化肥拉到其他仓库里。由于Farmer Justin及其懒惰，所以他只想一次拉完所有的灰化肥送到其他仓库里。但是灰化肥见光易挥发，所以Farmer Justin需要尽快把这些灰化肥拉完。现在告诉你Farmer Justin农场的构成地图，请你帮帮他计划一条<strong>从A仓库出发</strong>走完所有仓库的方案吧！由于Farmer Justin非常的讨厌浪费时间，所以你只需要告诉他最短的距离和走过所有农场的顺序。(注意:拖拉机走的时候是四联通的。)</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>状压DP+BFS</p><p>首先先暴力BFS跑出任意两个点之间的距离。</p><p>然后考虑DP，设$dp[i][j]$表示当前已经遍历过的点状态为$i$，最后一个遍历的点为$j$的最小值。</p><p>很明显：</p><p>$$dp[i][j]&#x3D;dp[i\oplus (1&lt;&lt;k-1)][k]+cost[k][j](i\&amp;(1&lt;&lt;k-1)!&#x3D;0)$$</p><p>又因为要记录路径，于是开一个数组$g$与$dp$类似，更新的过程中记录下路径即可。</p><p>注意要开long long。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int dx[]=&#123;0,0,1,-1&#125;,</span><br><span class="line">          dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">int r,c,n,cost[20][20],dis[510][510],Min,f[1&lt;&lt;16][16];</span><br><span class="line">char a[510][510];</span><br><span class="line">string Ans,g[1&lt;&lt;16][16];</span><br><span class="line">struct node&#123;int x,y;&#125;G[20];</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">inline void bfs(int x)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">while(!q.empty()) q.pop();</span><br><span class="line">q.push(G[x]);dis[G[x].x][G[x].y]=1;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">node u=q.front();q.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=u.x+dx[i],yy=u.y+dy[i];</span><br><span class="line">if(xx&gt;=1&amp;&amp;xx&lt;=r&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=c&amp;&amp;a[xx][yy]!=&#x27;*&#x27;&amp;&amp;!dis[xx][yy])&#123;</span><br><span class="line">dis[xx][yy]=dis[u.x][u.y]+1;</span><br><span class="line">q.push((node)&#123;xx,yy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">scanf(&quot;%lld%lld%lld&quot;,&amp;r,&amp;c,&amp;n);</span><br><span class="line">for(int i=1;i&lt;=r;i++) cin&gt;&gt;a[i]+1;</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">if(&#x27;A&#x27;&lt;=a[i][j]&amp;&amp;a[i][j]&lt;=&#x27;Z&#x27;) G[a[i][j]-&#x27;A&#x27;+1]=(node)&#123;i,j&#125;;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">bfs(i);</span><br><span class="line">for(int j=1;j&lt;=n;j++) cost[i][j]=dis[G[j].x][G[j].y]-1;</span><br><span class="line">&#125;</span><br><span class="line">memset(f,63,sizeof(f));</span><br><span class="line">f[1][1]=0;</span><br><span class="line">g[1][1]=&#x27;A&#x27;;</span><br><span class="line">for(int i=2;i&lt;(1&lt;&lt;n);i++)&#123;</span><br><span class="line">if(!(i&amp;1)) continue ;</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(!(i&amp;(1&lt;&lt;j-1))) continue ;</span><br><span class="line">for(int k=2;k&lt;=n;k++)&#123;</span><br><span class="line">if(!(i&amp;(1&lt;&lt;k-1))j==k) continue ;</span><br><span class="line">if(f[i][k]&gt;f[i^(1&lt;&lt;k-1)][j]+cost[j][k]) f[i][k]=f[i^(1&lt;&lt;k-1)][j]+cost[j][k],g[i][k]=g[i^(1&lt;&lt;k-1)][j]+char(k+&#x27;A&#x27;-1);</span><br><span class="line">else if(f[i][k]==f[i^(1&lt;&lt;k-1)][j]+cost[j][k]&amp;&amp;g[i][k]&gt;g[i^(1&lt;&lt;k-1)][j]+char(k+&#x27;A&#x27;-1)) g[i][k]=g[i^(1&lt;&lt;k-1)][j]+char(k+&#x27;A&#x27;-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Min=f[(1&lt;&lt;n)-1][2];Ans=g[(1&lt;&lt;n)-1][2];</span><br><span class="line">for(int i=3;i&lt;=n;i++)</span><br><span class="line">if(Min&gt;f[(1&lt;&lt;n)-1][i]) Min=f[(1&lt;&lt;n)-1][i],Ans=g[(1&lt;&lt;n)-1][i];</span><br><span class="line">else if(Min==f[(1&lt;&lt;n)-1][i]&amp;&amp;Ans&gt;g[(1&lt;&lt;n)-1][i]) Ans=g[(1&lt;&lt;n)-1][i];</span><br><span class="line">    return printf(&quot;%lld\n&quot;,Min),cout&lt;&lt;Ans&lt;&lt;endl,0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2493 [SDOI2011]贪食蛇 &amp; bzoj 2284. [Sdoi2011]贪食蛇 题解</title>
      <link href="/2020/08/22/luogu-p2493-sdoi2011%E8%B4%AA%E9%A3%9F%E8%9B%87-bzoj-2284-sdoi2011%E8%B4%AA%E9%A3%9F%E8%9B%87-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/22/luogu-p2493-sdoi2011%E8%B4%AA%E9%A3%9F%E8%9B%87-bzoj-2284-sdoi2011%E8%B4%AA%E9%A3%9F%E8%9B%87-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2493">题目链接Luogu</a> <a href="https://darkbzoj.tk/problem/2284">题目链接bzoj</a></p></blockquote><p>相信大家都玩过贪食蛇游戏，现在有一个改版贪食蛇游戏，跟传统的贪食蛇游戏一样，贪食蛇在活动区域内运动，吃食物，但是这个改版的贪食蛇游戏有着一些特别的规则。</p><h4 id="活动区域："><a href="#活动区域：" class="headerlink" title="活动区域："></a>活动区域：</h4><p>贪食蛇的活动区域是一个R行C列的网格A，贪食蛇活动不能超过这个网格的范围。第i行第j列的方格用Ai,j表示。每个方格有一个整数权值，记作w(Aij)。0&lt;&#x3D;w(Aij)&lt;&#x3D;8，w(Aij)&#x3D;0时，Aij禁止进入；w(Aij)&gt;0时，Aij允许进入。</p><h4 id="方向："><a href="#方向：" class="headerlink" title="方向："></a>方向：</h4><p>对于P&#x3D;(X0,Y0)、Q&#x3D;(X1,Y1)，有以下四种基本方向：</p><ul><li><p>正左(L)：X0&#x3D;X1且Y0&#x3D;Y1-1，则称P位于Q的正左方向。</p></li><li><p>正右(R)：X0&#x3D;X1且Y0&#x3D;Y1+1，则称P位于Q的正右方向。</p></li><li><p>正上(U)：X0&#x3D;X1-1且Y0&#x3D;Y1，则称P位于Q的正上方向。</p></li><li><p>正下(D)：X0&#x3D;X1+1且Y0&#x3D;Y1，则称P位于Q的正下方向。</p></li></ul><h4 id="贪食蛇："><a href="#贪食蛇：" class="headerlink" title="贪食蛇："></a>贪食蛇：</h4><p>贪食蛇B是占据若干方格的图形，占据的方格数为贪食蛇的长度，记为m，则贪食蛇从头到尾，用B1、B2、……、Bm表示。记p为贪食蛇的形态，若Bi位于第Xi行第Yi列，则p(Bi)&#x3D;(Xi,Yi)。初始情况下，m&#x3D;4，且运动过程中始终需要满足以下限制：</p><ul><li><p>对于Bi和Bi+1(1&lt;&#x3D;i&lt;m)，就是贪食蛇的前、后相邻两部分，必须满足Bi位于Bi+1的L、R、U、D四个方向之一。</p></li><li><p>对于Bi和Bj(1&lt;&#x3D;i&lt;j&lt;&#x3D;m)，p(Bi)&#x3D;(Xi,Yi)，p(Bj)&#x3D;(Xj,Yj)，需要满足Xi!&#x3D;Xj或Yi!&#x3D;Yj。也就是说，贪食蛇身体的任意一部分不能相交。</p></li></ul><h4 id="食物："><a href="#食物：" class="headerlink" title="食物："></a>食物：</h4><p>贪食蛇的活动区域内存在一些食物。每个食物位于一个允许进入的方格上，食物不会重叠。每个食物只能被吃一次。</p><h4 id="贪食蛇的运动："><a href="#贪食蛇的运动：" class="headerlink" title="贪食蛇的运动："></a>贪食蛇的运动：</h4><p>如果贪食蛇的头部B1的L、R、U、D四个方向之一的Aij能进入，且Aij上不存在食物，则贪食蛇可以向该方向运动，新的头部位于Aij上。记p’为贪食蛇新的形态，则：</p><ul><li><p>p’(Bk)&#x3D;p(Bk-1)，当2&lt;&#x3D;k&lt;&#x3D;m。</p></li><li><p>p’(Bk)&#x3D;(i,j)，当k&#x3D;1</p></li></ul><h4 id="贪食蛇的进食："><a href="#贪食蛇的进食：" class="headerlink" title="贪食蛇的进食："></a>贪食蛇的进食：</h4><p>如果贪食蛇的头部B1的L、R、U、D四个方向之一的Aij能进入，且Aij上存在食物，则贪食蛇可以向该方向进食，新的头部位于Aij上，蛇的新长度m’&#x3D;m+1。记p’为贪食蛇新的位置，则：</p><ul><li><p>p’(Bk)&#x3D;p(Bk-1)，当2&lt;&#x3D;k&lt;&#x3D;m’。</p></li><li><p>p’(Bk)&#x3D;(i,j)，当k&#x3D;1</p></li></ul><p>注意：运动或进食后的贪食蛇形态，仅仅需要考虑变换后的形态是否满足限制，不需要考虑变换的过程。也就是说，原来形态合法的贪食蛇的头部可以运动到尾部的位置，因为在变换后头部和尾部仍不会重叠。</p><h4 id="运动或进食所需要的时间："><a href="#运动或进食所需要的时间：" class="headerlink" title="运动或进食所需要的时间："></a>运动或进食所需要的时间：</h4><p>贪食蛇运动或进食，需要消耗时间。设运动或进食前头部所在的方格是P，运动或进食后头部所在的方格是Q，则此次运动或进食的所消耗的时间为w(P)-w(Q)+1。</p><p>游戏的会在开始前给出贪食蛇的初始位置和所有食物的位置。你的任务是，以最少的时间令贪食蛇吃完所有食物。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一句话题意：初始时有一条长度为$4$的贪吃蛇，每走一步需要时间为两格权值之差的绝对值，问最少的时间令贪吃蛇吃完所有的食物。</p><p>其中，食物数量$\leq 4$，矩阵长宽均$\leq 15$。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20170328162123959.png"></p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20170328162137710.png"></p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20170328162147781.png"></p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20170328162157866.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">const int dx[]=&#123;0,0,-1,1&#125;,</span><br><span class="line">          dy[]=&#123;-1,1,0,0&#125;;</span><br><span class="line">const char W[]=&#123;&#x27;L&#x27;,&#x27;R&#x27;,&#x27;U&#x27;,&#x27;D&#x27;&#125;;</span><br><span class="line">int n,m,w[17][17],snk[5][2],fd,g[17][17],HH,TT,S[1&lt;&lt;11][4],T[1&lt;&lt;11][4],Q[255*1200*16*8],pre[255*1200*16*8],Ans,AnsT,AnsN;</span><br><span class="line">char c,AnsP[17*17];</span><br><span class="line">unsigned long long vis[1&lt;&lt;23];</span><br><span class="line">inline int abs(int x)&#123;return x&lt;0?-x:x;&#125;</span><br><span class="line">inline void init()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">c=getchar();for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">while(!isdigit(c)) c=getchar();</span><br><span class="line">for(int j=1;j&lt;=m;j++) w[i][j]=c-&#x27;0&#x27;,c=getchar();</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=4;i++)</span><br><span class="line">for(int j=0;j&lt;=1;j++) snk[i][j]=read();</span><br><span class="line">fd=read();</span><br><span class="line">for(int x,y,i=1;i&lt;=fd;i++) x=read(),y=read(),g[x][y]=i;</span><br><span class="line">&#125;</span><br><span class="line">inline int get(int s,int len,int t)&#123;</span><br><span class="line">len+=4;t^=1;</span><br><span class="line">int x=dx[t],y=dy[t];</span><br><span class="line">for(int j=s,i=2;i&lt;len;i++,j&gt;&gt;=2)&#123;</span><br><span class="line">x+=dx[j&amp;3],y+=dy[j&amp;3];</span><br><span class="line">if(!x&amp;&amp;!y) return -1;</span><br><span class="line">&#125;</span><br><span class="line">return (s&lt;&lt;2&amp;((1&lt;&lt;((len-1)&lt;&lt;1))-1))t;</span><br><span class="line">&#125;</span><br><span class="line">inline int pos(int x,int y,int xx,int yy)&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">if(x+dx[i]==xx&amp;&amp;y+dy[i]==yy) return i;</span><br><span class="line">&#125;</span><br><span class="line">inline void load()&#123;</span><br><span class="line">memset(S,0xFF,sizeof(S));</span><br><span class="line">memset(T,0xFF,sizeof(T));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">HH=TT=0;</span><br><span class="line">int s=0;</span><br><span class="line">for(int i=4;i&gt;=2;i--)</span><br><span class="line">s=(s&lt;&lt;2)pos(snk[i-1][0],snk[i-1][1],snk[i][0],snk[i][1]);</span><br><span class="line">s&lt;&lt;=2;vis[s]=++TT;Q[TT]=s;</span><br><span class="line">while(HH&lt;TT)&#123;</span><br><span class="line">int u=Q[++HH];</span><br><span class="line">int del=u&gt;&gt;2,len=u&amp;3;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int nxt=get(del,len,i);</span><br><span class="line">if(nxt&lt;0) continue ;</span><br><span class="line">int s=(nxt&amp;((1&lt;&lt;12)-1))&lt;&lt;2len;</span><br><span class="line">if(!vis[s]) Q[++TT]=s,vis[s]=TT;</span><br><span class="line">S[HH][i]=vis[s];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int nxt=get(del,len+1,i);</span><br><span class="line">if(nxt&lt;0) continue ;</span><br><span class="line">if(len&lt;3)&#123;</span><br><span class="line">int s=(nxt&amp;((1&lt;&lt;12)-1))&lt;&lt;2(len+1);</span><br><span class="line">if(!vis[s]) Q[++TT]=s,vis[s]=TT;</span><br><span class="line">T[HH][i]=vis[s];</span><br><span class="line">&#125;else T[HH][i]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#define make_S(x,y,ss,tt,wt) ((x)&lt;&lt;22((y)&lt;&lt;18)(ss&lt;&lt;7)((tt)&lt;&lt;3)(wt))</span><br><span class="line">#define check(s,wt) (vis[(s)&gt;&gt;3]&amp;1&lt;&lt;(wt))</span><br><span class="line">inline void bfs()&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">HH=TT=0;</span><br><span class="line">Q[++TT]=make_S(snk[1][0],snk[1][1],1,(1&lt;&lt;fd)-1,0);</span><br><span class="line">vis[Q[TT]&gt;&gt;3]=1;</span><br><span class="line">while(HH&lt;TT)&#123;</span><br><span class="line">int u=Q[++HH];</span><br><span class="line">int x=u&gt;&gt;22&amp;((1&lt;&lt;4)-1),y=u&gt;&gt;18&amp;((1&lt;&lt;4)-1),sq=u&gt;&gt;7&amp;((1&lt;&lt;11)-1),t=u&gt;&gt;3&amp;((1&lt;&lt;4)-1),wt=u&amp;((1&lt;&lt;3)-1);</span><br><span class="line">if(!t&amp;&amp;!wt)&#123;Ans=HH;break ;&#125;</span><br><span class="line">if(wt)&#123;</span><br><span class="line">int s=make_S(x,y,sq,t,wt-1);</span><br><span class="line">if(!check(s,wt-1)) Q[++TT]=s,vis[s&gt;&gt;3]=1&lt;&lt;(wt-1),pre[TT]=HH;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+dx[i],yy=y+dy[i],ns=S[sq][i],nt=t,nwt=abs(w[xx][yy]-w[x][y]);</span><br><span class="line">if(!w[xx][yy]) continue ;</span><br><span class="line">if(g[xx][yy]&amp;&amp;t&amp;1&lt;&lt;(g[xx][yy]-1)) ns=T[sq][i],nt^=1&lt;&lt;(g[xx][yy]-1);</span><br><span class="line">else ns=S[sq][i];</span><br><span class="line">if(ns&lt;0) continue ;</span><br><span class="line">int s=make_S(xx,yy,ns,nt,nwt);</span><br><span class="line">if(!check(s,nwt))</span><br><span class="line">Q[++TT]=s,</span><br><span class="line">vis[s&gt;&gt;3]=1&lt;&lt;nwt,</span><br><span class="line">pre[TT]=HH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void solve()&#123;</span><br><span class="line">for(int p=Ans;p&gt;1;p=pre[p])&#123;</span><br><span class="line">++AnsT;</span><br><span class="line">int wt=Q[pre[p]]&amp;((1&lt;&lt;3)-1);</span><br><span class="line">if(wt) continue ;</span><br><span class="line">int x=Q[pre[p]]&gt;&gt;22&amp;((1&lt;&lt;4)-1),y=Q[pre[p]]&gt;&gt;18&amp;((1&lt;&lt;4)-1),xx=Q[p]&gt;&gt;22&amp;((1&lt;&lt;4)-1),yy=Q[p]&gt;&gt;18&amp;((1&lt;&lt;4)-1);</span><br><span class="line">AnsP[AnsN++]=W[pos(x,y,xx,yy)];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;(AnsN&gt;&gt;1);i++) swap(AnsP[i],AnsP[AnsN-i-1]);</span><br><span class="line">&#125;</span><br><span class="line">inline void print()&#123;</span><br><span class="line">if(!Ans)&#123;</span><br><span class="line">puts(&quot;No solution.&quot;);</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">write(AnsT);putchar(&#x27;\n&#x27;);</span><br><span class="line">for(int i=0;i&lt;AnsN;i++) putchar(AnsP[i]);putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;return init(),load(),bfs(),solve(),print(),0;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2446 [SDOI2010]大陆争霸 题解</title>
      <link href="/2020/08/21/luogu-p2446-sdoi2010%E5%A4%A7%E9%99%86%E4%BA%89%E9%9C%B8-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/21/luogu-p2446-sdoi2010%E5%A4%A7%E9%99%86%E4%BA%89%E9%9C%B8-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2446">题目链接</a></p></blockquote><p>$m$条单向边连接$n$个城市，通过每边要$w_i$​单位时间。从$1$开始，依次摧毁城市，<strong>仅仅摧毁不用时间</strong>，直到摧毁$n$结束。部分城市被别的城市保护，只有保护它的城市被摧毁后，才能摧毁这个城市。求结束的最短时间。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>把所有保护关系从保护者连向被保护者一条边，每一次遍历到一个点时，把所有与该点有关的被保护者都入读减一。那么当一个点的入读为$0$时，就代表这个点所有的保护均已摧毁，就可以遍历该点了。</p><p>我们记录一下每个点与之相关的所有保护均已摧毁的时间与到达该点的时间，最后取一个$max$就是可以进入该点的时间。</p><p>所以开心的跑$dijkstra$就好啦~</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">return res*f; </span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,in[3010],fir[3010],nxt[70010],son[70010],w[70010],tot,vis[3010],t[3010],g[3010],d[3010];</span><br><span class="line">vector&lt;int&gt; v[3010];</span><br><span class="line">inline void add(int x,int y,int z)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;&#125;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;</span><br><span class="line">inline void Dij()&#123;</span><br><span class="line">while(!q.empty()) q.pop();</span><br><span class="line">memset(d,63,sizeof(d));</span><br><span class="line">memset(t,63,sizeof(t));</span><br><span class="line">in[1]=g[1]=t[1]=d[1]=0;</span><br><span class="line">q.push(make_pair(0,1));</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">pair&lt;int,int&gt; u=q.top();q.pop();</span><br><span class="line">if(vis[u.second]) continue ;</span><br><span class="line">vis[u.second]=1;</span><br><span class="line">for(int to,i=fir[u.second];i;i=nxt[i])&#123;</span><br><span class="line">to=son[i];</span><br><span class="line">if(t[to]&gt;d[u.second]+w[i])&#123;</span><br><span class="line">t[to]=d[u.second]+w[i];</span><br><span class="line">if(!in[to])&#123;</span><br><span class="line">d[to]=max(g[to],t[to]);</span><br><span class="line">q.push(make_pair(-d[to],to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(auto i:v[u.second])&#123;</span><br><span class="line">g[i]=max(g[i],d[u.second]);</span><br><span class="line">in[i]--;</span><br><span class="line">if(!in[i])&#123;</span><br><span class="line">d[i]=max(g[i],t[i]);</span><br><span class="line">q.push(make_pair(-d[i],i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int x,y,z,i=1;i&lt;=m;i++) x=read(),y=read(),z=read(),add(x,y,z);</span><br><span class="line">for(int x,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">x=read(),in[i]=x;</span><br><span class="line">for(int y,j=1;j&lt;=x;j++) y=read(),v[y].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">Dij();</span><br><span class="line">return write(d[n]),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1606 [USACO07FEB]Lilypad Pond G  题解</title>
      <link href="/2020/08/21/luogu-p1606-usaco07feblilypad-pond-g-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/21/luogu-p1606-usaco07feblilypad-pond-g-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1606">题目链接</a></p></blockquote><p>为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了M行N列个方格（1≤M,N≤30）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝的水。</p><p>贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。</p><p>贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。</p><p>约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务。一贯节俭的约翰只想添加最少数量的莲花。当然，莲花不能放在石头上。</p><p>请帮助约翰确定必须要添加的莲花的最少数量，以及有多少种放置这些莲花的方法。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑跑最短路。</p><p>由于需要计数，可以把所有可以互相到达荷花之间合并成一个点，这样就不会算重。</p><p>然后跑spfa就好了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long </span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int dx[8]=&#123;2,2,-2,-2,1,-1,1,-1&#125;,dy[8]=&#123;-1,1,-1,1,2,2,-2,-2&#125;;</span><br><span class="line">int n,m,a[35][35],vis[35][35],fir[35*35],nxt[35*35*35*35],son[35*35*35*35],tot,dis[35*35],f[35*35],used[35*35],inf,s,t;</span><br><span class="line">inline void add(int x,int y)&#123;++tot,nxt[tot]=fir[x],fir[x]=tot,son[tot]=y;&#125;</span><br><span class="line">inline void dfs(int now,int x,int y)&#123;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">int xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m)&#123;</span><br><span class="line">if(vis[xx][yy]) continue ;</span><br><span class="line">if(a[xx][yy]==1) dfs(now,xx,yy);</span><br><span class="line">//荷花缩点</span><br><span class="line">else vis[xx][yy]=1,add(now,(xx-1)*m+yy);</span><br><span class="line">//连边</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">inline void spfa()&#123;</span><br><span class="line">while(!q.empty()) q.pop();</span><br><span class="line">memset(used,0,sizeof(used));</span><br><span class="line">memset(dis,63,sizeof(dis));inf=dis[0];</span><br><span class="line">memset(f,0,sizeof(f));</span><br><span class="line">q.push(s);</span><br><span class="line">used[s]=1;dis[s]=0;f[s]=1;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int u=q.front();q.pop();used[u]=0;</span><br><span class="line">for(int to,i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">to=son[i];</span><br><span class="line">if(dis[to]&gt;dis[u]+1)&#123;</span><br><span class="line">dis[to]=dis[u]+1;</span><br><span class="line">f[to]=f[u];</span><br><span class="line">if(!used[to])&#123;</span><br><span class="line">used[to]=1;</span><br><span class="line">q.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(dis[to]==dis[u]+1) f[to]+=f[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">a[i][j]=read();</span><br><span class="line">if(a[i][j]==3) s=(i-1)*m+j;</span><br><span class="line">if(a[i][j]==4) t=(i-1)*m+j;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(a[i][j]==0a[i][j]==3) memset(vis,0,sizeof(vis)),dfs((i-1)*m+j,i,j);</span><br><span class="line">spfa();</span><br><span class="line">if(dis[t]&lt;inf) write(dis[t]-1),putchar(&#x27;\n&#x27;),write(f[t]);</span><br><span class="line">else puts(&quot;-1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4366 [Code+#4]最短路 题解</title>
      <link href="/2020/08/20/luogu-p4366-code4%E6%9C%80%E7%9F%AD%E8%B7%AF-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/20/luogu-p4366-code4%E6%9C%80%E7%9F%AD%E8%B7%AF-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4366">题目链接</a></p></blockquote><p>给定一张 $N$ 个点的图，$M$ 条边，另外任意两个点之间还有一条权值为 $(i \oplus j) \times C$ 的边，问 $A$ 到 $B$ 的最短路。</p><p>$1\leq N \leq 10^5,1\leq M \leq 5\times 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，暴力建图肯定是不行的，$N$ 个点之间两两连边就已经 $10^{10}$，考虑看一下 $xor$ 的规律。</p><p>比如$(001)_2$和$(100)_2$连边，边权为$2^0+2^2$，那么我们考虑把边拆开，拆成$(001)_2$和$(000)_2$连边，再$(000)_2$和$(100)_2$连边，边权和是一样的。</p><p>也就是说，对于每一个点$i$，我们只需要建一条$i$到$i \oplus 2^k$的边即可。</p><p>另外：</p><blockquote><p>关于SPFA，她死了</p></blockquote><p>所以，我们只能使用堆优化Dijkstra。</p><p>还有，注意范围，$0$号节点也要包括进去。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,c,fir[100010],nxt[500010+20*100010],son[500010+20*100010],w[500010+20*100010],tot,A,B,vis[1000010],dis[1000010];</span><br><span class="line">inline void add(int x,int y,int z)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;&#125;</span><br><span class="line">inline void build()&#123;</span><br><span class="line">for(int i=0;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=n;j&lt;&lt;=1)</span><br><span class="line">if((i^j)&lt;=n) add(i,i^j,j*c);</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;</span><br><span class="line">inline void Dij()&#123;</span><br><span class="line">while(!q.empty()) q.pop();</span><br><span class="line">q.push(make_pair(0,A));</span><br><span class="line">memset(dis,63,sizeof(dis));dis[A]=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">pair&lt;int,int&gt; u=q.top();q.pop();</span><br><span class="line">while(vis[u.second]&amp;&amp;!q.empty()) u=q.top(),q.pop();</span><br><span class="line">if(vis[u.second]) return ;</span><br><span class="line">vis[u.second]=1;</span><br><span class="line">for(int to,i=fir[u.second];i;i=nxt[i])&#123;</span><br><span class="line">to=son[i];</span><br><span class="line">if(dis[to]&gt;dis[u.second]+w[i])&#123;</span><br><span class="line">dis[to]=dis[u.second]+w[i];</span><br><span class="line">q.push(make_pair(-dis[to],to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read(),c=read();</span><br><span class="line">build();</span><br><span class="line">for(int x,y,z,i=1;i&lt;=m;i++) x=read(),y=read(),z=read(),add(x,y,z);</span><br><span class="line">A=read(),B=read();</span><br><span class="line">Dij();</span><br><span class="line">return write(dis[B]),0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijkstra </tag>
            
            <tag> 优化建边 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 3091 &amp; Luogu P4842 城市旅行 题解</title>
      <link href="/2020/08/13/bzoj-3091-luogu-p4842-%E5%9F%8E%E5%B8%82%E6%97%85%E8%A1%8C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/13/bzoj-3091-luogu-p4842-%E5%9F%8E%E5%B8%82%E6%97%85%E8%A1%8C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4842">题目链接Luogu</a> <a href="https://darkbzoj.tk/problem/3091">darkbzoj</a></p></blockquote><p>给定一个森林，初始形态是一棵以 $1$ 为根的树，要求进行以下操作。</p><ol><li>连接 $x,y$</li><li>断开 $x,y$</li><li>$x$ 到 $y$ 的路径上每个点权值加上 $d$</li><li>求在 $x$ 到 $y$ 的路径上任选 $2$ 个点之间路径上点的权值和的期望</li></ol><p>对于 $100\%$ 的数据，满足 $1&lt;&#x3D;N&lt;&#x3D;50,000;1&lt;&#x3D;M&lt;&#x3D;50,000;1&lt;&#x3D;a_i&lt;&#x3D;10^6;1&lt;&#x3D;D&lt;&#x3D;100;1&lt;&#x3D;U,V&lt;&#x3D;N$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于有 $Link$ 与 $Cut$ 的动态树问题，考虑使用 $LCT$。</p><p>设这条路径是 $a_1,a_2,a_3,\dots,a_{sz}$，其中 $sz$ 是路径的长度。</p><p>对于每个点的期望，我们考虑路径上的每个点会被计算几次。</p><p>路径上的第 $i$ 个点权值为 $a_i$，显然当$1\leq l\leq i,i\leq r \leq sz$时会被计算到。（$l,r$表示路径上选择的两个点）</p><p>那么这个点会被计算到 $i\times (sz-i+1)$ 次，所以产生的贡献就是 $i\times (sz-i+1)\times a_i$。</p><p>故易知期望值就是 $$\frac{\sum\limits_{i&#x3D;1}^{sz}i\times (sz-i+1)\times a_i}{C_{sz+1}^2}$$</p><p><strong>Q:为什么是 $C_{sz+1}^2$ 而不是 $C_{sz}^2$ 呢？</strong></p><p><strong>A:因为任选两个点可以是相同。</strong></p><p>然后让我们来考虑维护这个又臭又长的答案。</p><p>首先考虑分母 $C_{sz+1}^2$，这个特别好维护，只需要维护下每个点的 $sz$ 即可，最后 $split$ 下就好了。</p><p>然后我们考虑分子如何维护，也就是说如何从左子树与右子树来得到这个答案。</p><p>我们设左子树的路径是 $a_1,a_2,\dots,a_{mid-1}$，路径长度是 $mid-1$。</p><p>然后，当前点的权值是 $a_{mid}$。</p><p>同理，右子树的路径是 $a_{mid+1},a_{mid+2},\dots,a_{sz}$，路径长度是 $sz-mid$</p><p>那么，当前点的应得答案就是 $\sum\limits_{i&#x3D;1}^{sz}i\times(sz-i+1)\times a_i$</p><p>左子树的答案就是 $\sum\limits_{i&#x3D;1}^{mid-1}i\times(mid-i)\times a_i$当前点的贡献是 $a_{mid}\times mid\times (sz-mid+1)$</p><p>右子树的答案就是 $\sum\limits_{i&#x3D;mid+1}^{sz-mid}(i-mid)\times (sz-i+1)\times a_i$</p><p>然后你就会发现，如果把当前点应得的答案拆分下：</p><p>$$\sum\limits_{i&#x3D;1}^{mid-1}i\times (sz-i+1)\times a_i + a_{mid}\times mid\times (sz-mid+1) \sum\limits_{i&#x3D;mid+1}^{sz-mid}i\times (sz-i+1)\times a_i$$</p><p>然后将其与左右子树的答案作差可得：</p><p>$$\sum\limits_{i&#x3D;1}^{mid-1}i\times (sz-mid+1)\times a_i + a_{mid}\times mid\times (sz-mid+1)+\sum\limits_{i&#x3D;mid+1}^{sz-mid} mid\times (sz-i+1)\times a_i$$</p><p>此时，为了更佳的观赏效果，我们重新设一下。</p><p>设左子树的路径是 $b_1,b_2,\dots,b_{sz_b}$，其中 $sz_b$ 表示左子树的路径长度。</p><p>同理，我们设右子树的路径是 $c_1,c_2,\dots,c_{sz_c}$，其中 $sz_c$ 表示右子树的路径长度。</p><p>最后，设我们这个点的权值为 $a$。</p><p>那么其实差值就是：</p><p>$$(sz_c+1)\times \sum\limits_{i&#x3D;1}^{sz_b}b_i\times i + a\times (sz_b+1)\times (sz_c+1)+ (sz_b+1)\times \sum\limits_{i&#x3D;1}^{sz_c} (sz_c-i+1)\times c_i$$</p><p>所以，我们就可以维护下 $lsum&#x3D;\sum\limits_{i&#x3D;1}^{sz}i\times a_i,rsum&#x3D;\sum\limits_{i&#x3D;1}^{sz} (sz-i+1)\times a_i$ 以快速 $pushup$ 答案。</p><p>那么问题来了，我们如何维护 $lsum$ 与 $rsum$ 呢？</p><p>很显然，(其中 $s$ 表示所有 $a_i$ 的和)</p><p>$$lsum[x]&#x3D;lsum[ls]+v[x]\times (sz[ls]+1)+lsum[rs]+s[rc]\times (sz[ls]+1)$$</p><p>$$rsum[x]&#x3D;rsum[rs]+v[x]\times (sz[rs]+1)+rsum[ls]+s[ls]\times (sz[rs]+1)$$</p><p>简单的来说，思路就是从左右儿子继承并注意前面的系数即可。</p><p>好了，至此，我们已经完成了如何从左右儿子得到自己，现在我们要考虑操作 $3$ 带来的影响。</p><p>为了方便阅读，这里再次给出操作 $3$ 的概括：把$x$ 到 $y$ 的路径上每个点权值加上 $d$。</p><p>那么其实就是：</p><ul><li>$s+&#x3D;d\times sz$</li><li>$lsum+&#x3D;\sum\limits_{i&#x3D;1}^{sz}i\times d$ 即 $lsum+&#x3D;\frac{sz\times (sz+1)}{2}\times d$</li><li>$rsum$ 与 $lsum$ 同理，$rsum+&#x3D;\frac{sz\times(sz+1)}{2}\times d$</li><li>$ans+&#x3D;\sum\limits_{i&#x3D;1}^{sz}i\times (sz-i+1)\times d$ 即 $ans+&#x3D;\frac{sz\times (sz+1)\times (sz+2)}{6}$</li></ul><p>然后就完事了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long </span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-&#x27;0&#x27;,ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(LL x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">struct node&#123;bool tag;LL v,s,ch[2],lsum,rsum,ans,add,sz,fa;&#125;tr[50010];</span><br><span class="line">int n,m,stk[50010],top,op,x,y;</span><br><span class="line">LL a[50010],d,Ans,Div,g;</span><br><span class="line">inline bool isroot(int x)&#123;return (!x)(tr[tr[x].fa].ch[0]!=x&amp;&amp;tr[tr[x].fa].ch[1]!=x);&#125;</span><br><span class="line">inline void flip(int x)&#123;swap(tr[x].lsum,tr[x].rsum),swap(tr[x].ch[0],tr[x].ch[1]),tr[x].tag^=1;&#125;</span><br><span class="line">inline void add(int x,int v)&#123;</span><br><span class="line">tr[x].v+=v,tr[x].add+=v,tr[x].s+=tr[x].sz*v;</span><br><span class="line">tr[x].lsum+=tr[x].sz*(tr[x].sz+1)*v&gt;&gt;1;</span><br><span class="line">tr[x].rsum+=tr[x].sz*(tr[x].sz+1)*v&gt;&gt;1;</span><br><span class="line">tr[x].ans+=tr[x].sz*(tr[x].sz+1)*(tr[x].sz+2)/6*v;</span><br><span class="line">&#125;</span><br><span class="line">inline void pushdown(int x)&#123;</span><br><span class="line">if(tr[x].tag)&#123;if(tr[x].ch[0]) flip(tr[x].ch[0]);if(tr[x].ch[1]) flip(tr[x].ch[1]);tr[x].tag=0;&#125;</span><br><span class="line">if(tr[x].add)&#123;if(tr[x].ch[0]) add(tr[x].ch[0],tr[x].add);if(tr[x].ch[1]) add(tr[x].ch[1],tr[x].add);tr[x].add=0;&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void pushup(int x)&#123;</span><br><span class="line">tr[x].s=tr[tr[x].ch[0]].s+tr[tr[x].ch[1]].s+tr[x].v;</span><br><span class="line">tr[x].sz=tr[tr[x].ch[0]].sz+tr[tr[x].ch[1]].sz+1;</span><br><span class="line">tr[x].lsum=tr[tr[x].ch[0]].lsum+tr[x].v*(tr[tr[x].ch[0]].sz+1)+tr[tr[x].ch[1]].lsum+tr[tr[x].ch[1]].s*(tr[tr[x].ch[0]].sz+1);</span><br><span class="line">tr[x].rsum=tr[tr[x].ch[1]].rsum+tr[x].v*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[0]].rsum+tr[tr[x].ch[0]].s*(tr[tr[x].ch[1]].sz+1);</span><br><span class="line">tr[x].ans=tr[tr[x].ch[0]].ans+tr[tr[x].ch[1]].ans+tr[x].v*(tr[tr[x].ch[0]].sz+1)*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[0]].lsum*(tr[tr[x].ch[1]].sz+1)+tr[tr[x].ch[1]].rsum*(tr[tr[x].ch[0]].sz+1);</span><br><span class="line">&#125;</span><br><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x,v=tr[x].ch[!k];</span><br><span class="line">if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;</span><br><span class="line">tr[x].ch[!k]=y,tr[y].ch[k]=v;</span><br><span class="line">if(v) tr[v].fa=y;</span><br><span class="line">tr[y].fa=x,tr[x].fa=z;</span><br><span class="line">pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void splay(int x)&#123;</span><br><span class="line">int y=x,z=0;top=0;stk[++top]=y;</span><br><span class="line">while(!isroot(y)) stk[++top]=y=tr[y].fa;</span><br><span class="line">while(top) pushdown(stk[top--]);</span><br><span class="line">while(!isroot(x))&#123;</span><br><span class="line">y=tr[x].fa,z=tr[y].fa;</span><br><span class="line">if(!isroot(y)) rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void access(int x)&#123;for(int y=0;x;x=tr[y=x].fa) splay(x),tr[x].ch[1]=y,pushup(x);&#125;</span><br><span class="line">inline void makeroot(int x)&#123;access(x),splay(x),flip(x);&#125;</span><br><span class="line">inline int findroot(int x)&#123;access(x),splay(x);while(tr[x].ch[0]) x=tr[x].ch[0];return x;&#125;</span><br><span class="line">inline void split(int x,int y)&#123;makeroot(x),access(y),splay(x);&#125;</span><br><span class="line">inline void link(int x,int y)&#123;makeroot(x);makeroot(y);tr[y].fa=x;&#125;</span><br><span class="line">inline void cut(int x,int y)&#123;split(x,y);tr[y].fa=tr[x].ch[1]=0;&#125;</span><br><span class="line">inline LL gcd(LL a,LL b)&#123;return !b?a:gcd(b,a%b);&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) tr[i].lsum=tr[i].rsum=tr[i].v=tr[i].s=tr[i].ans=a[i]=read(),tr[i].sz=1;</span><br><span class="line">for(int x,y,i=1;i&lt;n;i++) x=read(),y=read(),link(x,y);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">op=read(),x=read(),y=read();</span><br><span class="line">if(op==1)&#123;if(findroot(x)==findroot(y)) cut(x,y);&#125;</span><br><span class="line">else if(op==2)&#123;if(findroot(x)!=findroot(y)) link(x,y);&#125;</span><br><span class="line">else if(op==3)&#123;d=read();if(findroot(x)==findroot(y)) split(x,y),add(x,d);&#125;</span><br><span class="line">else if(op==4)&#123;if(findroot(x)!=findroot(y))&#123;puts(&quot;-1&quot;);continue ;&#125;split(x,y),Ans=tr[x].ans,Div=tr[x].sz*(tr[x].sz+1)&gt;&gt;1,g=gcd(Ans,Div),write(Ans/g),putchar(&#x27;/&#x27;),write(Div/g),putchar(&#x27;\n&#x27;);&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 2959 长跑 题解</title>
      <link href="/2020/08/10/bzoj-2959-%E9%95%BF%E8%B7%91-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/08/10/bzoj-2959-%E9%95%BF%E8%B7%91-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　某校开展了同学们喜闻乐见的阳光长跑活动。为了能“为祖国健康工作五十年”，同学们纷纷离开寝室，离开教室，离开实验室，到操场参加3000米长跑运动。一时间操场上熙熙攘攘，摩肩接踵，盛况空前。<br>　　为了让同学们更好地监督自己，学校推行了刷卡机制。<br>　　学校中有n个地点，用1到n的整数表示，每个地点设有若干个刷卡机。<br>　　有以下三类事件：<br>　　1、修建了一条连接A地点和B地点的跑道。<br>　　2、A点的刷卡机台数变为了B。<br>　　3、进行了一次长跑。问一个同学从A出发，最后到达B最多可以刷卡多少次。具体的要求如下：<br>　　当同学到达一个地点时，他可以在这里的每一台刷卡机上都刷卡。但每台刷卡机只能刷卡一次，即使多次到达同一地点也不能多次刷卡。<br>　　为了安全起见，每条跑道都需要设定一个方向，这条跑道只能按照这个方向单向通行。最多的刷卡次数即为在任意设定跑道方向，按照任意路径从A地点到B地点能刷卡的最多次数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>开2个并查集，一个保存的是原树之间的关系用来判断连通性，一个保存的是强联通分量的代表节点。</p><p>每连一条边u-v，就用第一个并查集判断一下u,v是否连通。如果没有，就直接连接，否则意味着图中出现了一个环。我们把这个环上的所有节点（也就是原来u-v的路径上的所有点）的点权移到一个代表节点上，然后丢掉其他所有点，还要把所有点的第二个并查集的父亲赋值为代表节点，因为它们属于的强联同分量改变了。</p><p>对于舍弃掉的点，只要保证不会在各种操作的时候跳到即可。具体实现时，只要把所有的fa改为getfa(fa)即可，就会跳到代表节点上。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,op,x,y,a[150010];</span><br><span class="line">namespace IO&#123;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace UFS&#123;</span><br><span class="line">int fa[150010][2];</span><br><span class="line">inline int getfa(int x,int y)&#123;return fa[x][y]==x?x:fa[x][y]=getfa(fa[x][y],y);&#125;</span><br><span class="line">inline void merge(int x,int y,int z)&#123;if(x=getfa(x,z),y=getfa(y,z),x!=y) fa[x][z]=y;&#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace LCT&#123;</span><br><span class="line">struct node&#123;int s,v,ch[2],fa,tag;&#125;tr[150010];</span><br><span class="line">int stk[150010],top;</span><br><span class="line">inline bool isroot(int x)&#123;return tr[UFS::getfa(tr[x].fa,1)].ch[0]!=x&amp;&amp;tr[UFS::getfa(tr[x].fa,1)].ch[1]!=x;&#125;</span><br><span class="line">inline void pushup(int x)&#123;tr[x].s=tr[x].v+tr[tr[x].ch[0]].s+tr[tr[x].ch[1]].s;&#125;</span><br><span class="line">inline void flip(int x)&#123;swap(tr[x].ch[0],tr[x].ch[1]);tr[x].tag^=1;&#125;</span><br><span class="line">inline void pushdown(int x)&#123;</span><br><span class="line">if(!tr[x].tag) return ;</span><br><span class="line">if(tr[x].ch[0]) flip(tr[x].ch[0]);</span><br><span class="line">if(tr[x].ch[1]) flip(tr[x].ch[1]);</span><br><span class="line">tr[x].tag=0;</span><br><span class="line">&#125;</span><br><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">int y=UFS::getfa(tr[x].fa,1),z=UFS::getfa(tr[y].fa,1),k=tr[y].ch[1]==x,v=tr[x].ch[!k];</span><br><span class="line">if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;</span><br><span class="line">tr[x].ch[!k]=y,tr[y].ch[k]=v;</span><br><span class="line">if(v) tr[v].fa=y;</span><br><span class="line">tr[y].fa=x,tr[x].fa=z;</span><br><span class="line">pushup(y),pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void splay(int x)&#123;</span><br><span class="line">int y=x,z;top=0;stk[++top]=y;</span><br><span class="line">while(!isroot(y)) stk[++top]=y=tr[y].fa;</span><br><span class="line">while(top) pushdown(stk[top--]);</span><br><span class="line">while(!isroot(x))&#123;</span><br><span class="line">y=UFS::getfa(tr[x].fa,1),z=UFS::getfa(tr[y].fa,1);</span><br><span class="line">if(!isroot(y)) rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void access(int x)&#123;for(int y=0;x;x=UFS::getfa(tr[y=x].fa,1)) splay(x),tr[x].ch[1]=y,pushup(x);&#125;</span><br><span class="line">inline void makeroot(int x)&#123;access(x),splay(x),flip(x);&#125;</span><br><span class="line">inline int findroot(int x)&#123;access(x),splay(x);while(tr[x].ch[0]) pushdown(x),x=tr[x].ch[0];return x;&#125;</span><br><span class="line">inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125;</span><br><span class="line">inline void link(int x,int y)&#123;makeroot(x);tr[x].fa=y;&#125;</span><br><span class="line">inline void cut(int x,int y)&#123;split(x,y);if(findroot(y)==x&amp;&amp;tr[x].fa==y&amp;&amp;!tr[x].ch[1]) tr[x].fa=tr[y].ch[0]=0,pushup(y);&#125;</span><br><span class="line">inline void reset(int x)&#123;tr[x].fa=tr[x].ch[0]=tr[x].ch[1]=0,pushup(x);&#125;</span><br><span class="line">inline void change(int x,int y)&#123;int t=UFS::getfa(x,1);splay(t),tr[t].v-=a[x],a[x]=y,tr[t].v+=a[x],pushup(x);&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline int dfs(int f,int x)&#123;</span><br><span class="line">if(!x) return 0;</span><br><span class="line">UFS::fa[x][1]=f;</span><br><span class="line">return dfs(f,LCT::tr[x].ch[0])+dfs(f,LCT::tr[x].ch[1])+LCT::tr[x].v;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=IO::read(),m=IO::read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) UFS::fa[i][0]=UFS::fa[i][1]=i,LCT::tr[i].s=LCT::tr[i].v=a[i]=IO::read();</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">op=IO::read(),x=IO::read(),y=IO::read();</span><br><span class="line">if(op==1)&#123;</span><br><span class="line">if(x=UFS::getfa(x,1),y=UFS::getfa(y,1),x==y) continue ;</span><br><span class="line">if(UFS::getfa(x,0)!=UFS::getfa(y,0)) LCT::link(x,y),UFS::merge(x,y,0);</span><br><span class="line">else LCT::split(x,y),LCT::tr[x].v=dfs(x,y),LCT::reset(x);</span><br><span class="line">&#125;else if(op==2) LCT::change(x,y);</span><br><span class="line">else if(op==3)&#123;</span><br><span class="line">if(UFS::getfa(x,0)!=UFS::getfa(y,0))&#123;puts(&quot;-1&quot;);continue ;&#125;</span><br><span class="line">x=UFS::getfa(x,1),y=UFS::getfa(y,1),LCT::split(x,y),IO::write(LCT::tr[y].s),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Link Cut Tree</title>
      <link href="/2020/07/27/%E6%B5%85%E8%B0%88link-cut-tree/"/>
      <url>/2020/07/27/%E6%B5%85%E8%B0%88link-cut-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Link Cut Tree 可真是好用呢~</p><p>刚入门的各位不需要担心，LCT其实十分简单。</p><p>陈指导写的LCT也不过10几行，我这个菜鸡打的模板也只有50+行。</p><p>所以LCT码量很小</p><p>好了，步入正题。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>A <strong>link&#x2F;cut tree</strong> is a <a href="https://en.wikipedia.org/wiki/Data_structure">data structure</a> for representing a <a href="https://en.wikipedia.org/wiki/Forest_(graph_theory)">forest</a>, a set of <a href="https://en.wikipedia.org/wiki/Rooted_tree">rooted trees</a>, and offers the following operations:</p><ul><li>Add a tree consisting of a single node to the forest.</li><li>Given a node in one of the trees, disconnect it (and its subtree) from the tree of which it is part.</li><li>Attach a node to another node as its child.</li><li>Given a node, find the root of the tree to which it belongs. By doing this operation on two distinct nodes, one can check whether they belong to the same tree.</li></ul><p>The represented forest may consist of very deep trees, so if we represent the forest as a plain collection of <a href="https://en.wikipedia.org/wiki/Parent_pointer_tree">parent pointer trees</a>, it might take us a long time to find the root of a given node. However, if we represent each tree in the forest as a link&#x2F;cut tree, we can find which tree an element belongs to in <em>O</em>(log(<em>n</em>)) amortized time. Moreover, we can quickly adjust the collection of link&#x2F;cut trees to changes in the represented forest. In particular, we can adjust it to merge (link) and split (cut) in <a href="https://en.wikipedia.org/wiki/Big_O_notation">O</a>(<a href="https://en.wikipedia.org/wiki/Logarithm">log</a>(n)) <a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a> time.</p><p>Link&#x2F;cut trees divide each tree in the represented forest into vertex-disjoint paths, where each path is represented by an auxiliary data structure (often <a href="https://en.wikipedia.org/wiki/Splay_trees">splay trees</a>, though the original paper predates splay trees and thus uses biased binary search trees). The nodes in the auxiliary data structure are ordered by their depth in the corresponding represented tree. In one variation, <em>Naive Partitioning</em>, the paths are determined by the most recently accessed paths and nodes, similar to <a href="https://en.wikipedia.org/wiki/Tango_Trees">Tango Trees</a>. In <em>Partitioning by Size</em> paths are determined by the heaviest child (child with the most children) of the given node. This gives a more complicated structure, but reduces the cost of the operations from amortized O(log n) to worst case O(log n). It has uses in solving a variety of network flow problems and to jive data sets.</p><p>In the original publication, <a href="https://en.wikipedia.org/wiki/Daniel_Sleator">Sleator</a> and <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Tarjan</a> referred to link&#x2F;cut trees as “dynamic trees”, or “dynamic dyno trees”.</p><p>——Wikepedia</p><p>当然你看不懂也没关系</p><p>简单的来说<strong>动态树(Link Cut Tree)<strong>是一个可以维护</strong>动态森林</strong>的<strong>树形结构</strong>，它有类似于树链剖分(重链剖分)、长链剖分的轻、重链的<strong>虚、实边</strong>，但不同的是，<strong>动态树的虚、实边是可以变换的</strong>(虚边变实边，实边变虚边)，并且用<strong>Splay</strong>来维护每一条<strong>实路径</strong>。</p><p>Link Cut Tree的基本操作复杂度<strong>均摊$O({\log}N)$<strong>，但</strong>常数较</strong>大，一般效率会<strong>低于树链剖分</strong>，但是却能解决许多树链剖分解决不了的问题。</p><p>所以，如果你还不会<strong>Splay</strong>，请左转这篇<a href="https://yzxoi.top/archives/1057">Blog</a>。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>Link Cut Tree有许多性质，差不多就这些了：</p><ul><li>每一个Splay维护的是一条从上到下按在原树中<strong>深度严格递增</strong>的路径，且<strong>中序遍历Splay</strong>得到的每个点的<strong>深度序列严格递增</strong>。(就是<strong>链</strong>)</li><li>每个节点<strong>包含且仅包含</strong>于一个Splay中，每一个父亲的向儿子的连边中<strong>有且只有一条</strong>边是<strong>实边</strong></li><li><strong>所有的实边包含在Splay中</strong>，而<strong>虚边</strong>总是<strong>指向另一个Splay中的某个节点</strong>(指向该Splay中<strong>中序遍历最靠前的点</strong>在<strong>原树中的父亲</strong>)</li><li><strong>所有的</strong>实边的父亲和儿子都要标记，虚边只要儿子记父亲(<strong>实边认父又认子，虚边认父不认子</strong>)</li></ul><p>听不懂？没关系，看图就会了。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727111049.png"></p><p>红色圆圈代表一个Splay</p><p>一开始，所有的边都是虚边，每个点都是一个Splay。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727111325.png"></p><p>绿色代表实边，其相连的代表一个Splay</p><p>后来，我们选了一些边为实边。这样也是符合的。</p><p>相信你看了图以后就知道LCT大概长什么样了。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>文字、代码中将要用到的变量名&amp;定义。</p><p>变量名</p><p>定义</p><p>fa[x]</p><p>节点x的父亲(father)</p><p>v[x]</p><p>节点x的权值(value)</p><p>s[x]</p><p>节点x及其子树的权值和(sum)</p><p>tag[x]</p><p>节点x的翻转情况</p><p>ch[x][0&#x2F;1]</p><p>节点x的左&#x2F;右儿子(children)</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>这里先给出将要介绍的基本操作的用途，看不懂没关系，接下来会图解+代码说明。</p><p>操作名称</p><p>用途</p><p>access(x)</p><p>将x到根节点的路径全部变成实边，并把其他子节点的边改为虚边</p><p>findroot(x)</p><p>找出x在原树中的根节点</p><p>makeroot(x)</p><p>把x变成原树的根节点</p><p>split(x,y)</p><p>把x和y弄到同一个Splay中</p><p>link(x,y)</p><p>将x和y所在原树连接起来</p><p>cut(x,y)</p><p>将x和y所在原树断开</p><h4 id="access-x"><a href="#access-x" class="headerlink" title="access(x)"></a>access(x)</h4><p>这是Link Cut Tree中<strong>最基础、最重要</strong>的操作。</p><p>就是将<strong>x到原树根节点之间的链</strong>丢到<strong>一个Splay</strong>中。</p><p>听不懂？没关系，来图解。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727113158.png"></p><p>比如还是这棵树，我们要执行access(9)。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727113310.png"></p><p>显然，它会变成这样。</p><p>1-2-5-9变成实边</p><p><strong>路径上所有点的其他儿子连的边变成虚边</strong></p><p><strong>整理一下</strong>：</p><ol><li>转到根</li><li>换儿子</li><li>更新信息</li><li>当前操作点切换为轻边所指的父亲，转1。</li></ol><p><strong>详细图解一下</strong>：</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727123411.png"></p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727123611.png"></p><p>而下一次操作需要Splay(2)，此时树的形态会发生巨大转变。</p><p><img src="https://gitee.com/yzx1798106406/yzximg/raw/master/img/20200727132522.png"></p><p>然后我们就完成了</p><p>那么为什么是<strong>右儿子</strong>而不是<strong>左儿子</strong>呢？</p><p>因为<strong>fa[x]的深度小于x</strong>，而在<strong>Splay里fa[x]是x的父亲</strong>，所以<strong>x在Splay里是fa[x]的右儿子</strong>。</p><p>上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline void access(int x)&#123;</span><br><span class="line">for(int y=0;x;x=tr[y=x].fa)&#123;//当前操作点转到轻边所指的父亲 </span><br><span class="line">splay(x),//转到根 </span><br><span class="line">tr[x].ch[1]=y,//换儿子 </span><br><span class="line">pushup(x);//更新信息 </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findroot-x"><a href="#findroot-x" class="headerlink" title="findroot(x)"></a>findroot(x)</h4><p>因为<strong>根节点的深度是最小的</strong>，所以我们可以从x向上找，使用<strong>access</strong>将<strong>x和x的根节点弄到同一个Splay中</strong>。</p><p>因为在执行<strong>access操作后</strong>，这棵<strong>Splay里的节点权值最大的就是x</strong>。</p><p>由于二叉搜索树(Binary Search Tree)的性质：x的左子树&lt;x&lt;x的右子树</p><p>所以我们可以把<strong>x转成根节点</strong>，那么<strong>最左边</strong>的那个节点便是这棵树的<strong>根节点</strong>了。</p><p><strong>代码实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int findroot(int x)&#123;</span><br><span class="line">access(x);//Access将x和根节点弄到同一个Splay中</span><br><span class="line">splay(x);//把x转到Splay的根节点 </span><br><span class="line">while(tr[x].ch[0])&#123;</span><br><span class="line">pushdown(x),//更新节点信息(可能有翻转标记，之后会提到) </span><br><span class="line">x=tr[x].ch[0];//不断找左儿子 </span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="makeroot-x"><a href="#makeroot-x" class="headerlink" title="makeroot(x)"></a>makeroot(x)</h4><p>将x到根节点的路径上的点<strong>全部翻</strong>转(即x变成了根节点)</p><p>我们可以先<strong>access(x)<strong>，把</strong>x到根节点打通成一条链</strong>。</p><p>我们发现x一定是在它所在的辅助树的中序遍历的最后一个的(因为它是这条链上<strong>最深的点</strong>)。</p><p>我们把<strong>x点Splay到Splay的根</strong>，那么<strong>x显然是没有右子树的</strong>。</p><p>我们要实现把x移到原树的根，也就是把x到根这条链的深度<strong>全部翻转一遍</strong>。</p><p>在<strong>Splay上体现就是把整棵树反转一次</strong>。</p><p>我们可以写个<strong>翻转标记</strong>来减小复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline void flip(int x)&#123;//翻转操作 </span><br><span class="line">swap(tr[x].ch[0],tr[x].ch[1]);//交换 </span><br><span class="line">tr[x].tag^=1;//标记 </span><br><span class="line">&#125;</span><br><span class="line">inline void makeroot(int x)&#123;</span><br><span class="line">access(x);//把x到根节点打通 </span><br><span class="line">splay(x);//把x变成根 </span><br><span class="line">flip(x);//翻转 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="split-x-y"><a href="#split-x-y" class="headerlink" title="split(x,y)"></a>split(x,y)</h4><p>把x和y放在<strong>同一个Splay</strong>中，并<strong>以y为根</strong></p><p>首先我们并不能保证x和y<strong>一定在同一条链</strong>里，所以我们要先把<strong>x变成原树的根节点</strong>，然后<strong>access(y)<strong>，这样就会</strong>把x到y之间所有节点弄到同一个Splay里</strong>了。</p><p>最后**Splay(y)**，以y为根。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline void split(int x,int y)&#123;</span><br><span class="line">makeroot(x);//把x变成原树的根节点 </span><br><span class="line">access(y);//把x到y之间所有节点弄到同一个Splay里 </span><br><span class="line">splay(y);//以y为根 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="link-x-y"><a href="#link-x-y" class="headerlink" title="link(x,y)"></a>link(x,y)</h4><p>把x和y的原树连接起来</p><p>首先把<strong>x换成原树的根</strong>，然后再判断<strong>y的根是否是</strong>x。因为x和y连接起来一定是x和y在不同树中，所以<strong>若y的根是x则不需要连接</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline void link(int x,int y)&#123;</span><br><span class="line">makeroot(x);//把x换成原树的根 </span><br><span class="line">if(findroot(y)!=x) tr[x].fa=y;//判断y的根是否是x，连虚边 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cut-x-y"><a href="#cut-x-y" class="headerlink" title="cut(x,y)"></a>cut(x,y)</h4><p>把x和y的原树断开</p><p>首先我们先把x,y之间的那条边用<strong>split(x,y)<strong>拎出来，因为</strong>x,y是相邻</strong>的，所以<strong>y的左儿子一定是x</strong>，将它们的父子关系消灭掉即可。</p><p>消灭时一定满足以下条件：</p><ol><li>x和y在<strong>同一个原树</strong>里</li><li>split后<strong>x是y的左儿子</strong></li><li>x没有右儿子(保证了中序遍历中y紧跟在x的后面，即<strong>深度相邻</strong>)(x的权值(深度)只比y小1，而x又正好是直接连着y的，所以我们无法再找到 <strong>&gt;x 而又 &lt;y</strong> 的整数了)</li></ol><p>但是，很遗憾，因为我们要使用findroot(y)，所以中途会splay(x)。</p><p>所以<strong>其他条件全部反过来</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline void cut(int x,int y)&#123;</span><br><span class="line">split(x,y);</span><br><span class="line">if(findroot(y)==x&amp;&amp;tr[x].fa==y&amp;&amp;!tr[x].ch[1]) tr[x].fa=tr[y].ch[0]=0,pushup(y);//findroot中有Splay，cut中x和y的父子关系会发生改变 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Rotate改动"><a href="#Rotate改动" class="headerlink" title="Rotate改动"></a>Rotate改动</h4><p>需要特判一下连虚边的情况</p><p>如果<strong>z(x的爷爷)不存在</strong>，则<strong>只需要连虚边</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x,v=tr[x].ch[!k];</span><br><span class="line">if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;//特判虚边</span><br><span class="line">tr[x].ch[!k]=y,tr[y].ch[k]=v;//普通Rotate</span><br><span class="line">if(v) tr[v].fa=y;</span><br><span class="line">tr[y].fa=x;tr[x].fa=z;</span><br><span class="line">pushup(y);pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Splay改动"><a href="#Splay改动" class="headerlink" title="Splay改动"></a>Splay改动</h4><p>要注意下Splay只能到<strong>Splay的根节点</strong>，所以需要<strong>先记录下这条链的所有节点</strong>，用栈即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline void splay(int x)&#123;</span><br><span class="line">int y=x,z;top=0;stk[++top]=y;</span><br><span class="line">while(!isroot(y)) stk[++top]=y=tr[y].fa;//开个栈记录下</span><br><span class="line">while(top) pushdown(stk[top--]);//下传</span><br><span class="line">while(!isroot(x))&#123;//普通Splay</span><br><span class="line">y=tr[x].fa;z=tr[y].fa;</span><br><span class="line">if(!isroot(y)) rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><blockquote><p><a href="https://www.luogu.com.cn/problem/P3690">题目链接：P3690 【模板】Link Cut Tree （动态树）</a></p></blockquote><p>模板题不需要讲了吧，直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">struct node&#123;int fa,v,s,ch[2],tag;&#125;tr[100010];</span><br><span class="line">int stk[100010],top;</span><br><span class="line">inline bool isroot(int x)&#123;return tr[tr[x].fa].ch[0]!=x&amp;&amp;tr[tr[x].fa].ch[1]!=x;&#125;</span><br><span class="line">inline void pushup(int x)&#123;tr[x].s=tr[tr[x].ch[0]].s^tr[tr[x].ch[1]].s^tr[x].v;&#125;</span><br><span class="line">inline void flip(int x)&#123;swap(tr[x].ch[0],tr[x].ch[1]);tr[x].tag^=1;&#125;</span><br><span class="line">inline void pushdown(int x)&#123;</span><br><span class="line">if(!tr[x].tag) return ;</span><br><span class="line">if(tr[x].ch[0]) flip(tr[x].ch[0]);</span><br><span class="line">if(tr[x].ch[1]) flip(tr[x].ch[1]);</span><br><span class="line">tr[x].tag=0;</span><br><span class="line">&#125;</span><br><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x,v=tr[x].ch[!k];</span><br><span class="line">if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;</span><br><span class="line">tr[x].ch[!k]=y,tr[y].ch[k]=v;</span><br><span class="line">if(v) tr[v].fa=y;</span><br><span class="line">tr[y].fa=x;tr[x].fa=z;</span><br><span class="line">pushup(y);pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void splay(int x)&#123;</span><br><span class="line">int y=x,z;top=0;stk[++top]=y;</span><br><span class="line">while(!isroot(y)) stk[++top]=y=tr[y].fa;</span><br><span class="line">while(top) pushdown(stk[top--]);</span><br><span class="line">while(!isroot(x))&#123;</span><br><span class="line">y=tr[x].fa;z=tr[y].fa;</span><br><span class="line">if(!isroot(y)) rotate((tr[y].ch[0]==x)^(tr[z].ch[0]==y)?x:y);</span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line">pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void access(int x)&#123;for(int y=0;x;x=tr[y=x].fa) splay(x),tr[x].ch[1]=y,pushup(x);&#125;</span><br><span class="line">inline void makeroot(int x)&#123;access(x);splay(x);flip(x);&#125;</span><br><span class="line">inline int findroot(int x)&#123;access(x);splay(x);while(tr[x].ch[0]) pushdown(x),x=tr[x].ch[0];return x;&#125;</span><br><span class="line">inline void split(int x,int y)&#123;makeroot(x);access(y);splay(y);&#125;</span><br><span class="line">inline void link(int x,int y)&#123;makeroot(x);if(findroot(y)!=x) tr[x].fa=y;&#125;</span><br><span class="line">inline void cut(int x,int y)&#123;split(x,y);if(findroot(y)==x&amp;&amp;tr[x].fa==y&amp;&amp;!tr[x].ch[1]) tr[x].fa=tr[y].ch[0]=0,pushup(y);&#125;</span><br><span class="line">int n,m,x,y,op;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) tr[i].v=read();</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">op=read(),x=read(),y=read();</span><br><span class="line">if(op==0) split(x,y),write(tr[y].s),putchar(&#x27;\n&#x27;);</span><br><span class="line">else if(op==1) link(x,y);</span><br><span class="line">else if(op==2) cut(x,y);</span><br><span class="line">else splay(x),tr[x].v=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>大家可以再找一点例题，这里放个<a href="https://www.luogu.com.cn/problem/list?tag=229&page=1">链接</a>。</p><p>终于写完了，完结撒花*★,°*:.☆(￣▽￣)&#x2F;$:*.°★* 。</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2617 Dynamic Rankings   题解</title>
      <link href="/2020/07/18/luogu-p2617-dynamic-rankings-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/07/18/luogu-p2617-dynamic-rankings-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2617">题目链接</a></p></blockquote><p>给定一个含有 $n$ 个数的序列 $a_1,a_2 \dots a_n$​，需要支持两种操作：</p><ul><li><code>Q l r k</code> 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数</li><li><code>C x y</code> 表示将 $a_x$​ 改为 $y$</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>树状数组套主席树</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">return res*f; </span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[100010],Q[100010&lt;&lt;1],cnt,tot,rt[100010&lt;&lt;1];</span><br><span class="line">vector&lt;int&gt; del,add;</span><br><span class="line">struct Question&#123;int op,l,r,x;&#125;q[100010];</span><br><span class="line">struct node&#123;int l,r,sum,sz;&#125;tr[60000010];</span><br><span class="line">inline void insert(int &amp;x,int l,int r,int pos,int v)&#123;</span><br><span class="line">if(!x) ++tot,tr[tot]=tr[x],x=tot;</span><br><span class="line">tr[x].sum+=v;</span><br><span class="line">if(l==r) return ;</span><br><span class="line">int mid=l+r&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) insert(tr[x].l,l,mid,pos,v);</span><br><span class="line">else insert(tr[x].r,mid+1,r,pos,v);</span><br><span class="line">&#125;</span><br><span class="line">inline int query(int l,int r,int x)&#123;</span><br><span class="line">if(l==r) return l;</span><br><span class="line">int res=0,mid=l+r&gt;&gt;1;</span><br><span class="line">for(auto i:del) res-=tr[tr[i].l].sum;</span><br><span class="line">for(auto i:add) res+=tr[tr[i].l].sum;</span><br><span class="line">if(x&lt;=res)&#123;</span><br><span class="line">for(auto &amp;i:del) i=tr[i].l;</span><br><span class="line">for(auto &amp;i:add) i=tr[i].l;</span><br><span class="line">return query(l,mid,x);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(auto &amp;i:del) i=tr[i].r;</span><br><span class="line">for(auto &amp;i:add) i=tr[i].r;</span><br><span class="line">return query(mid+1,r,x-res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i]=read(),Q[++cnt]=a[i];</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">char c;cin&gt;&gt;c;</span><br><span class="line">if(c==&#x27;Q&#x27;) q[i].op=1,q[i].l=read(),q[i].r=read(),q[i].x=read();</span><br><span class="line">else q[i].op=2,q[i].l=read(),q[i].x=read(),Q[++cnt]=q[i].x;</span><br><span class="line">&#125;</span><br><span class="line">sort(Q+1,Q+cnt+1);</span><br><span class="line">cnt=unique(Q+1,Q+cnt+1)-Q-1;</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i]=lower_bound(Q+1,Q+cnt+1,a[i])-Q;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">if(q[i].op==2) q[i].x=lower_bound(Q+1,Q+cnt+1,q[i].x)-Q;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=i;j&lt;=cnt;j+=(j&amp;(-j))) insert(rt[j],1,cnt,a[i],1);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">if(q[i].op==1)&#123;</span><br><span class="line">del.clear();add.clear();</span><br><span class="line">for(int j=q[i].l-1;j;j-=(j&amp;(-j))) del.push_back(rt[j]);</span><br><span class="line">for(int j=q[i].r;j;j-=(j&amp;(-j))) add.push_back(rt[j]);</span><br><span class="line">printf(&quot;%d\n&quot;,Q[query(1,cnt,q[i].x)]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">for(int j=q[i].l;j&lt;=cnt;j+=(j&amp;(-j))) insert(rt[j],1,cnt,a[q[i].l],-1);</span><br><span class="line">a[q[i].l]=q[i].x;</span><br><span class="line">for(int j=q[i].l;j&lt;=cnt;j+=(j&amp;(-j))) insert(rt[j],1,cnt,a[q[i].l],1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 树套树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>loj 6062 「2017 山东一轮集训 Day2」Pair 题解</title>
      <link href="/2020/07/16/loj-6062-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-day2%E3%80%8Dpair-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/07/16/loj-6062-%E3%80%8C2017-%E5%B1%B1%E4%B8%9C%E4%B8%80%E8%BD%AE%E9%9B%86%E8%AE%AD-day2%E3%80%8Dpair-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://loj.ac/problem/6062">题目链接</a></p></blockquote><p>给出一个长度为 $n$ 的数列 $\{a_i\}$ 和一个长度为 $m$ 的数列 $\{b_i\}$，求 $\{a_i\}$ 有多少个长度为 $m$ 的<strong>连续子数列</strong>能与 $\{b_i\}$ 匹配。</p><p>两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和<strong>不小于</strong> $h$。</p><p>对于$100\%$的数据，$1\leq m\leq n \leq 150000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很明显，我们可以把检验配对的不等式变形：</p><p>$$a_i + b_i \ge h$$</p><p>$$a_i \ge h- b_i$$</p><p>令$b_i’&#x3D;h-b_i$</p><p>要使其可<strong>完全</strong>匹配，那么应将选出的$a_i$和$b_i’$分别按照从大到小（或从小到大）<strong>排序</strong>，然后扫一遍，判断其是否满足这个等式即可。</p><p>但是如果这样的话复杂度就是$O((N-M+1)\times M)$（从长度为$n$中选长度为$m$的连续子数列有$(n-m+1)$种选法）</p><p>很明显，这个复杂度不够优秀。</p><p>那么我们可以用线段树来优化这道题。</p><p>令$b_1’ \ge b_2’ \ge b_3’ \ge \dots \ge b_m’$，则对于每个$b_i’$都应该有$\ge i$个$a$大于等于它。</p><p>所以，我们可以将$a,b’$离散化，对于每个$b_i’$，在线段树上的$b_i’$位置上减$i$，代表它需要$i$个数来大于等于它；对于每个$a_i$，在线段树上的$[1,a_i]$上加$1$，代表这些位置上的都比它小，为其产生贡献。</p><p>那么最后只要判断下线段树上是否每个点都是非负数即可。</p><p><strong>注意</strong>，当两个$b_i’$<strong>相同</strong>时，<strong>只需要取</strong>$i$更<strong>大</strong>的即可，<strong>不能叠加</strong>。</p><p>那么，如何来判断线段树上是否每个点都是非负数呢？</p><p>只需要记录一个最小值，若最小值都大于等于$0$，那么肯定完全匹配。</p><p>所以，我们每次枚举一下区间，将$[1,a_{i-m-1}]$减去$1$，并将$[1,a_i]$加上$1$（移动区间），然后判断下最小值是否大于等于$0$即可。</p><p>复杂度非常优秀$O((N-M+1)\times logN)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">return res*f; </span><br><span class="line">&#125; </span><br><span class="line">int n,m,h,a[150010],b[150010],q[300010],tot,ans;</span><br><span class="line">inline int cmp(int x,int y)&#123;return x&gt;y;&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">int mn,tag;</span><br><span class="line">&#125;tr[300010&lt;&lt;2];</span><br><span class="line">inline void psd(int x)&#123;</span><br><span class="line">if(!tr[x].tag) return ;</span><br><span class="line">tr[x&lt;&lt;1].mn+=tr[x].tag;</span><br><span class="line">tr[x&lt;&lt;1].tag+=tr[x].tag;</span><br><span class="line">tr[x&lt;&lt;11].mn+=tr[x].tag;</span><br><span class="line">tr[x&lt;&lt;11].tag+=tr[x].tag;</span><br><span class="line">tr[x].tag=0;</span><br><span class="line">&#125;</span><br><span class="line">inline void pup(int x)&#123;</span><br><span class="line">tr[x].mn=min(tr[x&lt;&lt;1].mn,tr[x&lt;&lt;11].mn);</span><br><span class="line">&#125;</span><br><span class="line">inline void upd(int x,int l,int r,int L,int R,int v)&#123;</span><br><span class="line">if(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">tr[x].mn+=v;</span><br><span class="line">tr[x].tag+=v;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">psd(x);</span><br><span class="line">int mid=l+r&gt;&gt;1;</span><br><span class="line">if(L&lt;=mid) upd(x&lt;&lt;1,l,mid,L,R,v);</span><br><span class="line">if(R&gt;mid) upd(x&lt;&lt;11,mid+1,r,L,R,v);</span><br><span class="line">pup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline void build(int x,int l,int r)&#123;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tr[x].mn=0;</span><br><span class="line">tr[x].tag=0;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">int mid=l+r&gt;&gt;1;</span><br><span class="line">build(x&lt;&lt;1,l,mid);</span><br><span class="line">build(x&lt;&lt;11,mid+1,r);</span><br><span class="line">&#125;</span><br><span class="line">inline int check()&#123;</span><br><span class="line">return tr[1].mn&gt;=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read(),h=read();</span><br><span class="line">for(int i=1;i&lt;=m;i++) b[i]=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">for(int i=1;i&lt;=m;i++) b[i]=h-b[i];</span><br><span class="line">sort(b+1,b+m+1,cmp);</span><br><span class="line">for(int i=1;i&lt;=m;i++) q[i]=b[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++) q[i+m]=a[i];</span><br><span class="line">sort(q+1,q+m+n+1);</span><br><span class="line">tot=unique(q+1,q+m+n+1)-q-1;</span><br><span class="line">build(1,1,tot);</span><br><span class="line">for(int i=1;i&lt;=m;i++) b[i]=lower_bound(q+1,q+tot+1,b[i])-q;</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i]=lower_bound(q+1,q+tot+1,a[i])-q;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">if(b[i]&lt;h) upd(1,1,tot,b[i],b[i],b[i]==b[i-1]?-1:-i);</span><br><span class="line">for(int i=1;i&lt;=m;i++) upd(1,1,tot,1,a[i],1);</span><br><span class="line">ans=check();</span><br><span class="line">for(int i=m+1;i&lt;=n;i++) upd(1,1,tot,1,a[i-m],-1),upd(1,1,tot,1,a[i],1),ans+=check();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 套路题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 3653 谈笑风生 题解</title>
      <link href="/2020/07/15/bzoj-3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/07/15/bzoj-3653-%E8%B0%88%E7%AC%91%E9%A3%8E%E7%94%9F-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p><a href="https://darkbzoj.tk/problem/3653">题目链接</a></p></blockquote><p>设T 为一棵有根树，我们做如下的定义：</p><p>设a和b为T 中的两个不同节点。如果a是b的祖先，那么称“a比b不知道高明到哪里去了”。</p><p>设a 和 b 为 T 中的两个不同节点。如果 a 与 b 在树上的距离不超过某个给定常数x，那么称“a 与b 谈笑风生”。</p><p>给定一棵n个节点的有根树T，节点的编号为1 到 n，根节点为1号节点。你需要回答q 个询问，询问给定两个整数p和k，问有多少个有序三元组(a;b;c)满足：</p><ol><li>a、b和 c为 T 中三个不同的点，且 a为p 号节点；</li><li>a和b 都比 c不知道高明到哪里去了；</li><li>a和b 谈笑风生。这里谈笑风生中的常数为给定的 k。</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>分类讨论+dfs序+主席树</p><p>若$b$在$a$上方，$ans&#x3D;min( dep[a]-1,k )\times ( sz[a] -1 )$</p><p>若$b$在$a$下方，主席树最外层$dfs$序，内层套线段树求区间和，维护子树大小。在$dep[a]+1$到$dep[a]+k$范围内求和$sz[TT]$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(!isdigit(ch)) f=ch==&#x27;-&#x27;?-1:f,ch=getchar();</span><br><span class="line">    while(isdigit(ch)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(ch&amp;15),ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,q,g[300010],cnt,dep[300010],cnd,rt[300010];</span><br><span class="line">LL sz[300010];</span><br><span class="line">int fir[300010],nxt[300010&lt;&lt;1],son[300010&lt;&lt;1],tot;</span><br><span class="line">pair&lt;int,int&gt; id[300010];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r;</span><br><span class="line">LL sum;</span><br><span class="line">&#125;tr[300010&lt;&lt;5];</span><br><span class="line">inline void add(int x,int y)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;&#125;</span><br><span class="line">inline void dfs(int x,int fa)&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    id[x].first=cnt;</span><br><span class="line">    dep[x]=dep[fa]+1;</span><br><span class="line">    sz[x]=1;</span><br><span class="line">    g[cnt]=x;</span><br><span class="line">    for(int to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        to=son[i];</span><br><span class="line">        if(to==fa) continue ;</span><br><span class="line">        dfs(to,x);</span><br><span class="line">        sz[x]+=sz[to];</span><br><span class="line">    &#125;</span><br><span class="line">    id[x].second=cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline void insert(int &amp;x,int l,int r,int pos,int v)&#123;</span><br><span class="line">++cnd;</span><br><span class="line">    tr[cnd]=tr[x];</span><br><span class="line">x=cnd;</span><br><span class="line">    tr[x].sum+=(LL)v;</span><br><span class="line">    if(l==r) return ;</span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    if(pos&lt;=mid) insert(tr[x].l,l,mid,pos,v);</span><br><span class="line">    else insert(tr[x].r,mid+1,r,pos,v);</span><br><span class="line">&#125;</span><br><span class="line">inline LL query(int x,int y,int l,int r,int L,int R)&#123;</span><br><span class="line">    if(L&lt;=l&amp;&amp;r&lt;=R) return tr[y].sum-tr[x].sum;</span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">LL res=0;</span><br><span class="line">    if(L&lt;=mid) res+=query(tr[x].l,tr[y].l,l,mid,L,R);</span><br><span class="line">    if(R&gt;mid) res+=query(tr[x].r,tr[y].r,mid+1,r,L,R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read(),q=read();</span><br><span class="line">    for(int u,v,i=1;i&lt;n;i++)&#123;</span><br><span class="line">        u=read(),v=read();</span><br><span class="line">        add(u,v),add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) rt[i]=rt[i-1],insert(rt[i],1,n,dep[g[i]],sz[g[i]]-1);</span><br><span class="line">for(int p,k,i=1;i&lt;=q;i++)&#123;</span><br><span class="line">        p=read(),k=read();</span><br><span class="line">        LL ans=query(rt[id[p].first],rt[id[p].second],1,n,dep[p]+1,dep[p]+k);</span><br><span class="line">        ans+=(LL)min(k,dep[p]-1)*(sz[p]-1);</span><br><span class="line">        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 3209 &amp; Luogu P4317 花神的数论题 题解</title>
      <link href="/2020/06/13/bzoj-3209-luogu-p4317-%E8%8A%B1%E7%A5%9E%E7%9A%84%E6%95%B0%E8%AE%BA%E9%A2%98-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/06/13/bzoj-3209-luogu-p4317-%E8%8A%B1%E7%A5%9E%E7%9A%84%E6%95%B0%E8%AE%BA%E9%A2%98-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接:<a href="https://darkbzoj.tk/problem/3209">bzoj</a> <a href="https://www.luogu.com.cn/problem/P4317">Luogu</a></p></blockquote><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>求$1$到$n$每个数的$1$的个数之积。</p><p>对于$ 100\% $的数据，$n\leq 10^15$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数位$DP$。</p><p>可以先把$n$拆成二进制，然后$DFS$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long//不开long long 可能会乘炸</span><br><span class="line">#define mod 10000007</span><br><span class="line">using namespace std;</span><br><span class="line">int a[60],m,f[60][60][2];//注意数组大小</span><br><span class="line">inline int dfs(int x,int sum,int lim)&#123;//当前位置，累计和，是否达到上限</span><br><span class="line">    if(x&gt;m) return max(sum,1ll);//返回</span><br><span class="line">    if(~f[x][sum][lim]) return f[x][sum][lim];//记忆化</span><br><span class="line">    int Max=lim?a[m-x+1]:1,res=1;//范围（需要反转）</span><br><span class="line">    for(int i=0;i&lt;=Max;i++) res*=dfs(x+1,sum+(i==1),lim&amp;&amp;(i==Max)),res%=mod;//别忘记%</span><br><span class="line">    return f[x][sum][lim]=res;//记忆化</span><br><span class="line">&#125;</span><br><span class="line">inline void solve(int x)&#123;memset(f,-1,sizeof(f));while(x) a[++m]=x&amp;1,x&gt;&gt;=1;cout&lt;&lt;dfs(1,0,1);&#125;</span><br><span class="line">int N;signed main()&#123;return cin&gt;&gt;N,solve(N),0;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 1858. [Scoi2010]序列操作 题解</title>
      <link href="/2020/06/06/bzoj-1858-scoi2010%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/06/06/bzoj-1858-scoi2010%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>题目链接：<a href="https://darkbzoj.tk/problem/1858">BZOJ1858 [Scoi2010]序列操作</a></p></blockquote><p>给你长度为$n$的$01$串，现有$m$个操作。</p><ol><li>区间赋值为$0$</li><li>区间赋值为$1$</li><li>区间反转（所有$0$变为$1$，所有$1$变为$0$）</li><li>区间求和</li><li>求区间最多有连续的几个$1$</li></ol><p>对于$100\%$的数据，$1\le n,m \le 100000$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>珂朵莉树，如果您还不了解珂朵莉树，可以参见我的<a href="https://yzxoi.top/archives/1409">这篇博客</a>。</p><p>由于$Luogu$上的数据已加强，故只能过$3$个点，但$bzoj$可过。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline </span><br><span class="line">#define It set&lt;node&gt;::iterator</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;mutable int v;</span><br><span class="line">node(int L,int R=-1,int V=0):l(L),r(R),v(V)&#123;&#125;</span><br><span class="line">bool operator&lt;(const node&amp; x)const&#123;return l&lt;x.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line">I It split(int x)&#123;</span><br><span class="line">It it=s.lower_bound(x);</span><br><span class="line">if(it!=s.end()&amp;&amp;it-&gt;l==x) return it;</span><br><span class="line">it--;</span><br><span class="line">int L=it-&gt;l,R=it-&gt;r,V=it-&gt;v;</span><br><span class="line">return s.erase(it),s.insert(node(L,x-1,V)),s.insert(node(x,R,V)).first;</span><br><span class="line">&#125;</span><br><span class="line">I void assign(int l,int r,int v)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">s.erase(it1,it2);s.insert(node(l,r,v));</span><br><span class="line">&#125;</span><br><span class="line">I void flip(int l,int r)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">for(;it1!=it2;it1++) it1-&gt;v^=1;</span><br><span class="line">&#125;</span><br><span class="line">I int sum(int l,int r)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);int s=0;</span><br><span class="line">for(;it1!=it2;it1++) s+=it1-&gt;v*(it1-&gt;r-it1-&gt;l+1);</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">I int getmax(int l,int r)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);int s=0,Max=0;</span><br><span class="line">for(;it1!=it2;it1++)</span><br><span class="line">if(it1-&gt;v==1) s+=it1-&gt;r-it1-&gt;l+1,Max=max(Max,s);</span><br><span class="line">else s=0;</span><br><span class="line">return max(Max,s);</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int x,i=0;i&lt;n;i++) x=read(),s.insert(node(i,i,x));</span><br><span class="line">s.insert(node(n,n,0));</span><br><span class="line">for(int op,l,r,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">op=read(),l=read(),r=read();</span><br><span class="line">if(op==0) assign(l,r,0);</span><br><span class="line">if(op==1) assign(l,r,1);</span><br><span class="line">if(op==2) flip(l,r);</span><br><span class="line">if(op==3) write(sum(l,r)),putchar(&#x27;\n&#x27;);</span><br><span class="line">if(op==4) write(getmax(l,r)),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>珂朵莉树 学习笔记</title>
      <link href="/2020/06/06/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/06/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是珂朵莉树？"><a href="#什么是珂朵莉树？" class="headerlink" title="什么是珂朵莉树？"></a>什么是珂朵莉树？</h2><p>珂朵莉树，又称$ODT(Old Driver Tree)$，是一个基于$std::set$的<strong>暴力、玄学</strong>数据结构。</p><h2 id="什么时候使用珂朵莉树？"><a href="#什么时候使用珂朵莉树？" class="headerlink" title="什么时候使用珂朵莉树？"></a>什么时候使用珂朵莉树？</h2><p>如果有一题涉及到区间赋值（即把区间内所有的数全部赋值成同一个量）的操作，且数据随机，就可以<strong>考虑</strong>使用珂朵莉树。</p><p>下面以一道<a href="https://www.luogu.com.cn/problem/CF896C">例题CF896</a>来详解珂朵莉树。</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给你$n$个数，要求进行$m$次操作。</p><ol><li>区间加</li><li>区间赋值</li><li>求区间第$k$小</li><li>求区间每个数的幂的和</li></ol><p>保证<strong>数据随机</strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>珂朵莉树的板子</p><h4 id="首先定义珂朵莉树"><a href="#首先定义珂朵莉树" class="headerlink" title="首先定义珂朵莉树"></a>首先定义珂朵莉树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define It set&lt;node&gt;::iterator//由于set的指针定义实在是太长了，这里先define下</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;//每一个区间的范围</span><br><span class="line">mutable LL val;//该区间内所有的数字都是val</span><br><span class="line">node(int L,int R=-1,LL V=0):l(L),r(R),val(V)&#123;&#125;//生成一个node</span><br><span class="line">bool operator&lt;(const node&amp; q)const&#123;return l&lt;q.l;&#125;//set按照l红黑树</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br></pre></td></tr></table></figure><p>不知道$mutable$？<a href="https://en.cppreference.com/w/cpp/keyword/mutable">点击此了解详情</a></p><h4 id="珂朵莉树操作"><a href="#珂朵莉树操作" class="headerlink" title="珂朵莉树操作"></a>珂朵莉树操作</h4><h5 id="核心操作——split"><a href="#核心操作——split" class="headerlink" title="核心操作——split"></a>核心操作——split</h5><p>如果要修改某一个区间，那么肯定要把区间拆出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I It split(int x)&#123;</span><br><span class="line">It it=s.lower_bound(node(x));//寻找第一个不小于x的点</span><br><span class="line">if(it!=s.end()&amp;&amp;it-&gt;l==x) return it;//如果该区间刚好以x作为左端点，那么直接返回</span><br><span class="line">it--;//否则一定在前一个</span><br><span class="line">int L=it-&gt;l,R=it-&gt;r;LL V=it-&gt;val;//[L,R]区间值为V</span><br><span class="line">s.erase(it);//删除</span><br><span class="line">s.insert(node(L,x-1,V));//插入左边的区间</span><br><span class="line">return s.insert(node(x,R,V)).first;//返回有右边需要的区间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="推平操作——assign"><a href="#推平操作——assign" class="headerlink" title="推平操作——assign"></a>推平操作——assign</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I void assign(int l,int r,LL val)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);//求出区间指针</span><br><span class="line">s.erase(it1,it2);//全部删除</span><br><span class="line">s.insert(node(l,r,val));//新建一个推平区间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>珂朵莉树是靠推平操作来减小复杂度的。由于数据随机，就有约$\frac{1}{4}$的操作是推平操作，使得$set$大小飞速下降，从而保证了复杂度。</p><p>那么为啥要先$split(r+1)$呢？因为如果先$split(l)$根据$split$中的$erase$操作，迭代器$it1$可能会失效。（因为$it1$所属的节点可能被删除了）</p><h5 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I void add(int l,int r,LL val)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);//求出区间指针</span><br><span class="line">for(;it1!=it2;it1++) it1-&gt;val+=val;//暴力扫一次直接加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求区间第k小"><a href="#求区间第k小" class="headerlink" title="求区间第k小"></a>求区间第k小</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I LL grank(int l,int r,int x)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);//求出区间指针</span><br><span class="line">vector&lt;pair&lt;LL,int&gt; &gt; tmp;tmp.clear();//临时定义个vector</span><br><span class="line">for(;it1!=it2;it1++) tmp.push_back(make_pair(it1-&gt;val,it1-&gt;r-it1-&gt;l+1));//将区间内所有数字插入vector</span><br><span class="line">sort(tmp.begin(),tmp.end());//将所有数字排序</span><br><span class="line">for(vector&lt;pair&lt;LL,int&gt; &gt;::iterator it=tmp.begin();it!=tmp.end();it++)&#123;//扫一次找第k小</span><br><span class="line">x-=it-&gt;second;//因为区间上有r-l+1个相同的数，所以一次减去r-l+1</span><br><span class="line">if(x&lt;=0) return it-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求区间每个数的幂的和"><a href="#求区间每个数的幂的和" class="headerlink" title="求区间每个数的幂的和"></a>求区间每个数的幂的和</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inline LL fpow(LL a,LL b,LL mod)&#123;//快速幂</span><br><span class="line">LL s=1;a%=mod;</span><br><span class="line">while(b)&#123;</span><br><span class="line">if(b&amp;1) s*=a,s%=mod;</span><br><span class="line">a*=a,a%=mod;</span><br><span class="line">b&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">I LL sum(int l,int r,LL x,LL y)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);//求出区间指针</span><br><span class="line">LL s=0;</span><br><span class="line">for(;it1!=it2;it1++) s+=(LL)(it1-&gt;r-it1-&gt;l+1)*fpow(it1-&gt;val,x,y)%y,s%=y;//暴力扫每个数求和，别忘记一个区间应该乘上r-l+1</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define I inline </span><br><span class="line">#define LL long long</span><br><span class="line">#define It set&lt;node&gt;::iterator</span><br><span class="line">using namespace std;</span><br><span class="line">inline LL read()&#123;</span><br><span class="line">LL res=0,f=1;char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(LL x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else&#123;</span><br><span class="line">write(x/10);</span><br><span class="line">putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;</span><br><span class="line">mutable LL val;</span><br><span class="line">node(int L,int R=-1,LL V=0):l(L),r(R),val(V)&#123;&#125;</span><br><span class="line">bool operator&lt;(const node&amp; q)const&#123;return l&lt;q.l;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line">inline LL fpow(LL a,LL b,LL mod)&#123;</span><br><span class="line">LL s=1;a%=mod;</span><br><span class="line">while(b)&#123;</span><br><span class="line">if(b&amp;1) s*=a,s%=mod;</span><br><span class="line">a*=a,a%=mod;</span><br><span class="line">b&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">I It split(int x)&#123;</span><br><span class="line">It it=s.lower_bound(node(x));</span><br><span class="line">if(it!=s.end()&amp;&amp;it-&gt;l==x) return it;</span><br><span class="line">it--;</span><br><span class="line">int L=it-&gt;l,R=it-&gt;r;LL V=it-&gt;val;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert(node(L,x-1,V));</span><br><span class="line">return s.insert(node(x,R,V)).first;</span><br><span class="line">&#125;</span><br><span class="line">I void assign(int l,int r,LL val)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">s.erase(it1,it2);</span><br><span class="line">s.insert(node(l,r,val));</span><br><span class="line">&#125;</span><br><span class="line">I void add(int l,int r,LL val)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">for(;it1!=it2;it1++) it1-&gt;val+=val;</span><br><span class="line">&#125;</span><br><span class="line">I LL grank(int l,int r,int x)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">vector&lt;pair&lt;LL,int&gt; &gt; tmp;tmp.clear();</span><br><span class="line">for(;it1!=it2;it1++) tmp.push_back(make_pair(it1-&gt;val,it1-&gt;r-it1-&gt;l+1));</span><br><span class="line">sort(tmp.begin(),tmp.end());</span><br><span class="line">for(vector&lt;pair&lt;LL,int&gt; &gt;::iterator it=tmp.begin();it!=tmp.end();it++)&#123;</span><br><span class="line">x-=it-&gt;second;</span><br><span class="line">if(x&lt;=0) return it-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">I LL sum(int l,int r,LL x,LL y)&#123;</span><br><span class="line">It it2=split(r+1),it1=split(l);</span><br><span class="line">LL s=0;</span><br><span class="line">for(;it1!=it2;it1++) s+=(LL)(it1-&gt;r-it1-&gt;l+1)*fpow(it1-&gt;val,x,y)%y,s%=y;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">LL seed,vmax,a[100010];</span><br><span class="line">I LL rnd()&#123;</span><br><span class="line">LL res=seed;</span><br><span class="line">seed=(seed*7+13)%1000000007;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read(),seed=read(),vmax=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">a[i]=rnd()%vmax+1;</span><br><span class="line">s.insert(node(i,i,a[i]));</span><br><span class="line">&#125;</span><br><span class="line">s.insert(node(n+1,n+1,0));</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">LL op,l,r,x,y;</span><br><span class="line">op=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1;</span><br><span class="line">if(l&gt;r) swap(l,r);</span><br><span class="line">if(op==3) x=rnd()%(r-l+1)+1;</span><br><span class="line">else x=rnd()%vmax+1;</span><br><span class="line">if(op==4) y=rnd()%vmax+1;</span><br><span class="line">if(op==1) add(l,r,x);</span><br><span class="line">else if(op==2) assign(l,r,x);</span><br><span class="line">else if(op==3) write(grank(l,r,x)),putchar(&#x27;\n&#x27;);</span><br><span class="line">else if(op==4) write(sum(l,r,x,y)),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj1774. [Usaco2009 Dec]Toll 过路费 题解</title>
      <link href="/2020/05/26/bzoj1774-usaco2009-dectoll-%E8%BF%87%E8%B7%AF%E8%B4%B9-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/05/26/bzoj1774-usaco2009-dectoll-%E8%BF%87%E8%B7%AF%E8%B4%B9-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><p>一句话题意：给你一个有点权$n$与边权$m$的图，询问$q$次，问两个点间最短路长度。（最短路定义为路径上的边权和+路径上的点权的最大值）</p><p>$1\leq n\leq 250,1\leq m\leq 10000,1\leq q\leq 10000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑到点的数量小于$250$，所以可以$Floyed$求出任意两点之间的最短路径长度，记录答案。</p><p>由于最短路定义为边权和+点权最大值，所以$Floyed$枚举的中间点点权应该从小到大。</p><p>假设$1–&gt;2$有两条路，一条$Sum_d&#x3D;1,Max_v&#x3D;7,cost&#x3D;8$，一条$Sum_d&#x3D;4,Max_v&#x3D;3,cost&#x3D;7$，选择第二条。</p><p>假设$2–&gt;3$有一条路，一条$Sum_d&#x3D;3,Max_v&#x3D;5,cost&#x3D;8$，很容易发现如果一开始选择第一条路的$cost&#x3D;(1+3)+7&#x3D;11$，第二条$cost&#x3D;(4+3)+5&#x3D;12$，很明显，如果一开始选择第一条的话$1–&gt;3$的最短路会更短。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">int n,m,q,f[255][255],ans[255][255],g[255];</span><br><span class="line">struct node&#123;int v,id;&#125;a[255];</span><br><span class="line">inline int cmp(node x,node y)&#123;return x.v&lt;y.v;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read(),q=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i].v=read(),a[i].id=i;</span><br><span class="line">memset(f,63,sizeof(f));</span><br><span class="line">memset(ans,63,sizeof(ans));</span><br><span class="line">for(int i=1;i&lt;=n;i++) f[i][i]=ans[i][i]=a[i].v;</span><br><span class="line">for(int x,y,z,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">x=read(),y=read(),z=read();</span><br><span class="line">f[x][y]=f[y][x]=min(f[x][y],z);</span><br><span class="line">&#125;</span><br><span class="line">sort(a+1,a+n+1,cmp);</span><br><span class="line">for(int i=1;i&lt;=n;i++) g[a[i].id]=i;</span><br><span class="line">#define mid a[k].id</span><br><span class="line">#define val a[k].v</span><br><span class="line">for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">f[i][j]=min(f[i][j],f[i][mid]+f[mid][j]);</span><br><span class="line">ans[i][j]=min(ans[i][j],f[i][j]+max(val,max(a[g[i]].v,a[g[j]].v)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#undef mid</span><br><span class="line">#undef val</span><br><span class="line">for(int x,y,i=1;i&lt;=q;i++)&#123;</span><br><span class="line">x=read(),y=read();</span><br><span class="line">write(ans[x][y]),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> floyed </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米稳定版刷root</title>
      <link href="/2020/05/17/%E5%B0%8F%E7%B1%B3%E7%A8%B3%E5%AE%9A%E7%89%88%E5%88%B7root/"/>
      <url>/2020/05/17/%E5%B0%8F%E7%B1%B3%E7%A8%B3%E5%AE%9A%E7%89%88%E5%88%B7root/</url>
      
        <content type="html"><![CDATA[<p>[admonition title&#x3D;”警告” icon&#x3D;”flag” color&#x3D;”red”]刷机有风险，root需谨慎[&#x2F;admonition]</p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>由于去年入的Redmi7是入门机型，所以莫得开发版，窝就作死的刷了Magisk竟然还成功了QwQ。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="一、解BL锁"><a href="#一、解BL锁" class="headerlink" title="一、解BL锁"></a>一、解BL锁</h3><p>[admonition title&#x3D;”警告” icon&#x3D;”flag” color&#x3D;”red”]解BL锁会抹去手机所有数据，请备份好后操作！[&#x2F;admonition]</p><p>先到小米官网上解BL锁。<a href="http://www.miui.com/unlock/index.html">点击此直达</a></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517131209.png"></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517131441.png"></p><p>手机上：</p><p>1.进入“设置 -&gt; 开发者选项 -&gt; 设备解锁状态”中绑定账号和设备；<br>2.手动进入Bootloader模式（关机后，同时按住开机键和音量下键）；</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517131726.png"></p><p>电脑上：</p><p>解压压缩包，双击“miflash_unlock.exe”</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517131646.png"></p><p>进入后同意并输入小米账号&amp;密码（要和手机上登陆的一样）</p><p>如果无法解锁按步骤申请下即可。</p><p>如果显示当前未连接到手机，安装下驱动试试。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517132000.png"></p><p>等待完成后即可进入系统设置了（变得和新手机一样）。</p><h3 id="二、下载Magisk-zip"><a href="#二、下载Magisk-zip" class="headerlink" title="二、下载Magisk.zip"></a>二、下载Magisk.zip</h3><blockquote><p><strong>Magisk</strong>是一套<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开放源代码</a>的<a href="https://zh.wikipedia.org/wiki/Android">Android</a>（4.2及以上版本）自定义工具套组，内置了Magisk Manager（图形化管理界面）、<a href="https://zh.wikipedia.org/wiki/Root_(Android)">Root</a>、<a href="https://zh.wikipedia.org/wiki/Initrd">启动脚本</a>、<a href="https://zh.wikipedia.org/wiki/SELinux">SElinux补丁</a>和<a href="https://zh.wikipedia.org/wiki/Android%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">启动时认证</a>&#x2F;dm-verity&#x2F;强制加密移除功能。Magisk同时提供了在无需修改系统文件的情况下更改&#x2F;system或&#x2F;vendor分区内容的接口，利用与<a href="https://zh.wikipedia.org/wiki/Xposed%E6%A1%86%E6%9E%B6">Xposed</a>类似的模块系统，开发者可以对系统进行修改或对所安装的软件功能进行修改等。</p><p>Wikipedia</p></blockquote><p>说白了其实就是root工具。</p><p>上<a href="https://magiskmanager.com/">Magisk官网</a>下载Magisk.zip，这里给出一个官网直接下载的<a href="https://github.com/topjohnwu/Magisk/releases/download/v20.4/Magisk-v20.4.zip">链接</a>，当然，这里再给出一个较为<a href="http://106.54.129.33:2333/Magisk-v20.4.zip">友好的链接</a>。</p><p>下载好以后把这个文件直接copy到小米手机的根目录。（连接手机后点击传输文件即可直接copy）</p><h3 id="三、刷入TWRP-Recovery"><a href="#三、刷入TWRP-Recovery" class="headerlink" title="三、刷入TWRP_Recovery"></a>三、刷入TWRP_Recovery</h3><p>使用前也需要先进入fastboot模式。</p><p>在<a href="https://cloud.189.cn/t/NVvIvieaIJb2">此网盘</a>中搜索自己的小米机型，下载一键刷入recovery工具，解压。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517133139.png"></p><p>根据bat提示信息完成刷入并进入TWRP。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517134024.png"></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517134136.png"></p><p>然后完成刷入重启。</p><h3 id="四、Magisk使用"><a href="#四、Magisk使用" class="headerlink" title="四、Magisk使用"></a>四、Magisk使用</h3><p>进入手机后会发现自动安装了Magisk Manager这个软件。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/IMG_20200517_134341.jpg"></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517134529.png"></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517134637.png"></p><h3 id="五、安装太极·阳（可选）"><a href="#五、安装太极·阳（可选）" class="headerlink" title="五、安装太极·阳（可选）"></a>五、安装太极·阳（可选）</h3><p>太极可以帮助您修改app，而不需要重启手机。</p><p><a href="https://taichi.cool/zh/download.html">太极官网</a>，这里给出两个个官网直接下载链接（因为蓝奏还是很友好的，这里就不给出我的云盘了）<a href="https://github.com/taichi-framework/TaiChi/releases">Github</a>，<a href="https://taichi.lanzous.com/ic6xl1i">蓝奏</a></p><p>下载后安装该app。</p><p>然后下载<a href="https://taichi.lanzous.com/icco1ed">太极·阳模块</a></p><p>下载完成后，在Magisk Manager中选择此模块安装（安装完后需要重启，以后就不需要了）</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/IMG_20200517_135325.jpg"></p><p>安装完重启后打开太极app，成功应该会显示此界面。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/IMG_20200517_135437.jpg"></p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/image/20200517135731.png"></p><p>具体使用方法可以参见<a href="https://taichi.cool/zh/doc/">太极官网</a>，或在官网上<a href="https://taichi.cool/zh/module/">下载更多模块</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>root以后就可以为所欲为了</p><p>完结撒花o(*￣▽￣*)ブ</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> magisk </tag>
            
            <tag> root </tag>
            
            <tag> 太极 </tag>
            
            <tag> 小米 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj3137 [Baltic2013]tracks 题解</title>
      <link href="/2020/05/14/bzoj3137-baltic2013tracks-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/05/14/bzoj3137-baltic2013tracks-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><p>给定一片长方形的草地，有<code>2</code><strong>种</strong>动物：兔子和狐狸。兔子走过草地会留下<code>R</code>，狐狸走过草地会留下<code>F</code>。每<strong>只</strong>动物从左上角进入草地，从右下角走出草地。其间，它可以上下左右乱跳（可以重复），经过的格子会被覆盖上它的脚印。每次草地上最多只有一<strong>只</strong>动物。</p><p>给你地图，问最少有多少<strong>只</strong>动物走过了草地。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先将每一个边缘点加入$queue$，再每一次$bfs$选高度最小的点拓展，取最大，计算出每个点最高可达到的水量，最后一减即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">int n,m,a[110][110],b[110][110],vis[110][110],ans;</span><br><span class="line">struct node&#123;int x,y,h;bool operator&lt;(const node &amp;t)const&#123;return h&gt;t.h;&#125;&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">const int dx[]=&#123;0,0,1,-1&#125;,</span><br><span class="line">          dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">inline void spfa()&#123;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node u=q.top();q.pop();</span><br><span class="line">        int x=u.x,y=u.y,h=u.h;</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            int xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">            if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=m)&#123;</span><br><span class="line">                if(vis[xx][yy]) continue ;</span><br><span class="line">                a[xx][yy]=max(a[xx][yy],h);</span><br><span class="line">                vis[xx][yy]=1,q.push((node)&#123;xx,yy,a[xx][yy]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++) b[i][j]=a[i][j]=read();</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">            if(i==1j==1i==nj==m) q.push((node)&#123;i,j,a[i][j]&#125;),vis[i][j]=1;</span><br><span class="line">    spfa();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=1;j&lt;=m;j++)</span><br><span class="line">            ans+=a[i][j]-b[i][j];</span><br><span class="line">    return write(ans),putchar(&#x27;\n&#x27;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4255 公主の#18文明游戏 题解</title>
      <link href="/2020/04/11/luogu-p4255-%E5%85%AC%E4%B8%BB%E3%81%AE18%E6%96%87%E6%98%8E%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/04/11/luogu-p4255-%E5%85%AC%E4%B8%BB%E3%81%AE18%E6%96%87%E6%98%8E%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4255">题目链接</a></p></blockquote><p>这个游戏里有n个城市，标号1<del>n，有m条双向道路相连，编号1</del>m。</p><p>游戏里会系统会添加Ni个人到一个城市Xi，并给定这些人的信仰Ci</p><p>系统还会切断一条道路，并给定道路编号Xi</p><p>系统还会给定一个城市Xi，询问从Xi出发可以到达的所有城市中选择Ni个人，使得他们信仰都为Ci的概率为多少，对19260817取模。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先用并查集搞成各个连通块，然后每个连通块用个$map$储存信仰为$Ci$的个数。再开一个$vector$储存每个连通块有哪些信仰。</p><p>那么每次答案就可以求出信仰为$Ci$的人数$C$和连通块总人数$A$。</p><p>那么答案就是$ans&#x3D;\frac{C_C^Ni}{C_A^Ni}$。</p><p>那么用快速幂逆元一下就好了。</p><p>维护的时候可以用$vector$的$find,erase$和并查集启发式合并即可。</p><p>技巧：由于断边比较困难，所以时间倒流，断边变成连边，加值变成减值。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LL long long</span><br><span class="line">#define mod 19260817</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,q,fa[400010],vis[400010],A,C,ans[400010],Z[400010];</span><br><span class="line">LL fac[400010*4];</span><br><span class="line">inline LL fpow(LL a,LL b)&#123;// 快速幂，求逆元</span><br><span class="line">    LL s=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) s*=a,s%=mod;</span><br><span class="line">        a*=a;a%=mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;E[400010];</span><br><span class="line">struct Question&#123;</span><br><span class="line">    int op,x,y,z;</span><br><span class="line">&#125;Q[400010];</span><br><span class="line">map&lt;int,int&gt; v[400010];</span><br><span class="line">vector&lt;int&gt; g[400010];</span><br><span class="line">inline int getfa(int x)&#123;// 并查集启发式合并</span><br><span class="line">    int a=x,y;</span><br><span class="line">    while(x!=fa[x]) x=fa[x];</span><br><span class="line">    while(a!=x) y=a,a=fa[a],fa[y]=x; </span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">inline void merge(int x,int y)&#123;</span><br><span class="line">    x=getfa(x);y=getfa(y);</span><br><span class="line">    if(x==y) return ;</span><br><span class="line">    if(v[x].size()&lt;v[y].size()) swap(x,y);// 选择小的合并到大的</span><br><span class="line">    fa[y]=x;Z[x]+=Z[y];</span><br><span class="line">    for(int i:g[y])&#123;// 暴力遍历合并</span><br><span class="line">        if(v[x][i]==0&amp;&amp;v[y][i]!=0) g[x].push_back(i);</span><br><span class="line">        v[x][i]+=v[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    Z[y]=0;// 清空</span><br><span class="line">    v[y].clear();</span><br><span class="line">    g[y].clear();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read(),m=read(),q=read(); </span><br><span class="line">    fac[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=4*400000;i++)&#123;</span><br><span class="line">        fac[i]=(LL)fac[i-1]*i%mod;// 预处理阶乘</span><br><span class="line">    &#125;</span><br><span class="line">    for(int x,y,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        v[i].clear();</span><br><span class="line">        g[i].clear();</span><br><span class="line">        g[i].push_back(y);</span><br><span class="line">        v[i][y]+=x;</span><br><span class="line">        Z[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        E[i].x=read(),E[i].y=read();</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=q;i++)&#123;// 先记录再倒序做</span><br><span class="line">        Q[i].op=read();</span><br><span class="line">        if(Q[i].op==1)&#123;</span><br><span class="line">            Q[i].x=read(),Q[i].y=read(),Q[i].z=read();</span><br><span class="line">            if(v[Q[i].x][Q[i].z]==0) g[Q[i].x].push_back(Q[i].z);</span><br><span class="line">            v[Q[i].x][Q[i].z]+=Q[i].y;</span><br><span class="line">            Z[Q[i].x]+=Q[i].y;</span><br><span class="line">        &#125;else if(Q[i].op==2)&#123;</span><br><span class="line">            Q[i].x=read();</span><br><span class="line">            vis[Q[i].x]=1;</span><br><span class="line">        &#125;else if(Q[i].op==3)&#123;</span><br><span class="line">            Q[i].x=read(),Q[i].y=read(),Q[i].z=read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;// 先连不需要删除的边</span><br><span class="line">        if(vis[i]==0) merge(E[i].x,E[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=q;i&gt;=1;i--)&#123;</span><br><span class="line">        if(Q[i].op==1)&#123;</span><br><span class="line">            Q[i].x=getfa(Q[i].x);</span><br><span class="line">            v[Q[i].x][Q[i].z]-=Q[i].y;// 减值</span><br><span class="line">            Z[Q[i].x]-=Q[i].y;</span><br><span class="line">            if(v[Q[i].x][Q[i].z]==0) g[Q[i].x].erase(find(g[Q[i].x].begin(),g[Q[i].x].end(),Q[i].z));// 如果这删完以后是 0 记得删 vector，否则会重复合并</span><br><span class="line">        &#125;else if(Q[i].op==2)&#123;</span><br><span class="line">            merge(E[Q[i].x].x,E[Q[i].x].y);// 连边</span><br><span class="line">        &#125;else if(Q[i].op==3)&#123;</span><br><span class="line">            Q[i].x=getfa(Q[i].x);</span><br><span class="line">            A=C=0;A=Z[Q[i].x];C=v[Q[i].x][Q[i].z];</span><br><span class="line">            LL tmp1=fac[C]*fac[A-Q[i].y]%mod;</span><br><span class="line">            LL tmp2=fac[A]*fac[C-Q[i].y]%mod;</span><br><span class="line">            tmp2=fpow(tmp2,mod-2);// 求逆元</span><br><span class="line">            LL res=tmp1*tmp2;</span><br><span class="line">            res+=mod;res%=mod;</span><br><span class="line">            ans[i]=res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=q;i++)</span><br><span class="line">        if(Q[i].op==3) write(ans[i]),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> stl </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1879 [USACO06NOV]Corn Fields G 题解</title>
      <link href="/2020/04/05/luogu-p1879-usaco06novcorn-fields-g-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/04/05/luogu-p1879-usaco06novcorn-fields-g-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1879">题目链接</a></p></blockquote><p>给一个$M\times N$的矩阵，矩阵每个位置为$0&#x2F;1$，问选一些$1$使这些不相邻的方案数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>明显状压$DP$。</p><p>那么怎么$DP$呢？</p><p>设$f[i][j]$表示第$i$行状态为$j$的方案数。</p><p>那么转移就可以暴力枚举上一行的状态再判断可能性转移。</p><p>$$f[i][j]+&#x3D;f[i-1][k]$$</p><p>那么怎么判断是否可行呢？</p><p>$!j\&amp;(j&lt;&lt;1)\&amp;\&amp;!j\&amp;(j&gt;&gt;1)$表示同一行两个相邻的不能同被选择。</p><p><img src="https://gitee.com/yzx1798106406/picgoimage/raw/master/img/20200405202635.png"></p><p>直观感受</p><p>那么还有什么条件呢？$S[i]\&amp;j\text{^}j$即这个状态必须选择的都是$1$。$!j\&amp;k$即和上一行不要重复。</p><p>那么就直接上代码（逃：</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mod 100000000</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n,S[20],f[20][(1&lt;&lt;13)+10],ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">for(int x,j=1;j&lt;=n;j++)</span><br><span class="line">cin&gt;&gt;x,S[i]=S[i]&lt;&lt;1x;//整合一行信息</span><br><span class="line">f[0][0]=1;//初始化</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;(1&lt;&lt;n);j++)&#123;</span><br><span class="line">if(j&amp;(j&lt;&lt;1)j&amp;(j&gt;&gt;1)S[i]&amp;j^j) continue ;//判断三个条件</span><br><span class="line">for(int k=0;k&lt;(1&lt;&lt;n);k++)&#123;</span><br><span class="line">if(k&amp;j) continue ;//和上一行有冲突</span><br><span class="line">f[i][j]+=f[i-1][k];//累计</span><br><span class="line">f[i][j]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;(1&lt;&lt;n);i++) ans+=f[m][i],ans%=mod;//总和</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1896 [SCOI2005]互不侵犯 题解</title>
      <link href="/2020/04/01/luogu-p1896-scoi2005%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/04/01/luogu-p1896-scoi2005%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1896">题目链接</a></p></blockquote><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p><p>注：数据有加强（2018&#x2F;4&#x2F;25）</p><p>1 &lt;&#x3D;N &lt;&#x3D;9, 0 &lt;&#x3D; K &lt;&#x3D; N * N</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>状压DP。</p><p>判断两个国王是否相互干扰：$i\&amp;j(i&lt;&lt;1)\&amp;ji\&amp;(j&lt;&lt;1)$。</p><p>设$f[i][j][k]$表示第$i$行状态$j$，布置了$k$个国王的方案数。</p><p>$$f[i][j][k]+&#x3D;f[i][p][k-sum[j]]$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long //10年OI一场空，不开long long见祖宗</span><br><span class="line">using namespace std;</span><br><span class="line">int n,K,f[11][1&lt;&lt;10][100],S[1&lt;&lt;10],sum[1&lt;&lt;10],cnt,ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line">for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;</span><br><span class="line">if(i&amp;(i&lt;&lt;1)) continue ;</span><br><span class="line">S[++cnt]=i;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">if((1&lt;&lt;j)&amp;i) sum[cnt]++;</span><br><span class="line">&#125;</span><br><span class="line">f[0][1][0]=1;//初始化</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=cnt;j++)&#123;</span><br><span class="line">for(int k=0;k&lt;=K;k++)&#123;</span><br><span class="line">if(k&lt;sum[j]) continue ;</span><br><span class="line">for(int p=1;p&lt;=cnt;p++)&#123;</span><br><span class="line">if(S[p]&amp;S[j]S[p]&amp;(S[j]&lt;&lt;1)(S[p]&lt;&lt;1)&amp;S[j]) continue ;//是否干扰</span><br><span class="line">f[i][j][k]+=f[i-1][p][k-sum[j]];//DP</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=cnt;i++) ans+=f[n][i][K];//最终答案求和</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1110 [ZJOI2007]报表统计 题解</title>
      <link href="/2020/03/31/luogu-p1110-zjoi2007%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/31/luogu-p1110-zjoi2007%E6%8A%A5%E8%A1%A8%E7%BB%9F%E8%AE%A1-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1110">题目链接</a></p></blockquote><p>小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。</p><p>经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。</p><p>在最开始的时候，有一个长度为$ n$的整数序列$a$，并且有以下三种操作：</p><ul><li><code>INSERT i k</code>：在原数列的第$ i$个元素后面添加一个新元素$ k$；如果原数列的第$ i$个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。</li><li><code>MIN_GAP</code>：查询相邻两个元素的之间差值（绝对值）的最小值。</li><li><code>MIN_SORT_GAP</code>：查询所有元素中最接近的两个元素的差值（绝对值）。</li></ul><p>于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>开两个<a href="http://www.cplusplus.com/reference/set/multiset/">multiset</a>即可。</p><p>一个存放<strong>所有</strong>元素的最小差值，一个存放<strong>相邻</strong>元素的最小差值。</p><p>每次插入一个数字可以处理下前驱和后继即可。</p><p>细节详见代码。</p><p>P.S.千万不要作死用vector.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define It multiset&lt;int&gt;::iterator</span><br><span class="line">#define inf 2000000010//inf不要太小哦</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) x=-x,putchar(&#x27;-&#x27;);</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,Min=inf,las,nxt,tmp,a[500010],b[500010];//a,b分别表示每一段的开头与结尾</span><br><span class="line">multiset&lt;int&gt; v,d;//v表示全部,d表示相邻</span><br><span class="line">char c;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read();m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i]=b[i]=read(),v.insert(a[i]);</span><br><span class="line">v.insert(inf);v.insert(-inf);//防止奇怪错误</span><br><span class="line">for(int i:v) Min=min(Min,abs(i-las)),las=i;//预处理开始的情况</span><br><span class="line">for(int i=2;i&lt;=n;i++) d.insert(abs(a[i]-a[i-1]));//预处理插入相邻之差</span><br><span class="line">for(int x,y,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">c=getchar();while(c!=&#x27;M&#x27;&amp;&amp;c!=&#x27;I&#x27;&amp;&amp;c!=&#x27;N&#x27;&amp;&amp;c!=&#x27;_&#x27;&amp;&amp;c!=&#x27;S&#x27;&amp;&amp;c!=&#x27;O&#x27;&amp;&amp;c!=&#x27;T&#x27;&amp;&amp;c!=&#x27;G&#x27;&amp;&amp;c!=&#x27;A&#x27;&amp;&amp;c!=&#x27;P&#x27;&amp;&amp;c!=&#x27;E&#x27;&amp;&amp;c!=&#x27;R&#x27;) c=getchar();</span><br><span class="line">if(c==&#x27;I&#x27;)&#123;</span><br><span class="line">while(c==&#x27;M&#x27;c==&#x27;I&#x27;c==&#x27;N&#x27;c==&#x27;_&#x27;c==&#x27;S&#x27;c==&#x27;O&#x27;c==&#x27;T&#x27;c==&#x27;G&#x27;c==&#x27;A&#x27;c==&#x27;P&#x27;c==&#x27;E&#x27;c==&#x27;R&#x27;) c=getchar();</span><br><span class="line">x=read();y=read();</span><br><span class="line">las=b[x];</span><br><span class="line">if(x!=n)&#123;</span><br><span class="line">nxt=a[x+1];</span><br><span class="line">tmp=abs(las-nxt);//如果插入一个数必定把前一个数与后一个数隔开，所以要删去</span><br><span class="line">d.erase(d.find(tmp));</span><br><span class="line">d.insert(abs(y-nxt));//插入新的后继</span><br><span class="line">&#125;</span><br><span class="line">d.insert(abs(y-las));//插入新的前驱</span><br><span class="line">b[x]=y;</span><br><span class="line">It pos=v.lower_bound(y);//寻找后继</span><br><span class="line">Min=min(Min,abs(y-*pos));</span><br><span class="line">--pos;//后继-1就是前驱</span><br><span class="line">Min=min(Min,abs(y-*pos));</span><br><span class="line">v.insert(y);//插入总</span><br><span class="line">&#125;else&#123;</span><br><span class="line">c=getchar();c=getchar();c=getchar();c=getchar();</span><br><span class="line">if(c==&#x27;G&#x27;)&#123;</span><br><span class="line">while(c==&#x27;M&#x27;c==&#x27;I&#x27;c==&#x27;N&#x27;c==&#x27;_&#x27;c==&#x27;S&#x27;c==&#x27;O&#x27;c==&#x27;T&#x27;c==&#x27;G&#x27;c==&#x27;A&#x27;c==&#x27;P&#x27;c==&#x27;E&#x27;c==&#x27;R&#x27;) c=getchar();</span><br><span class="line">write(*d.begin());putchar(&#x27;\n&#x27;);//输出最小值</span><br><span class="line">&#125;else&#123;</span><br><span class="line">while(c==&#x27;M&#x27;c==&#x27;I&#x27;c==&#x27;N&#x27;c==&#x27;_&#x27;c==&#x27;S&#x27;c==&#x27;O&#x27;c==&#x27;T&#x27;c==&#x27;G&#x27;c==&#x27;A&#x27;c==&#x27;P&#x27;c==&#x27;E&#x27;c==&#x27;R&#x27;) c=getchar();</span><br><span class="line">write(Min);putchar(&#x27;\n&#x27;);//输出最小值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multiset </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉钉群直播提取视频文件</title>
      <link href="/2020/03/29/%E9%92%89%E9%92%89%E7%BE%A4%E7%9B%B4%E6%92%AD%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/"/>
      <url>/2020/03/29/%E9%92%89%E9%92%89%E7%BE%A4%E7%9B%B4%E6%92%AD%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>[admonition title&#x3D;”Tips” color&#x3D;”red”]如果您打开yzxoi的网盘下载链接页面为白色，请检查浏览器是否使用chrome内核或者使用极速模式，建议使用Google Chrome浏览器[&#x2F;admonition]</p><h2 id="本教程仅供学习研究使用！！！"><a href="#本教程仅供学习研究使用！！！" class="headerlink" title="本教程仅供学习研究使用！！！"></a>本教程仅供学习研究使用！！！</h2><p>教程更新了若干次，2020-&gt;2021.04-&gt;2021.06，如果知友们发现又失效了请联系我。</p><p><strong>目前给定两种方案，若视频是在 2021.06 之前的，可以采用第一种方案，如果是在 2021.06 之后的&#x2F;第一种方案抓不到 M3U8的，可以采用另一种方案，文末会放 FAQ。</strong></p><h2 id="（壹）适用于2021-06-之前的回放视频"><a href="#（壹）适用于2021-06-之前的回放视频" class="headerlink" title="（壹）适用于2021.06 之前的回放视频"></a><strong>（壹）适用于2021.06 之前的回放视频</strong></h2><h3 id="一、安装Fiddler"><a href="#一、安装Fiddler" class="headerlink" title="一、安装Fiddler"></a>一、安装Fiddler</h3><p>提供个官网<a href="https://telerik-fiddler.s3.amazonaws.com/fiddler/FiddlerSetup.exe">下载链接</a>，同样，再带一个比较友好的下载链接：<a href="https://wwa.lanzoui.com/b016dlm4d">https://wwa.lanzoui.com/b016dlm4d</a> 密码:fvap。</p><h3 id="二、设置Fiddler捕捉HTTPS流量"><a href="#二、设置Fiddler捕捉HTTPS流量" class="headerlink" title="二、设置Fiddler捕捉HTTPS流量"></a>二、设置Fiddler捕捉HTTPS流量</h3><p>点击Tools，选择Options…</p><p><img src="https://pic2.zhimg.com/50/v2-277be8d926d431651df0f4b34b037783_b.jpg"></p><p><img src="https://pic2.zhimg.com/50/v2-4c1765b549ddcb5cb0b0dd229db42309_b.jpg"></p><h3 id="三、开始抓包"><a href="#三、开始抓包" class="headerlink" title="三、开始抓包"></a>三、开始抓包</h3><p>P.S.如果您觉得左侧栏东西有点多可以先remove点。</p><p><img src="https://pic3.zhimg.com/50/v2-d4b938c87f70ff2b8d9fbd76aa172c49_b.jpg"></p><p>在钉钉内播放群直播回放，然后返回Fiddler界面。Ctrl+F进入搜索.m3u8即可找到文件。</p><p><img src="https://pic1.zhimg.com/50/v2-57af036a93bd44ddb7d9d9a4b20fecae_b.jpg"></p><p>然后就会自动为您<strong>标黄底黑字</strong>一条记录，右键。</p><p><img src="https://pic2.zhimg.com/50/v2-271fac316cea78d2eacc9519971e19ec_b.jpg"></p><p>随便保存一个位置。</p><p><img src="https://pic4.zhimg.com/50/v2-648a578759d8a93ddb41de05986ea52b_b.jpg"></p><p>随便找个文本编辑器，粘贴复制的url地址，删掉尾缀。</p><p><img src="https://pic2.zhimg.com/50/v2-f4eb3c975c942624497eba0f0f5a3ec2_b.jpg"></p><p>把 M3U8文件拖入下载器（下载器的 <a href="https://github.com/nilaoda/N_m3u8DL-CLI">Github Repo</a>，也可以<a href="https://github.com/nilaoda/N_m3u8DL-CLI/releases/download/2.9.7/N_m3u8DL-CLI_v2.9.7_with_ffmpeg_and_SimpleG.zip">一键下载</a>，当然也可以在我的<a href="http://42.192.40.243/#/s/jRfM">网盘链接</a>中下载，并解压，打开 ***SimpleG.exe），填入BASEURL。</p><p><img src="https://pic2.zhimg.com/50/v2-3101b5d5db502012878bb07712cde445_b.jpg"></p><p>之后点击 GO 开始下载即可。下载完成后默认保存在该目录的<strong>Downloads</strong>文件夹内。</p><h2 id="（贰）适用于-2021-06-之后-x2F-第一种抓不到-m3u8-文件的回放视频"><a href="#（贰）适用于-2021-06-之后-x2F-第一种抓不到-m3u8-文件的回放视频" class="headerlink" title="（贰）适用于 2021.06 之后&#x2F;第一种抓不到 m3u8 文件的回放视频"></a>（贰）适用于 2021.06 之后&#x2F;第一种抓不到 m3u8 文件的回放视频</h2><h3 id="一二步与（壹）相同，这里不重复提。"><a href="#一二步与（壹）相同，这里不重复提。" class="headerlink" title="一二步与（壹）相同，这里不重复提。"></a>一二步与（壹）相同，这里不重复提。</h3><h3 id="三、中间人注入"><a href="#三、中间人注入" class="headerlink" title="三、中间人注入"></a>三、中间人注入</h3><p><img src="https://pic1.zhimg.com/50/v2-8de6c4541e238ce775d7713f09ccea0e_b.jpg"></p><p>选中 Fiddler Script。</p><p><img src="https://pic4.zhimg.com/50/v2-31c623213340128107e2297b270053b2_b.jpg"></p><p>选择 OnBeforeResponse，会自动定位。</p><p><img src="https://pic3.zhimg.com/50/v2-c9fddbb6313aa2b2183f5c08a0c33203_b.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sToInsert = &quot;&lt;script src=&#x27;https://cdn.jsdelivr.net/gh/Tencent/vConsole@3.8.1/dist/vconsole.min.js&#x27;&gt;&lt;/script&gt;&lt;script&gt;var vConsole = new VConsole();&lt;/script&gt;&quot;</span><br><span class="line">oSession.utilDecodeResponse();</span><br><span class="line">oSession.utilReplaceOnceInResponse(&#x27;&lt;/head&gt;&#x27;, sToInsert + &#x27;&lt;/head&gt;&#x27;, 0);</span><br></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/50/v2-856ba1fd9391a2125429e05a7736b056_b.jpg"></p><p>上图应该是 3.8.1 的 vConsole ，懒得重新换图了（</p><h3 id="四、监测流量"><a href="#四、监测流量" class="headerlink" title="四、监测流量"></a>四、监测流量</h3><p>打开钉钉回放页面，发现右下角多了 vConsole，一个绿色的按钮。点击这个按钮，填入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vConsole.showTab(&quot;network&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/50/v2-7961ce7479bbac2a224617023055a0d4_b.jpg"></p><p><img src="https://pic2.zhimg.com/50/v2-bad34df14a09322c45603038184a8553_b.jpg"></p><p><img src="https://pic4.zhimg.com/50/v2-06e46261521ca89976864076e1a27ac8_b.jpg"></p><p>然后丢到 M3U8 下载器（下载器的 <a href="https://github.com/nilaoda/N_m3u8DL-CLI">Github Repo</a>，也可以<a href="https://github.com/nilaoda/N_m3u8DL-CLI/releases/download/2.9.7/N_m3u8DL-CLI_v2.9.7_with_ffmpeg_and_SimpleG.zip">一键下载</a>，当然也可以在我的<a href="http://42.192.40.243/#/s/jRfM">网盘链接</a>中下载，并解压，打开 ***SimpleG.exe）里下载：</p><p><img src="https://pic1.zhimg.com/50/v2-82840a38319ccee1f6a6c8ff2294f7ff_b.jpg"></p><p>等待下载完成即可，下载后的视频在 M3U8 下载器目录下 Downloads 文件夹内。</p><h2 id="钉钉云课堂回放下载"><a href="#钉钉云课堂回放下载" class="headerlink" title="钉钉云课堂回放下载"></a>钉钉云课堂回放下载</h2><p>有知友向我提问，能否下载云课堂回放，其实也可以，比直播回放更加简单：打开 Fiddler，点开视频回放：</p><p><img src="https://pic3.zhimg.com/50/v2-f981547758c777a18bab32dabdde98b4_b.jpg"></p><p>返回 Fiddler，按下 Ctrl+F，搜索 `.mp4`</p><p><img src="https://pic1.zhimg.com/50/v2-6423a415043dd4938cf7968480088ccd_b.jpg"></p><p><img src="https://pic3.zhimg.com/50/v2-3f778ec0fe1e2d6d1b974c3eeb2e75cd_b.jpg"></p><p>右键那一条目，Copy - Just Url。</p><p><img src="https://pic4.zhimg.com/50/v2-7356174e5430a5a11ba4ab602915d031_b.jpg"></p><p>然后粘贴到浏览器地址栏或者任何其他下载器即可下载。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Upd-如果点开视频后抓包软件无反应怎么办？"><a href="#Upd-如果点开视频后抓包软件无反应怎么办？" class="headerlink" title="Upd:如果点开视频后抓包软件无反应怎么办？"></a>Upd:如果点开视频后抓包软件无反应怎么办？</h3><p>检查钉钉登录时是否打开了使用代理。</p><p><img src="https://pic3.zhimg.com/50/v2-7cce99d5f610bac7c3096cbdd2a768be_b.jpg"></p><p><img src="https://pic3.zhimg.com/50/v2-fb0d755728c23d9ea6d5cc8d9aa5c12d_b.jpg"></p><h3 id="Upd-如果抓包显示内容unknown怎么办？"><a href="#Upd-如果抓包显示内容unknown怎么办？" class="headerlink" title="Upd:如果抓包显示内容unknown怎么办？"></a>Upd:如果抓包显示内容unknown怎么办？</h3><p>检查抓包软件的SSL证书是否安装正常，可以尝试重新安装一次。</p><h3 id="Upd-如果抓包显示证书错误怎么办？"><a href="#Upd-如果抓包显示证书错误怎么办？" class="headerlink" title="Upd:如果抓包显示证书错误怎么办？"></a>Upd:如果抓包显示证书错误怎么办？</h3><p>在证书安装的设置中勾选 Check for certificate revocation 选项。或者尝试右上角的 Actions，Reset all</p><p><img src="https://pic4.zhimg.com/50/v2-8a07191c178ffec2e0d47ab602bacab0_b.jpg"></p><h3 id="Upd-如果需要下载多个视频，比较麻烦怎么办？"><a href="#Upd-如果需要下载多个视频，比较麻烦怎么办？" class="headerlink" title="Upd:如果需要下载多个视频，比较麻烦怎么办？"></a>Upd:如果需要下载多个视频，比较麻烦怎么办？</h3><p>可以先抓出所有 M3U8链接，有三种方法批量下载：</p><ol><li>将m3u8链接每行一个存入一个.txt文件，然后将文件直接拖到M3U8地址文本框，点击GO按钮</li><li>将m3u8文件存到一个文件夹中，然后将文件夹直接拖到M3U8地址文本框，点击GO按钮</li><li>新建txt,每行以name,url形式写</li></ol><p>记得别忘记填 BASEURL 哦~</p><h3 id="Upd-如果遇到-M3U8-下载器下载时出现-Error-in-reading-file-怎么办？"><a href="#Upd-如果遇到-M3U8-下载器下载时出现-Error-in-reading-file-怎么办？" class="headerlink" title="Upd:如果遇到 M3U8 下载器下载时出现 Error in reading file 怎么办？"></a>Upd:如果遇到 M3U8 下载器下载时出现 Error in reading file 怎么办？</h3><p>检查 BASEURL 末尾是否加上了 ‘&#x2F;‘</p><h3 id="Upd-如果遇到-Fiddler-出现以下小黄条怎么办？"><a href="#Upd-如果遇到-Fiddler-出现以下小黄条怎么办？" class="headerlink" title="Upd:如果遇到 Fiddler 出现以下小黄条怎么办？"></a>Upd:如果遇到 Fiddler 出现以下小黄条怎么办？</h3><p><img src="https://pic1.zhimg.com/50/v2-4f5a87dacc035e436c0b69994e94a55d_b.jpg"></p><p>尝试点击黄条中央文字，看下是否可以正常工作。如果不行，可以尝试关闭系统代理，重启 Fiddler。</p><p>如果遇到任何问题可以在我的博客文章下方评论栏提出（或者知乎评论也行），我会尽力解答的啦~</p><p>如若您觉得我的教程对您有帮助，可以在文末点击赞赏，请我喝杯咖啡，谢谢啦~</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钉钉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1514 引水入城 题解</title>
      <link href="/2020/03/29/luogu-p1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/29/luogu-p1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.luogu.com.cn/problem/P1514">题目链接</a></p></blockquote><h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><p>在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个$N$行$\times M$列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/299.png"></p><p>为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。</p><p>因此，只有与湖泊毗邻的第$1$行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第$N$行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可以考虑逆向思维，从最后一行开始$DFS$，一直到第$1$行。</p><p>求出最后一行每个点到第一行的可行区间。</p><p>最后再扫一遍贪心下就好了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int res=0,f=1;char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[510][510],inf=2e9,now,ans,p,vis[510][510];</span><br><span class="line">const int dx[]=&#123;0,0,-1,1&#125;,</span><br><span class="line">          dy[]=&#123;1,-1,0,0&#125;;</span><br><span class="line">pair&lt;int,int&gt; q[510];</span><br><span class="line">inline void dfs(int x,int y)&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">if(xx&lt;1yy&lt;1xx&gt;nyy&gt;m) continue ;</span><br><span class="line">if(a[xx][yy]&lt;=a[x][y]) continue ;</span><br><span class="line">if(vis[xx][yy]) continue ;</span><br><span class="line">vis[xx][yy]=1;</span><br><span class="line">if(xx==1) q[now].first=min(q[now].first,yy),q[now].second=max(q[now].second,yy);</span><br><span class="line">dfs(xx,yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++) a[i][j]=read();</span><br><span class="line">for(int i=1;i&lt;=m;i++) q[i]=make_pair(inf,0);</span><br><span class="line">for(int i=1;i&lt;=m;i++) memset(vis,0,sizeof(vis)),vis[n][i]=1,now=i,dfs(n,i);</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">if(q[i].first==inf) ans++;</span><br><span class="line">if(ans) return n==1?(putchar(&#x27;1&#x27;)):(putchar(&#x27;0&#x27;)),putchar(&#x27;\n&#x27;),write(ans),putchar(&#x27;\n&#x27;),0;</span><br><span class="line">sort(q+1,q+m+1);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">if(q[i].first&lt;=p&amp;&amp;p&lt;=q[i].second) continue ;</span><br><span class="line">ans++;p=q[i].second;</span><br><span class="line">&#125;</span><br><span class="line">return putchar(&#x27;1&#x27;),putchar(&#x27;\n&#x27;),write(ans),putchar(&#x27;\n&#x27;),0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3174 [HAOI2009]毛毛虫 题解</title>
      <link href="/2020/03/28/luogu-p3174-haoi2009%E6%AF%9B%E6%AF%9B%E8%99%AB-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/28/luogu-p3174-haoi2009%E6%AF%9B%E6%AF%9B%E8%99%AB-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3174">题目链接</a></p></blockquote><p>对于一棵树，我们可以将某条链和与该链相连的边抽出来，看上去就象成一个毛毛虫，点数越多，毛毛虫就越大。例如下图左边的树（图 $1$）抽出一部分就变成了右边的一个毛毛虫了（图 $2$）。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/7967.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>毛毛虫?</p><p>很明显，我们可以先预处理出每个点的入度。</p><p>显然最后的答案就是$\sum{a_i}-(s-1)+1&#x3D;\sum{a_i-1}+2$（好好想想）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,in[300010],Max,now;</span><br><span class="line">vector&lt;int&gt; v[300010];</span><br><span class="line">inline void DFS(int x,int fa,int sum)&#123;</span><br><span class="line">if(sum&gt;Max)&#123;</span><br><span class="line">Max=sum;</span><br><span class="line">now=x;</span><br><span class="line">&#125;</span><br><span class="line">for(auto i:v[x])</span><br><span class="line">if(fa!=i) DFS(i,x,sum+in[i]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">for(int x,y,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">v[y].push_back(x);</span><br><span class="line">in[x]++;in[y]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++) in[i]--;</span><br><span class="line">DFS(1,0,in[1]);</span><br><span class="line">Max=0;</span><br><span class="line">DFS(now,0,in[now]);</span><br><span class="line">printf(&quot;%d\n&quot;,Max+2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1270 “访问”美术馆 题解</title>
      <link href="/2020/03/28/luogu-p1270-%E8%AE%BF%E9%97%AE%E7%BE%8E%E6%9C%AF%E9%A6%86-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/28/luogu-p1270-%E8%AE%BF%E9%97%AE%E7%BE%8E%E6%9C%AF%E9%A6%86-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1270">题目链接</a></p></blockquote><p>经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要5秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/85.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑$DP$。</p><p>设$f[i][j]$表示前$i$个还有$j$秒时间。</p><p>那么易得：</p><p>$$f[i][j]&#x3D;max(f[ilson][k]+f[irson][time-t[x]-k])(0\leq k \leq time-t[x])$$</p><p>由于路是要走<strong>两次</strong>的（去一次回来一次）所以$t$数组要乘$2$。</p><p>注意小偷一定要在警察来之前跑走，所以$s$要减一。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int s,t[1010],a[1010],f[1010][1010];</span><br><span class="line">inline void init(int x)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;t[x],&amp;a[x]);</span><br><span class="line">t[x]*=2;</span><br><span class="line">if(!a[x]) init(x&lt;&lt;1),init(x&lt;&lt;11);</span><br><span class="line">&#125;</span><br><span class="line">inline int dfs(int x,int tim)&#123;</span><br><span class="line">if(!tim) return 0;</span><br><span class="line">if(f[x][tim]) return f[x][tim]; </span><br><span class="line">if(a[x]) return f[x][tim]=min(a[x],(tim-t[x])/5);</span><br><span class="line">for(int i=0;i&lt;=tim-t[x];i++)</span><br><span class="line">f[x][tim]=max(f[x][tim],dfs(x&lt;&lt;1,i)+dfs(x&lt;&lt;11,tim-t[x]-i));</span><br><span class="line">return f[x][tim];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;s);--s;</span><br><span class="line">init(1);</span><br><span class="line">printf(&quot;%d\n&quot;,dfs(1,s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3413 SAC#1 - 萌数 题解</title>
      <link href="/2020/03/26/luogu-p3413-sac1-%E8%90%8C%E6%95%B0-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/26/luogu-p3413-sac1-%E8%90%8C%E6%95%B0-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3413">题目链接</a></p></blockquote><p>定义“萌数”： 存在长度至少为$2$的回文子串。</p><p>问$[L,R]$中共有多少个萌数字？</p><p>对于$100\%$的数据$0\leq L\leq R \leq {10}^{1000}$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数位$dp$裸题。</p><p>$$DFS(x,las,lasqr,has,lim,st)$$</p><p>分别表示第$x$位，上一个数字是$las$，再上一个数字是$lasqr$，是否到达上限$lim$，是否前导$0$。</p><p>萌数一定是形如$11$或$101$式的，所以只要判断$las&#x3D;&#x3D;ilasqr&#x3D;&#x3D;i$即可。</p><p>注意$L,R$都需要<strong>高精</strong></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1010],m,f[1010][11][2][2][2],ans1,ans2;</span><br><span class="line">inline int DFS(int x,int las,int lasqr,int has,int lim,int st)&#123;//分别表示第$x$位，上一个数字是$las$，再上一个数字是$lasqr$，是否到达上限$lim$，是否前导$0$。</span><br><span class="line">if(x&lt;=0) return has;//结束</span><br><span class="line">if(~f[x][las][has][lim][st]) return f[x][las][has][lim][st];//记忆化</span><br><span class="line">int Max=lim?a[x]:9,res=0;</span><br><span class="line">for(int i=0;i&lt;=Max;i++)</span><br><span class="line">res+=DFS(x-1,i,st?-1:las,has(!st&amp;&amp;i==las)(!st&amp;&amp;i==lasqr),lim&amp;&amp;(i==Max),st&amp;&amp;(i==0))%mod,res%=mod;//注意前导0</span><br><span class="line">if(!st&amp;&amp;~lasqr) f[x][las][has][lim][st]=res;//记忆化</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">inline int solve()&#123;</span><br><span class="line">if(m&lt;=1) return 0;</span><br><span class="line">for(int i=1;i&lt;=m/2;i++) swap(a[i],a[m-i+1]);//读入的时候是反的</span><br><span class="line">memset(f,-1,sizeof(f));</span><br><span class="line">return DFS(m,-1,-1,0,1,1);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;) ch=getchar();</span><br><span class="line">m=0;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) a[++m]=ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">a[m]--;int j=m;while(a[j]==-1) a[j-1]--,a[j]+=10,j--;//L需要-1</span><br><span class="line">ans1=solve();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;) ch=getchar();</span><br><span class="line">m=0;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) a[++m]=ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">ans2=solve();</span><br><span class="line">printf(&quot;%lld\n&quot;,(ans2-ans1+mod)%mod);//别忘记%%%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4127 [AHOI2009]同类分布 题解</title>
      <link href="/2020/03/25/luogu-p4127-ahoi2009%E5%90%8C%E7%B1%BB%E5%88%86%E5%B8%83-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/25/luogu-p4127-ahoi2009%E5%90%8C%E7%B1%BB%E5%88%86%E5%B8%83-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4127">题目链接</a></p></blockquote><p>给出两个数$a,b$，求出$[a,b]$中各位数字之和能整除原数的数的个数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数位dp。</p><p>$DFS(x,sum,dig,lim)$分别表示第$x$位，当前数位之和为$sum$，数字为$dig$，是否到达极限。</p><p>但是数据极大，$dig$会达到${10}^{18}$是不可能来记忆化的，所以考虑<strong>取模</strong></p><p>那么模多少好呢？很明显如果模$sum$是最好的，最后只要判断下是否等于$0$即可。</p><p>那么暴力跑$9\times len$次数位$dp$，求的是$sum&#x3D;&#x3D;i$时的数位$dp$结果，最后加起来就好了。</p><p>P.S.这里参考了讨论区神仙的优化：如果最后各个数位之和绝对到不了要求的话直接$return 0$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">int a[21],m,mod,f[21][201][201][2];</span><br><span class="line">inline int DFS(int x,int sum,int dig,int lim)&#123;</span><br><span class="line">if(sum+9*x&lt;mod) return 0;//优化</span><br><span class="line">if(x==0) return sum==mod&amp;&amp;dig==0;</span><br><span class="line">if(~f[x][sum][dig][lim]) return f[x][sum][dig][lim];</span><br><span class="line">int Max=lim?a[x]:9,res=0;</span><br><span class="line">for(int i=0;i&lt;=Max;i++) res+=DFS(x-1,sum+i,(dig*10+i)%mod,lim&amp;&amp;(i==Max));</span><br><span class="line">return f[x][sum][dig][lim]=res;</span><br><span class="line">&#125;</span><br><span class="line">inline int solve(int n)&#123;</span><br><span class="line">m=0;</span><br><span class="line">while(n)&#123;</span><br><span class="line">a[++m]=n%10;</span><br><span class="line">n/=10;</span><br><span class="line">&#125;</span><br><span class="line">int res=0;</span><br><span class="line">for(mod=1;mod&lt;=m*9;mod++) memset(f,-1,sizeof(f)),res+=DFS(m,0,0,1);//暴力枚举模数</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int L,R;</span><br><span class="line">signed main()&#123;return scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R),printf(&quot;%lld\n&quot;,solve(R)-solve(L-1)),0;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4124 [CQOI2016]手机号码 题解</title>
      <link href="/2020/03/24/luogu-p4124-cqoi2016%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/24/luogu-p4124-cqoi2016%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P4124">题目链接</a></p></blockquote><p>人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。 工具需要检测的号码特征有两个：号码中要出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。 手机号码一定是 $11$ 位数，前不含前导的 $0$。工具接收两个数 $L$ 和 $R$，自动统计出 $[L,R]$ 区间内所有满足条件的号码数量。$L$ 和 $R$ 也是 $11$ 位的手机号码。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>数位dp 注意细节</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long </span><br><span class="line">using namespace std;</span><br><span class="line">int a[15],m,f[15][10][10][2][2][2][2][2];</span><br><span class="line">inline int DFS(int x,int las,int lasqr,int has,int is4,int is8,int lim,int st)&#123;</span><br><span class="line">    if(is4&amp;&amp;is8) return 0;</span><br><span class="line">    if(x==0) return has;</span><br><span class="line">    if(~f[x][las][lasqr][has][is4][is8][lim][st]) return f[x][las][lasqr][has][is4][is8][lim][st];</span><br><span class="line">    int Max=lim?a[x]:9,res=0;</span><br><span class="line">    for(int i=0;i&lt;=Max;i++)</span><br><span class="line">        if(st==1) res+=DFS(x-1,i,las,has,is4(i==4),is8(i==8),lim&amp;&amp;(i==Max),st&amp;&amp;(i==0));</span><br><span class="line">        else res+=DFS(x-1,i,las,has(las==lasqr&amp;&amp;las==i),is4(i==4),is8(i==8),lim&amp;&amp;(i==Max),st&amp;&amp;(i==0));</span><br><span class="line">    return f[x][las][lasqr][has][is4][is8][lim][st]=res;</span><br><span class="line">&#125;</span><br><span class="line">inline int solve(int n)&#123;</span><br><span class="line">    m=0;memset(f,-1,sizeof(f));</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        a[++m]=n%10;</span><br><span class="line">        n/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    return DFS(m,-1,-1,0,0,0,1,1);</span><br><span class="line">&#125;</span><br><span class="line">int L,R;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R);</span><br><span class="line">    printf(&quot;%lld\n&quot;,solve(R)-solve(L-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1801 黑匣子 题解</title>
      <link href="/2020/03/19/luogu-p1801-%E9%BB%91%E5%8C%A3%E5%AD%90-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/19/luogu-p1801-%E9%BB%91%E5%8C%A3%E5%AD%90-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1801">题目链接</a></p></blockquote><p>Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。 命令只有两种： ADD(x):把x元素放进BlackBox; GET:i加1，然后输出Blackhox中第i小的数。 记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如： 我们来演示一下一个有11个命令的命令串。（如下图所示） <img src="https://cdn.luogu.com.cn/upload/pic/661.png"> 现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串： 1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A&#x3D;(3，1，一4，2，8，-1000，2)。 2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u&#x3D;(l，2，6，6)。输入数据不用判错。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>维护一个小根堆、大根堆。 大根堆中存储$i$个数据，且这$i$个数据比小根堆中的都要小。 那么每次$GET$就取小根堆的堆顶。 每次$ADD$就把数据存到大根堆中，然后再择劣$push$到小根堆中。 每轮结束后记得要$push$回一个到大根堆，为下次做准备。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n,a[200010],k=1;</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><br><span class="line">priority_queue&lt;int&gt; Q;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int x,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        for(int j=k;j&lt;=x;j++)&#123;</span><br><span class="line">            Q.push(a[j]);</span><br><span class="line">            if(Q.size()==i) q.push(Q.top()),Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,q.top());</span><br><span class="line">        Q.push(q.top()),q.pop();</span><br><span class="line">        k=x+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1273 有线电视网 题解</title>
      <link href="/2020/03/18/luogu-p1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/18/luogu-p1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P1273">题目链接</a></p></blockquote><p>某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>类似于分组背包。 设$f[i][j]$表示第$i$个子树，使用$j$个的最大钱数。 $f[i][j]&#x3D;$$max(f[i][j-k]$$+f[to][k]-$$w[edge])$ 那么转移就好了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,fir[3010],nxt[3010],w[3010],son[3010],tot,v[3010],f[3010][3010];</span><br><span class="line">inline void add(int x,int y,int z)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;&#125;</span><br><span class="line">inline int DFS(int x)&#123;</span><br><span class="line">    if(n-m+1&lt;=x&amp;&amp;x&lt;=n)&#123;</span><br><span class="line">        f[x][1]=v[x];</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int tmp,to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        to=son[i];</span><br><span class="line">        tmp=DFS(to);</span><br><span class="line">        sum+=tmp;</span><br><span class="line">        for(int j=sum;j;j--)&#123;</span><br><span class="line">            for(int k=1;k&lt;=tmp;k++)&#123;</span><br><span class="line">                if(j-k&gt;=0) f[x][j]=max(f[x][j],f[x][j-k]+f[to][k]-w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int x,y,z,i=1;i&lt;=n-m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        for(;x;x--) scanf(&quot;%d%d&quot;,&amp;y,&amp;z),add(i,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n-m+1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;v[i]);</span><br><span class="line">    memset(f,-63,sizeof(f));</span><br><span class="line">    for(int i=1;i&lt;=n;i++) f[i][0]=0;</span><br><span class="line">    DFS(1);</span><br><span class="line">    for(int i=m;i&gt;=1;i--)&#123;</span><br><span class="line">        if(f[1][i]&gt;=0)&#123;printf(&quot;%d &quot;,i);break;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
            <tag> 分组背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2585 [ZJOI2006]三色二叉树 题解</title>
      <link href="/2020/03/17/luogu-p2585-zjoi2006%E4%B8%89%E8%89%B2%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/17/luogu-p2585-zjoi2006%E4%B8%89%E8%89%B2%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2585">题目链接</a></p></blockquote><p><img src="https://cdn.luogu.com.cn/upload/pic/1705.png"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$0-$绿色，$1-$红色，$2-$蓝色。 设$f[i][j]$表示$i$节点染成$j$这种颜色的最大值。 如果$i$节点的没有儿子，那么很明显$f[i][0]&#x3D;1$。 如果$i$节点有一个儿子，那么$f[i][0]&#x3D;max(f[to][1],f[to][2])+1,f[i][1]&#x3D;max(f[to][0],f[to][2])$（颜色染成蓝色与红色类似） 如果$i$节点有两个儿子，那么$f[i][0]&#x3D;max(f[lson][1]+f[rson][2],f[lson][2]+f[rson][1])+1$（颜色染成红色、蓝色只需不用$-1$即可） 最大值如此，最小值类似。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[500010];</span><br><span class="line">int f[500010][3],g[500010][3],tot;</span><br><span class="line">inline void DFS(int x)&#123;</span><br><span class="line">    if(str[x]==&#x27;0&#x27;)&#123;</span><br><span class="line">        f[x][0]=g[x][0]=1;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;else if(str[x]==&#x27;1&#x27;)&#123;</span><br><span class="line">        int son=x+1;</span><br><span class="line">        DFS(++tot);</span><br><span class="line">        f[x][0]=max(f[son][1],f[son][2])+1;</span><br><span class="line">        f[x][1]=max(f[son][0],f[son][2]);</span><br><span class="line">        f[x][2]=max(f[son][0],f[son][1]);</span><br><span class="line">        g[x][0]=min(g[son][1],g[son][2])+1;//最小值</span><br><span class="line">        g[x][1]=min(g[son][0],g[son][2]);</span><br><span class="line">        g[x][2]=min(g[son][0],g[son][1]);</span><br><span class="line">    &#125;else if(str[x]==&#x27;2&#x27;)&#123;</span><br><span class="line">        int l=x+1;DFS(++tot);</span><br><span class="line">        int r=tot+1;DFS(++tot);</span><br><span class="line">        f[x][0]=max(f[l][1]+f[r][2],f[l][2]+f[r][1])+1;</span><br><span class="line">        f[x][1]=max(f[l][0]+f[r][2],f[l][2]+f[r][0]);</span><br><span class="line">        f[x][2]=max(f[l][0]+f[r][1],f[l][1]+f[r][0]);</span><br><span class="line">        g[x][0]=min(g[l][1]+g[r][2],g[l][2]+g[r][1])+1;//最小值</span><br><span class="line">        g[x][1]=min(g[l][0]+g[r][2],g[l][2]+g[r][0]);</span><br><span class="line">        g[x][2]=min(g[l][0]+g[r][1],g[l][1]+g[r][0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;str+1;</span><br><span class="line">    DFS(++tot);</span><br><span class="line">    cout&lt;&lt;max(f[1][0],max(f[1][1],f[1][2]))&lt;&lt;&quot; &quot;&lt;&lt;min(g[1][0],min(g[1][1],g[1][2]))&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P5060 旅行 题解</title>
      <link href="/2020/03/16/luogu-p5060-%E6%97%85%E8%A1%8C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/16/luogu-p5060-%E6%97%85%E8%A1%8C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P5060">题目链接</a></p></blockquote><p>给定一个 $N$ 个点， $M$ 条边的有向图，求从 $A$ 到 $B$ 的路径上边权和是 $P$ 的倍数的最短路径的长度及路径。 对于所有数据，$2\leq N \leq$$ 5\times $${10}^{4}$$,M\leq$$ 2 \times {10}^5$$ , 1\leq P $$\leq 50$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设$dis[i][j]$表示从起点出发走到$i$的路径边权和$\% P&#x3D;j$的最小值。 那么跑一次$Dijikstra$即可。 注意转移$dis[to][v+w[i]]&#x3D;dis[u][v]+w[i]$。 保存路径可以记录根节点最后递归输出。 由于此题出题人不是特别友好，所以此题卡$spfa$，本人亲测$spfa$只有$80pts$。</p><blockquote><p>关于spfa，她死了</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long //注意此题数据范围要开long long</span><br><span class="line">using namespace std;</span><br><span class="line">char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf;</span><br><span class="line">#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)//fread快读</span><br><span class="line">inline int read()&#123;int res=0,f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();return res*f;&#125;</span><br><span class="line">inline void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else write(x/10),putchar(x%10+&#x27;0&#x27;);&#125;</span><br><span class="line">int n,m,p,s,t,fir[50010],nxt[200010],son[200010],w[200010],tot,dis[50010][60],vis[50010][60],pre[50010][60][3],inf;</span><br><span class="line">inline void add(int x,int y,int z)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;&#125;</span><br><span class="line">struct node&#123;int id,val,note;bool operator &lt; (const node &amp;x) const&#123;return val&gt;x.val;&#125;&#125;;</span><br><span class="line">inline node make(int x,int y,int z)&#123;node pp;pp.id=x,pp.val=y,pp.note=z;return pp;&#125;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">inline void dij()&#123;</span><br><span class="line">    while(!q.empty()) q.pop();//清空队列是个好习惯</span><br><span class="line">    dis[s][0]=0;</span><br><span class="line">    q.push(make(s,0,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node u=q.top();q.pop();</span><br><span class="line">        if(vis[u.id][u.note]) continue ;</span><br><span class="line">        vis[u.id][u.note]=1;</span><br><span class="line">        for(int to,i=fir[u.id];i;i=nxt[i])&#123;</span><br><span class="line">            to=son[i];</span><br><span class="line">            if(!vis[to][(u.note+w[i])%p]&amp;&amp;dis[to][(u.note+w[i])%p]&gt;dis[u.id][u.note]+w[i])&#123;</span><br><span class="line">                dis[to][(u.note+w[i])%p]=dis[u.id][u.note]+w[i];</span><br><span class="line">                pre[to][(u.note+w[i])%p][0]=u.id;//记录路径</span><br><span class="line">                pre[to][(u.note+w[i])%p][1]=u.note;</span><br><span class="line">                q.push(make(to,dis[to][(u.note+w[i])%p],(u.note+w[i])%p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void print(int x,int note,int fir)&#123;//递归输出路径</span><br><span class="line">    if(!x) return ;</span><br><span class="line">    print(pre[x][note][0],pre[x][note][1],1);</span><br><span class="line">    write(x);</span><br><span class="line">    if(!fir) return ;//判断不输出第一个-&gt;</span><br><span class="line">    putchar(&#x27;-&#x27;);putchar(&#x27;&gt;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read(),m=read(),p=read(),s=read(),t=read();</span><br><span class="line">    for(int x,y,z,i=1;i&lt;=m;i++) x=read(),y=read(),z=read(),add(x,y,z);//有向图</span><br><span class="line">    memset(dis,63,sizeof(dis));inf=dis[0][0];//清零</span><br><span class="line">    dij();</span><br><span class="line">    if(dis[t][0]==inf) puts(&quot;jjc fails in travelling&quot;);</span><br><span class="line">    else write(dis[t][0]),putchar(&#x27;\n&#x27;),print(t,0,0),putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> Dijikstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2656 采蘑菇 题解</title>
      <link href="/2020/03/15/luogu-p2656-%E9%87%87%E8%98%91%E8%8F%87-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/15/luogu-p2656-%E9%87%87%E8%98%91%E8%8F%87-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2656">题目链接</a></p></blockquote><p>在一个 $N$ 个点， $M$ 条边的有向图中，每条路可以走无数次，边权为 $w_i$ ，边的恢复系数为 $p_i$ 第二次走时，边权变为 $w_i \times {p_i} $ ，第三次走时，边权变为 $w_i \times {p_i} ^ 2$…第 $k$ 次走时，边权变为 $w_i \times {p_i}^{k-1}$（全部向下取整，直到 $0$ 为止） 问，从 $S$ 出发，最大的路径经过的边权和为多少？(可以重复走) 对于所有数据，$N \leq 80,000 , M \leq 200,000 , 0.1\leq p_i \leq 0.8\text{且仅有一位小数},1\leq S \leq N$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，只要我们找到一个环，那么我们就可以不停地走这个环，直到环内所有的边权为$0$，所以，只要找环，缩点再遍历一次就好了。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理出每条边的无限次走后的边权。</p><h3 id="找环-amp-缩点"><a href="#找环-amp-缩点" class="headerlink" title="找环&amp;缩点"></a>找环&amp;缩点</h3><p>看了下$Luogu$题解区内的都是$Tarjan$找环、缩点，那么对于我这种不会$Tarjan$的怎么办呢？当然是用$kosaraju$啦~ 什么是$kosaraju$？可以参考我的<a href="https://yzxoi.xyz/archives/62">这篇</a>博客(此文写的时间久远，写的不好勿喷)。</p><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>找环&amp;缩点后肯定是要重新构造一个有向无环图啦~ 那么怎么构图呢？ 直接暴力枚举每条边如果不是在同一个强连通分量，那么很遗憾这条边不能重复走很多次，那么就两个强连通分量间连接一条$w_i$的边即可。如果在同一个强连通分量，那么把所有在这个强连通分量中的所有边的无限次走后的边权的和存成点权。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>最后从$S$出发跑个$dfs$就好了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LD double</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">struct edge&#123;int u,v,w;&#125;e[200010];</span><br><span class="line">int n,m,fir[80010],nxt[200010],son[200010],w[200010],tot,sum[200010],val[200010],S,dis[80010],vis[80010],d[80010],t;</span><br><span class="line">vector&lt;int&gt; G[80010],P[80010];</span><br><span class="line">inline void add(int x,int y,int z)&#123;++tot;nxt[tot]=fir[x];fir[x]=tot;son[tot]=y;w[tot]=z;&#125;</span><br><span class="line">inline void dfs1(int x)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    for(auto i:G[x])//C++11简易写法</span><br><span class="line">        if(!vis[i]) dfs1(i);</span><br><span class="line">    d[++t]=x;</span><br><span class="line">&#125;</span><br><span class="line">inline void dfs2(int x)&#123;</span><br><span class="line">    vis[x]=t;</span><br><span class="line">    for(auto i:P[x])</span><br><span class="line">        if(!vis[i]) dfs2(i);</span><br><span class="line">&#125;</span><br><span class="line">inline void kosaraju()&#123;//缩点</span><br><span class="line">    memset(vis,0,sizeof(vis));t=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(!vis[i]) dfs1(i);</span><br><span class="line">    memset(vis,0,sizeof(vis));t=0;</span><br><span class="line">    for(int i=n;i&gt;=1;i--)</span><br><span class="line">        if(!vis[d[i]]) ++t,dfs2(d[i]);</span><br><span class="line">&#125;</span><br><span class="line">inline void dfs(int x)&#123;</span><br><span class="line">    if(dis[x]) return ;</span><br><span class="line">    dis[x]=val[x];//别忘记加上点权</span><br><span class="line">    int Max=0;</span><br><span class="line">    for(int to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        to=son[i];</span><br><span class="line">        dfs(to);</span><br><span class="line">        Max=max(Max,dis[to]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dis[x]+=Max;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int x,y,w,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        x=read();y=read();w=read();</span><br><span class="line">        e[i]=(edge)&#123;x,y,w&#125;;</span><br><span class="line">        G[x].push_back(y);</span><br><span class="line">        P[y].push_back(x);//缩点需要建反边</span><br><span class="line">        LD s;scanf(&quot;%lf&quot;,&amp;s);</span><br><span class="line">        while(w)&#123;//预处理出无限次走的边权</span><br><span class="line">            sum[i]+=w;</span><br><span class="line">            w=(LD)w*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kosaraju();</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">        if(vis[e[i].u]!=vis[e[i].v]) add(vis[e[i].u],vis[e[i].v],e[i].w);//不在同一个强连通分量，构图</span><br><span class="line">        else val[vis[e[i].u]]+=sum[i];//在同一个强连通分量，累计点权</span><br><span class="line">    S=read();</span><br><span class="line">    dfs(vis[S]);//最后跑一次dfs求最大值</span><br><span class="line">    printf(&quot;%d\n&quot;,dis[vis[S]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> Kosaraju </tag>
            
            <tag> 缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2900 [USACO08MAR]Land Acquisition G 题解</title>
      <link href="/2020/03/11/luogu-p2900-usaco08marland-acquisition-g-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/11/luogu-p2900-usaco08marland-acquisition-g-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P2900">题目链接</a></p></blockquote><p>Farmer John 准备扩大他的农场，眼前他正在考虑购买 $N$ 块长方形的土地。 如果 FJ 单买一块土地，价格就是土地的面积。但他可以选择并购一组土地，并购的价格为这些土地中最大的长乘以最大的宽。比如 FJ 并购一块 $3 \times 5$ 和一块 $5 \times 3$ 的土地，他只需要支付 $5 \times 5&#x3D;25$ 元， 比单买合算。 FJ 希望买下所有的土地。他发现，将这些土地分成不同的小组来并购可以节省经费。 给定每份土地的尺寸，请你帮助他计算购买所有土地所需的最小费用。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑$dp$，但是怎么$dp$呢？ 很显然，这需要先预处理。 将土地按照$w_i$从小到大排序，那么$l_i$筛选一下，一定是从大到小排序，否则肯定可以省略。 设$f_i$表示前$i$块土地的最小费用，那么有：$$f_i&#x3D;min(f_j+w_{j+1}\times l_{i})(0\leq j &lt;i)$$ 显然，这个式子可以斜率优化。 设$0\leq j&lt;k&lt;i$且$k$比$j$优，则$$f_j+w_{j+1}\times l_{i}\leq f_k+w_{k+1}\times l_{i}$$ 化简一下： $$(f_j-f_k)+l_i\times (w_{j+1}-w_{k+1})\leq 0$$ 即： $$\frac{f_k-f_j}{w_{j+1}-w_{k+1}}\ge l_i$$ 那么愉快的维护一个下凸壳即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LD double</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,q[1000010],l,r;</span><br><span class="line">long long f[100010];</span><br><span class="line">struct node&#123;int w,l;&#125;a[1000010];</span><br><span class="line">inline int cmp(node x,node y)&#123;return x.w&gt;y.w(x.w==y.w&amp;&amp;x.l&gt;y.l);&#125;</span><br><span class="line">inline LD slope(int j,int k)&#123;</span><br><span class="line">    return (LD)((LD)(f[k]-f[j]))/((LD)(a[j+1].w-a[k+1].w));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].w,&amp;a[i].l);</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(a[i].l&gt;a[m].l) a[++m]=a[i];</span><br><span class="line">    l=r=1;q[1]=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        while(l&lt;r&amp;&amp;slope(q[l],q[l+1])&lt;=a[i].l) l++;</span><br><span class="line">        f[i]=f[q[l]]+1ll*a[i].l*a[q[l]+1].w;</span><br><span class="line">        while(l&lt;r&amp;&amp;slope(q[r-1],q[r])&gt;=slope(q[r],i)) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,f[m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3648 [APIO2014]序列分割 题解</title>
      <link href="/2020/03/08/luogu-p3648-apio2014%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/03/08/luogu-p3648-apio2014%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><blockquote><p><a href="https://www.luogu.com.cn/problem/P3648">题目链接</a></p></blockquote><p>你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次： 选择一个有超过一个元素的块（初始时你只有一块，即整个序列） 选择两个相邻元素把这个块从中间分开，得到两个非空的块。 每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。 对于所有的数据，$2\leq n \leq 100000,1\leq k \leq min\left(n-1,200\right)$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑$dp$。 设$s_i&#x3D;\sum_{i&#x3D;1}^n a_i$，$f_{i,j}$表示前$i$个数，分成$j$块。 由题意可得，$f_{i,j}&#x3D;max \left( f_{k,j-1}+s_k\times(s_i-s_k) \right)$ 显然，这个式子可以滚存。 我们设$f_i&#x3D;f_{i,j},g_k&#x3D;f_{k,j-1}$。 上面那个式子就变成了： $$f_i&#x3D;max(g_k+s_k\times(s_i-s_k))(0\leq j &lt; k &lt;i )$$ 显然，这个式子可以斜率优化。 设$k$比$j$更优。 $$g_k+s_k\times(s_i-s_k) \ge g_j+s_j\times(s_i-s_j)$$ 化简一下，可得： $$\frac{(g_j-{s_j}^2)-(g_k-{s_k}^2)}{s_k-s_j}\leq s_i$$ 那么维护一个下凸壳即可。(注意分母可能为$0$)</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LD double</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k,a[100010],q[100010],pre[100010][210];</span><br><span class="line">long long g[100010],f[100010],s[100010];</span><br><span class="line">inline LD slope(int j,int k)&#123;</span><br><span class="line">    return s[j]==s[k]?-2000000000.0:(LD)((LD)((g[j]-s[j]*s[j])-(g[k]-s[k]*s[k])))/((LD)(s[k]-s[j]));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),s[i]=s[i-1]+a[i];</span><br><span class="line">    for(int t=1;t&lt;=k;t++)&#123;</span><br><span class="line">        int l,r;l=r=1;q[1]=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            while(l&lt;r&amp;&amp;slope(q[l],q[l+1])&lt;=s[i]) ++l;</span><br><span class="line">            f[i]=g[q[l]]+s[q[l]]*(s[i]-s[q[l]]);</span><br><span class="line">            pre[i][t]=q[l];</span><br><span class="line">            while(l&lt;r&amp;&amp;slope(q[r-1],q[r])&gt;=slope(q[r],i)) --r;</span><br><span class="line">            q[++r]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) g[i]=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,f[n]);</span><br><span class="line">    for(int i=k,t=n;i&gt;=1;i--) t=pre[t][i],printf(&quot;%d &quot;,t);printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斜率优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 4337 BJOI2015 树的同构</title>
      <link href="/2020/03/08/bzoj-4337-bjoi2015-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"/>
      <url>/2020/03/08/bzoj-4337-bjoi2015-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>树是一种很常见的数据结构。 我们把N个点，N-1条边的连通无向图称为树。 若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。 对于两个树T1和T2，如果能够把树T1的所有点重新标号，使得树T1和树T2完全相 同，那么这两个树是同构的。也就是说，它们具有相同的形态。 现在，给你M个有根树，请你把它们按同构关系分成若干个等价类。 对于100%的数据，$1\leq N ,M \leq 50$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>乍一看这数据这么小，直接乱$Hash$就好了。 我的$Hash$是$dfs$每个子节点的$val$排序一遍然后$\times {base}^i$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register </span><br><span class="line">#define mod 19260817</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line"></span><br><span class="line">class Solve&#123;</span><br><span class="line">    private:</span><br><span class="line">        int m,n,fir[55],nxt[55*2],son[55*2],tot,ans[55][55],put[55];</span><br><span class="line">    public:</span><br><span class="line">        inline void add(int x,int y)&#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            nxt[tot]=fir[x];</span><br><span class="line">            fir[x]=tot;</span><br><span class="line">            son[tot]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int DFS(int x,int fa)&#123;</span><br><span class="line">            int sum=1;</span><br><span class="line">            vector&lt;int&gt; v;v.clear();</span><br><span class="line">            for(int to,i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">                to=son[i];</span><br><span class="line">                if(to==fa) continue ;</span><br><span class="line">                int tmp=DFS(to,x);</span><br><span class="line">                v.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(v.begin(),v.end());</span><br><span class="line">            int base=233;</span><br><span class="line">            for(vector&lt;int&gt;::iterator i=v.begin();i!=v.end();i++)&#123;</span><br><span class="line">                sum+=(*i)*base%mod;sum%=mod;</span><br><span class="line">                base*=233;base%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            m=I.read();</span><br><span class="line">            for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                n=I.read();</span><br><span class="line">                memset(fir,0,sizeof(fir));tot=0;</span><br><span class="line">                for(int x,j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                    x=I.read();</span><br><span class="line">                    if(x==0) continue ;</span><br><span class="line">                    add(x,j);add(j,x);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i][0]=n;</span><br><span class="line">                for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                    ans[i][j]=DFS(j,0);</span><br><span class="line">                &#125;</span><br><span class="line">                sort(ans[i]+1,ans[i]+n+1);</span><br><span class="line">                put[i]=i;</span><br><span class="line">                for(int j=1;j&lt;i;j++)&#123;</span><br><span class="line">                    if(ans[i][0]==ans[j][0])&#123;</span><br><span class="line">                        int ff=0;</span><br><span class="line">                        for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">                            if(ans[j][k]==ans[i][k]) ;</span><br><span class="line">                            else&#123;</span><br><span class="line">                                ff=1;</span><br><span class="line">                                break ;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(ff==0)&#123;</span><br><span class="line">                            put[i]=put[j];</span><br><span class="line">                            break ;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=1;i&lt;=m;i++) cout&lt;&lt;put[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;S.init();&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1084 疫情控制 题解</title>
      <link href="/2020/02/28/luogu-p1084-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/02/28/luogu-p1084-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://www.luogu.com.cn/problem/P1084">Luogu Problem view</a></p><h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><p>有一棵以$1$为根节点的树，现在要在除根节点外的点设立阻拦，使得没有一条路径可以从根节点到任意一个叶子节点。这些阻拦需要$m$个军队来设立，这$m$个军队中第$i$个一开始在点$q_i$上，军队移动的时间等于移动经过的边权之和，问最少要多少时间才能设立完阻拦。注意：不同的军队可以同时移动。 对于$100%$的数据，$2\leq m\leq n\leq 50,000,0\leq w\leq {10}^9$($w$表示边权)。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由题意可知，要求的是最少的时间，所以显而易见可以二分（如果花了更长的时间肯定更可以），接下来就只需要考虑如何写$check$函数。 我们有一个贪心的想法：因为要阻拦从根到叶子节点的路径，所以军队越往上肯定就越好，这样可以阻拦更多的路径。 如果一个军队可以走到根节点，则将这个军队先放一放，因为这个军队可能会走到另一个以根节点的子节点为根的树中去。 如果一个军队不可以走到根节点，则走到能走到的深度最小的点上。 经过这次操作后，再遍历一次，记录还是可以到达的叶子节点。再贪心的思想：剩余时间最少的军队到叶子节点肯定是最优的，然后再操作一遍，把剩余节点按照到根节点的距离进行排序。 现在可能还有一些军队还未设立阻拦，将这些军队按照剩余的时间进行排序，然后与刚刚排序过的剩余的节点一一匹配，这也是个贪心策略，如果所有都能够被匹配则可行，否则不可行。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register </span><br><span class="line">#define N 50010</span><br><span class="line">#define int long long </span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout)</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line"></span><br><span class="line">int n,m,logn,q[N];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; a; </span><br><span class="line">vector&lt;int&gt; v,g;</span><br><span class="line"></span><br><span class="line">class Edge&#123;</span><br><span class="line">    public:</span><br><span class="line">        int fir[N],nxt[N*2],son[N*2],w[N*2],tot;</span><br><span class="line">        inline void add(int x,int y,int z)&#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            nxt[tot]=fir[x];</span><br><span class="line">            fir[x]=tot;</span><br><span class="line">            son[tot]=y;</span><br><span class="line">            w[tot]=z;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;E;</span><br><span class="line"></span><br><span class="line">class LCA&#123;</span><br><span class="line">    public:</span><br><span class="line">        int f[N][25],dis[N][25],dep[N];</span><br><span class="line">        inline void init(int x,int fa)&#123;</span><br><span class="line">            dep[x]=dep[fa]+1;</span><br><span class="line">            for(int i=0;i&lt;logn;i++) f[x][i+1]=f[f[x][i]][i];</span><br><span class="line">            for(int i=0;i&lt;logn;i++) dis[x][i+1]=dis[x][i]+dis[f[x][i]][i];</span><br><span class="line">            for(int to,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(to==fa) continue ;</span><br><span class="line">                f[to][0]=x;dis[to][0]=E.w[i];</span><br><span class="line">                init(to,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;L;</span><br><span class="line"></span><br><span class="line">class Solve&#123;</span><br><span class="line">    private:</span><br><span class="line">        int l,r,mid,ans,vis[N],una[N];</span><br><span class="line">    public:</span><br><span class="line">        inline int dfs(int x,int fa)&#123;</span><br><span class="line">            if(vis[x]==1) return 1;</span><br><span class="line">            re bool ff=0;</span><br><span class="line">            for(int to,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(to==fa) continue ;</span><br><span class="line">                ff=1;</span><br><span class="line">                if(dfs(to,x)==0) return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return ff;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int check(int Max)&#123;</span><br><span class="line">            a.clear();</span><br><span class="line">            v.clear();</span><br><span class="line">            g.clear();</span><br><span class="line">            memset(vis,0,sizeof(vis));</span><br><span class="line">            memset(una,0,sizeof(una));</span><br><span class="line">            for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                re int x=q[i],cnt=0;</span><br><span class="line">                for(int j=logn;j&gt;=0;j--)&#123;</span><br><span class="line">                    if(L.f[x][j]&gt;1&amp;&amp;cnt+L.dis[x][j]&lt;=Max)&#123;</span><br><span class="line">                        cnt+=L.dis[x][j];</span><br><span class="line">                        x=L.f[x][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(L.f[x][0]==1&amp;&amp;cnt+L.dis[x][0]&lt;=Max) a.push_back(make_pair(Max-(cnt+L.dis[x][0]),x));</span><br><span class="line">                else vis[x]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int to,i=E.fir[1];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(dfs(to,1)==0) una[to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(a.begin(),a.end());</span><br><span class="line">            for(auto i=a.begin();i!=a.end();i++)&#123;</span><br><span class="line">                if(una[(*i).second]==1&amp;&amp;(*i).first&lt;L.dis[(*i).second][0]) una[(*i).second]=0;</span><br><span class="line">                else v.push_back((*i).first); </span><br><span class="line">            &#125;</span><br><span class="line">            for(int to,i=E.fir[1];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(una[to]==1) g.push_back(L.dis[to][0]); </span><br><span class="line">            &#125;</span><br><span class="line">            if(v.size()&lt;g.size()) return 0;</span><br><span class="line">            sort(v.begin(),v.end());</span><br><span class="line">            sort(g.begin(),g.end());</span><br><span class="line">            auto i=g.begin(),j=v.begin();</span><br><span class="line">            while(i!=g.end()&amp;&amp;j!=v.end())&#123;</span><br><span class="line">                if((*j)&gt;=(*i)) i++,j++;</span><br><span class="line">                else j++;</span><br><span class="line">            &#125;</span><br><span class="line">            return i==g.end();</span><br><span class="line">        &#125;</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            n=I.read();logn=log2(n)+1;l=r=0;ans=-1;</span><br><span class="line">            for(int x,y,z,i=1;i&lt;n;i++)&#123;</span><br><span class="line">                x=I.read(),y=I.read(),z=I.read();r+=z;</span><br><span class="line">                E.add(x,y,z);</span><br><span class="line">                E.add(y,x,z);</span><br><span class="line">            &#125;</span><br><span class="line">            m=I.read();</span><br><span class="line">            for(int i=1;i&lt;=m;i++) q[i]=I.read();</span><br><span class="line">            L.init(1,0);</span><br><span class="line">        &#125;</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            while(l&lt;=r)&#123;</span><br><span class="line">                mid=l+r&gt;&gt;1;</span><br><span class="line">                if(check(mid)) ans=mid,r=mid-1;</span><br><span class="line">                else l=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;S.init();S.solve();&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> dfs </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>#10168. 「一本通 5.3 练习 3」恨 7 不成妻</title>
      <link href="/2020/02/23/10168-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-3-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E6%81%A8-7-%E4%B8%8D%E6%88%90%E5%A6%BB/"/>
      <url>/2020/02/23/10168-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-3-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E6%81%A8-7-%E4%B8%8D%E6%88%90%E5%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://loj.ac/problem/10168">loj #10168. 「一本通 5.3 练习 3」恨 7 不成妻</a></p><h2 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h2><p>共$T$组数据，求在区间$[L,R]$与$7$无关的数的平方之和。 与$7$有关的数的定义： 1. 整数中某一位是$7$； 2. 整数的每一位加起来的和是$ 7$的整数倍； 3. 这个整数是$7$的整数倍。 $1\leq T\leq 50,1\leq L\leq R\leq {10}^{18}$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这明显是数位$DP$，考虑记忆化搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFS(now,presum,prenum,lim)//依次表示当前位数，之前的和mod 7，之前的数mod 7，该位数之前是否最大</span><br></pre></td></tr></table></figure><p>这个数字枚举完的情况很明显，答案就是presum!&#x3D;0&amp;&amp;prenum!&#x3D;0。 那么数位$DP$就是要维护三个值： 1. 与$7$无关的数字的个数 2. 与$7$无关的数字的和 3. 与$7$无关的数字的平方的和 第一个很简单，直接普通的数位$DP$即可。 第二个其实我们只需要用到它$\mod 7$的结果，所以只要每次$sum&#x3D;(sum\times 10+val)\%7$即可。 第三个维护就需要个数与和。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register </span><br><span class="line">#define int long long </span><br><span class="line">#define eps 1e-5 </span><br><span class="line">#define mod 1000000007 </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int a[30],m,pw[30];</span><br><span class="line">struct node&#123;int ans,sum,sqrsum;&#125;dp[30][10][10];</span><br><span class="line">inline node DFS(int now,int presum,int prenum,int lim)&#123;</span><br><span class="line">    if(!now) return (node)&#123;presum!=0&amp;&amp;prenum!=0,0,0&#125;;</span><br><span class="line">    if(!lim&amp;&amp;~dp[now][presum][prenum].ans) return dp[now][presum][prenum];</span><br><span class="line">    re int Max=lim?a[now]:9;node ans=(node)&#123;0,0,0&#125;,bk;</span><br><span class="line">    for(int i=0;i&lt;=Max;i++)&#123;</span><br><span class="line">        if(i==7) continue ;</span><br><span class="line">        bk=DFS(now-1,(presum+i)%7,(prenum*10+i)%7,lim&amp;&amp;i==Max);</span><br><span class="line">        ans.ans+=bk.ans;ans.ans%=mod;</span><br><span class="line">        ans.sum+=bk.sum;ans.sum%mod;</span><br><span class="line">        ans.sum+=pw[now-1]*i%mod*bk.ans%mod;ans.sum%=mod;</span><br><span class="line">        ans.sqrsum+=bk.sqrsum;ans.sqrsum%=mod;</span><br><span class="line">        ans.sqrsum+=2*pw[now-1]%mod*i%mod*bk.sum%mod;ans.sqrsum%=mod;</span><br><span class="line">        ans.sqrsum+=bk.ans*pw[now-1]%mod*pw[now-1]%mod*i%mod*i%mod;ans.sqrsum%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim) dp[now][presum][prenum]=ans;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">inline int solve(int N)&#123;</span><br><span class="line">    re int x=N;m=0;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        a[++m]=x%10;</span><br><span class="line">        x/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=28;i++)</span><br><span class="line">        for(int j=0;j&lt;10;j++)</span><br><span class="line">            for(int k=0;k&lt;10;k++) dp[i][j][k]=(node)&#123;-1,0,0&#125;;</span><br><span class="line">    return DFS(m,0,0,1).sqrsum;</span><br><span class="line">&#125;</span><br><span class="line">int T,L,R;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    pw[0]=1;for(int i=1;i&lt;=28;i++) pw[i]=pw[i-1]*10,pw[i]%=mod;</span><br><span class="line">    T=I.read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        L=I.read();R=I.read();</span><br><span class="line">        I.write((solve(R)-solve(L-1)+mod)%mod);putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2020/02/16/codeforces-round-620-div-2-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/02/16/codeforces-round-620-div-2-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Before-Read"><a href="#Before-Read" class="headerlink" title="Before Read"></a>Before Read</h2><p>Solve 4 of 7 Rank:1120 Rating Change:+29 1735 → 1764 <a href="http://codeforces.com/contest/1304">Contest Link</a></p><h2 id="A-Two-Rabbits"><a href="#A-Two-Rabbits" class="headerlink" title="A. Two Rabbits"></a>A. Two Rabbits</h2><h3 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h3><p><img src="https://yzxoi.xyz/wp-content/uploads/2020/02/c168c7fa6587ab4b451579fdf3f30b63.png"> 两只可爱的兔子分别从$x,y$出发，相向而行，其中，左边的兔子一次跳$a$个单位，右边的兔子一次跳$b$个单位，数据保证$x&lt;y$。 现有$t(0 \leq t\leq 1000)$组，保证$(0\leq x&lt; y \leq {10}^9 ,1\leq a ,b\leq {10}^9)$。 问每组兔子是否能相遇（都跳$ans$次使其在同一点），若可以输出$ans$否则输出$-1$。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Codeforces的A题一般都是比较简单的qwq 这就是大名鼎鼎的小学相遇问题。 那么直接路程差除以速度和是否是整数即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>（请忽略窝比赛时随手定义的变量名qwq）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int T,x,y,a,b;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    T=I.read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        x=I.read();y=I.read();a=I.read();b=I.read();</span><br><span class="line">        int sb=y-x,nc=b+a;</span><br><span class="line">        if(sb%nc==0)&#123;</span><br><span class="line">            I.write(sb/nc);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            puts(&quot;-1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Longest-Palindrome"><a href="#B-Longest-Palindrome" class="headerlink" title="B. Longest Palindrome"></a>B. Longest Palindrome</h2><h3 id="Describe-1"><a href="#Describe-1" class="headerlink" title="Describe"></a>Describe</h3><p>有$n(1\leq n\leq 100)$个字符串，每个字符串长度均为$m(1\leq m \leq 50)$，你可以选取其中的几个字符串，任意顺序组合，使其为一个回文字符串，输出最长的字符串长度与这个字符串。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>由于所有字符串的长度均为$m$，所以要将两两互相回文的字符串组合即可，比如说样例1（这个bat蝙蝠是不是预示着什么…）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br><span class="line">one</span><br><span class="line">bat</span><br></pre></td></tr></table></figure><p>我们可以$O(N^2 \times M)$的求出两个字符串是否互相回文，比如说$\texttt{tab}$与$\texttt{bat}$互相回文。 那么我们可以将其组合起来。 设我们已经组合出来了$s_i,t_i$是互相回文的，那么答案就是$s_1,s_2,s_3…s_k,t_k,t_{k-1},t_{k-2}…t_1$。 当然这种方法是不完美的。 比如说这个数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab</span><br><span class="line">xxx</span><br><span class="line">bat</span><br></pre></td></tr></table></figure><p>那么显然$xxx$可以放在中间。 所以我们在最后特判一下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">int n,m,dp[110][110],vis[110],ans;//dp[i][j]表示i与j两个字符串是否互相回文,vis[i]表示i是否使用</span><br><span class="line">char a[110][60],stk[110],sbk[110],cnt;//stk,sbk均为输出使用</span><br><span class="line">int kkk[110],tot;//kkk表示可以放在中间的串</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=I.read();m=I.read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            int ff=0;</span><br><span class="line">            for(int k=0;k&lt;m;k++)&#123;</span><br><span class="line">                if(a[i][k]==a[j][m-k-1])&#123;</span><br><span class="line">                    //ff=0;</span><br><span class="line">                &#125;else ff=1;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j]=(ff==0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int ff=0;</span><br><span class="line">        for(int j=0;j&lt;m/2;j++)&#123;</span><br><span class="line">            if(a[i][j]==a[i][m-j-1]) ;</span><br><span class="line">            else ff=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ff==0)&#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            kkk[tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//  cout&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i]==0)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">                if(vis[j]==0&amp;&amp;dp[i][j]==1)&#123;</span><br><span class="line">                    vis[i]=vis[j]=1;</span><br><span class="line">                    ans+=2;</span><br><span class="line">                    stk[++cnt]=i;</span><br><span class="line">                    sbk[cnt]=j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sss=-1;</span><br><span class="line">    for(int i=1;i&lt;=tot;i++)&#123;</span><br><span class="line">        if(vis[kkk[i]]==0)&#123;</span><br><span class="line">            sss=kkk[i];</span><br><span class="line">            ans++;</span><br><span class="line">            break ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans*=m;//别忘记乘上长度</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[stk[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sss==-1 ) ;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i=0;i&lt;m;i++) &#123;</span><br><span class="line">            cout&lt;&lt;a[sss][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=cnt;i&gt;=1;i--)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[sbk[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Air-Conditioner"><a href="#C-Air-Conditioner" class="headerlink" title="C. Air Conditioner"></a>C. Air Conditioner</h2><h3 id="Describe-2"><a href="#Describe-2" class="headerlink" title="Describe"></a>Describe</h3><p>餐厅里有个空调，在任意一个时刻，空调可以关（温度不变），加热（温度$+1$），降温（温度$-1$）。 给出$n(1\leq n\leq 100)$个限制，在$t(1\leq t\leq {10}^9)$时，温度要在$[l,r](-{10}^9 \leq l \leq r \leq {10}^9)$区间之内。 一开始时间为$0$，温度为$m(-{10}^9\leq m \leq {10}^9)$，问能否满足全部限制。 总共$q(1\leq q\leq 500)$组数据。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>显然可以用区间乱搞。 设$L,R$表示当前可以到达的温度区间。 一开始$L&#x3D;R&#x3D;m$。 那么在接下来的时间可以到达$[L-(t_i-t_{i-1}),R-(t_i-t_{i-1})]$内任意一个温度，只要判断是否与$[l_i,r_i]$有相交即可。别忘记最后要更新区间呦~</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int q,n,m,dp[110],nowt,L,R;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int t,l,r;</span><br><span class="line">&#125;a[110];</span><br><span class="line">inline int cmp(node x,node y)&#123;</span><br><span class="line">    return x.t&lt;y.t;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    q=I.read();</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        n=I.read();m=I.read();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            a[i].t=I.read(),a[i].l=I.read(),a[i].r=I.read();</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+1,a+n+1,cmp);//先按照时间从小到大排序</span><br><span class="line">        re int now=m;nowt=0;L=m;R=m;</span><br><span class="line">        int ff=1;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            L-=a[i].t-nowt;</span><br><span class="line">            R+=a[i].t-nowt;//可行范围</span><br><span class="line">            nowt=a[i].t;</span><br><span class="line">            if(a[i].l&lt;=RL&lt;=a[i].r) ;//有相交</span><br><span class="line">            else&#123;</span><br><span class="line">                ff=0;</span><br><span class="line">                break ;</span><br><span class="line">            &#125;</span><br><span class="line">            L=max(L,a[i].l);R=min(R,a[i].r);//更新区间</span><br><span class="line">            if(L&gt;R)&#123;</span><br><span class="line">                ff=0;</span><br><span class="line">                break ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ff==0)&#123;</span><br><span class="line">            puts(&quot;NO&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            puts(&quot;YES&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Shortest-and-Longest-LIS"><a href="#D-Shortest-and-Longest-LIS" class="headerlink" title="D. Shortest and Longest LIS"></a>D. Shortest and Longest LIS</h2><h3 id="Describe-3"><a href="#Describe-3" class="headerlink" title="Describe"></a>Describe</h3><p>给出一个由$&lt;$和$&gt;$组成的序列，第$i$个表示$a_i$和$a_{i+1}$的大小关系，求出两个满足这个条件的序列，其中一个$LIS$最长，一个$LIS$最短，多组询问，询问的序列长度和不超过$2\times {10}^5$。 P.S:LIS是最长不下降子序列长度</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>构造题。 最长构造： <img src="https://yzxoi.xyz/wp-content/uploads/2020/02/2d267c0d1d393b9020d4494578194ac9.png"> 最短构造： <img src="https://yzxoi.xyz/wp-content/uploads/2020/02/50d20a0a27a4f2bdda5845c2e4a21907.png"> 那么构造就好了</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int T,n,m,now;</span><br><span class="line">char a[200010];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    T=I.read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        n=I.read();</span><br><span class="line">        cin&gt;&gt;a+1;m=n;</span><br><span class="line">        for(int j,i=1;i&lt;=n;i=j+1)&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            while(j&lt;n&amp;&amp;a[j]==&#x27;&lt;&#x27;) ++j;</span><br><span class="line">            m-=j-i+1;</span><br><span class="line">            for(int k=m+1;k&lt;=m+j-i+1;k++) I.write(k),putchar(&#x27; &#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">        m=n;now=1;</span><br><span class="line">        for(int j,i=1;i&lt;=n;i=j+1)&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            while(j&lt;n&amp;&amp;a[j]==&#x27;&lt;&#x27;) ++j;</span><br><span class="line">            for(int k=i;k&lt;j;k++) I.write(now),putchar(&#x27; &#x27;),now++;</span><br><span class="line">            I.write(m);putchar(&#x27; &#x27;);</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-1-Trees-and-Queries"><a href="#E-1-Trees-and-Queries" class="headerlink" title="E. 1-Trees and Queries"></a>E. 1-Trees and Queries</h2><h3 id="Describe-4"><a href="#Describe-4" class="headerlink" title="Describe"></a>Describe</h3><p>给定树，$q$此询问如果加入边$(a,b)$,$x$到$y$是否有长度为$k$的路径（不一定是简单路径）。</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>先$LCA$预处理，$logN$求任意两点间距离。 那么加入$(a,b)$边，$x$到$y$的路径只有$3$种情况： - x–&gt; y - x–&gt;a–&gt;b–&gt;y - x–&gt;b–&gt;a–&gt;y 所以乱搞就好了（注意可以走重复点所以直接%2即可）。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int n,m,s;</span><br><span class="line">int Dep[MAXN],f[MAXN][25];</span><br><span class="line">int fir[MAXN],nxt[MAXN*2],son[MAXN*2],tot;</span><br><span class="line">void add(int x,int y)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">&#125;</span><br><span class="line">void init(int u,int fa)&#123;</span><br><span class="line">    Dep[u]=Dep[fa]+1;</span><br><span class="line">    for(int i=0;i&lt;=21;i++)&#123;</span><br><span class="line">        f[u][i+1]=f[f[u][i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">        int to=son[i];</span><br><span class="line">        if(to==fa) continue ;</span><br><span class="line">        f[to][0]=u;</span><br><span class="line">        init(to,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int x,int y)&#123;</span><br><span class="line">    if(Dep[x]&lt;Dep[y]) swap(x,y);</span><br><span class="line">    for(int i=22;i&gt;=0;i--)&#123;</span><br><span class="line">        if(Dep[f[x][i]]&gt;=Dep[y]) x=f[x][i];</span><br><span class="line">        if(x==y) return x;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=22;i&gt;=0;i--)&#123;</span><br><span class="line">        if(f[x][i]!=f[y][i])&#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line">int dist(int x,int y)&#123;</span><br><span class="line">    return Dep[x]+Dep[y]-2*Dep[lca(x,y)];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=I.read();s=1;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        int x=I.read(),y=I.read();</span><br><span class="line">        add(x,y);add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    init(s,0);</span><br><span class="line">    m=I.read();</span><br><span class="line">    for(int x,y,a,b,k,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        x=I.read(),y=I.read(),a=I.read(),b=I.read(),k=I.read();</span><br><span class="line">        swap(x,a);</span><br><span class="line">        swap(y,b);</span><br><span class="line">        int ans=dist(x,y);</span><br><span class="line">        int ff=0;</span><br><span class="line">        if(ans&lt;=k&amp;&amp;(k-ans)%2==0) ff=1;</span><br><span class="line">        ans=dist(x,a)+dist(b,y)+1;</span><br><span class="line">        if(ans&lt;=k&amp;&amp;(k-ans)%2==0) ff=1;</span><br><span class="line">        ans=dist(x,b)+dist(a,y)+1;</span><br><span class="line">        if(ans&lt;=k&amp;&amp;(k-ans)%2==0) ff=1;</span><br><span class="line">        if(ff==1) puts(&quot;YES&quot;);</span><br><span class="line">        else puts(&quot;NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Animal-Observation"><a href="#F-Animal-Observation" class="headerlink" title="F. Animal Observation"></a>F. Animal Observation</h2><p>太难了不会qwq 挂个题解链接：<a href="http://codeforces.com/blog/entry/73934">戳这里</a></p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 数学 </tag>
            
            <tag> CF </tag>
            
            <tag> 区间 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位dp 学习笔记</title>
      <link href="/2020/02/15/%E6%95%B0%E4%BD%8Ddp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/15/%E6%95%B0%E4%BD%8Ddp-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数位dp真的好简单啊qwq</p><h2 id="什么是数位dp"><a href="#什么是数位dp" class="headerlink" title="什么是数位dp"></a>什么是数位dp</h2><p>让我们以这道题为例：<a href="https://www.luogu.com.cn/problem/P2657">Luogu P2657 [SCOI2009]windy数</a> 如果您很懒不想点开题面可以看下面： windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道， 在A和B之间，包括A和B，总共有多少个windy数？ 100%的数据，满足 1 &lt;&#x3D; A &lt;&#x3D; B &lt;&#x3D; 2000000000 。 简单的说就是在$[L,R]$区间中，相邻两个数字之差都大于等于$2$的数字的个数。</p><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>什么windy不windy的，直接for！！！ 伪代码（不标准的，大雾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool CHECK (x) do</span><br><span class="line">    ......</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = L i &lt;= R i++ do</span><br><span class="line">    if CHECK( i ) == 1 do</span><br><span class="line">        ans++</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">print ans </span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>这样显然会TLE。 那么考虑正解——数位dp</p><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>先考虑类似于前缀和的思想。 要求$L<del>R$的个数就相当于求$1\text{</del>}R$的个数-$1\text{<del>}L-1$的个数。 接下来考虑如何求出$1\text{</del>}n$的个数。 我们可以先将$n$按照$10$进制来分解，比如说这个数：$19260817$。 那么我们可以枚举每一位，再枚举$0\text{<del>}9$来统计答案。 举个栗子： 我们枚举出了最高位上的数字是$1$，那么第二位可以是$0\text{</del>}9$的任意一个数，但是这个数与$1$之差的绝对值一定要大于等于$2$（满足题意）。于是我们可以这样： （依旧是丑陋的伪代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 i &lt;= 9 i++ do</span><br><span class="line">    if abs( i - las ) &gt;= 2 do</span><br><span class="line">        ans++</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>当然，为了方便转移，我们要将$ans++$改成$DP(…)$。 相信聪明的小学生一定会发现，**不一定可以枚举到$9$**，换句话说，该位数字的上界不一定是$9$。 比如说这种情况（还是$19260817$）： $\texttt{1926081-}$ 显然这一位不能成为$8$，因为$19260818 &gt; 19260817$。 那么由此，我们可以总结出，这个上界其实就是$n$。 但是我们是按照位来转移的，那么怎么限定条件呢？ 显然，我们可以用$lim$来表示，转移到现在前面几位有没有达到最大值，如果没达到，那么这位可以$0\text{<del>}9$，否则这个位只能$0</del>A[x]$。不理解？举个栗子： $\texttt{1926081-}$的$lim&#x3D;1$。 $\texttt{1926080-}$和$\texttt{1925901-}$的$lim&#x3D;0$。 相信聪明机智的你肯定明白了。 那么可以考虑最后一种特殊的情况：前导$0$。 由题意可知，前导$0$并不算在数字里，所以如果前面是前导$0$可以不用考虑限制条件（相邻绝对值为$2$），由此，可以用一个处理技巧，将前导$0$的$las$处理为$-2$，可以结合代码理解。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register </span><br><span class="line">#define int long long </span><br><span class="line">#define eps 1e-5 </span><br><span class="line">#define mod 1000000007</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int a[30],m,dp[30][30];</span><br><span class="line">inline int DFS(int now,int las,int st,int lim)&#123;</span><br><span class="line">    if(now&gt;m) return 1;//超过了</span><br><span class="line">    if(lim==0&amp;&amp;dp[now][las]!=-1) return dp[now][las];//这位可以是0~9，且以前已经搜过了，直接记忆化调用即可</span><br><span class="line">    re int Max=lim?a[m-now+1]:9,res=0;//确定该位的范围</span><br><span class="line">    for(int i=0;i&lt;=Max;i++)&#123;</span><br><span class="line">        if(abs(i-las)&lt;2) continue ;//不符合题意</span><br><span class="line">        if(st&amp;&amp;i==0) res+=DFS(now+1,-2,1,lim&amp;&amp;i==Max);//该位也是前导0情况</span><br><span class="line">        else res+=DFS(now+1,i,0,lim&amp;&amp;i==Max);//普通情况</span><br><span class="line">    &#125;</span><br><span class="line">    if(!lim&amp;&amp;!st) dp[now][las]=res;//记忆化</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">inline int solve(int n)&#123;</span><br><span class="line">    m=0;re int x=n;while(x)&#123;</span><br><span class="line">        a[++m]=x%10;</span><br><span class="line">        x/=10;</span><br><span class="line">    &#125;//将N拆位</span><br><span class="line">    memset(dp,-1,sizeof(dp));//初始化别忘了＞﹏＜</span><br><span class="line">    return DFS(1,-2,1,1);//将前导0处理为-2，初始化默认有前导0，达到了最大值</span><br><span class="line">&#125;</span><br><span class="line">int L,R;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    L=I.read();R=I.read();</span><br><span class="line">    I.write(solve(R)-solve(L-1));putchar(&#x27;\n&#x27;);//类似于前缀和思想</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>[checkbox checked&#x3D;”flase”]数字游戏[&#x2F;checkbox] [checkbox checked&#x3D;”true”]不要 62[&#x2F;checkbox] [checkbox checked&#x3D;”flase”]恨 7 不成妻[&#x2F;checkbox] [checkbox checked&#x3D;”true”]数字计数[&#x2F;checkbox]</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HHHOJ NOIP2020模拟赛（叁）2020.02.03 题解</title>
      <link href="/2020/02/04/hhhoj-noip2020%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E5%8F%81%EF%BC%892020-02-03-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/02/04/hhhoj-noip2020%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E5%8F%81%EF%BC%892020-02-03-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="A-「NOIP模拟赛-叁」木板"><a href="#A-「NOIP模拟赛-叁」木板" class="headerlink" title="A. 「NOIP模拟赛 叁」木板"></a>A. 「NOIP模拟赛 叁」木板</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将一个边长为$ N $的正方形裁剪成四个直角三角形。注意面积不能为$ 0$。</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200204164423.png"></p><p>三个必要的切割中的两个始终从一个角落$G$进行（图中$G$位于$A$，实际上也可以是$B$、$C$、$D$），第三次切割必须垂直于前面两个之一（在图中，$AE$部分垂直于$EF$部分）。</p><p>切割机仅接受整个坐标值，这意味着$N$必须是整数的，并且点$E$和$F$的坐标必须是整数的。 有时候这可能是不可能的。</p><p>编写一个程序，根据给出的$ N$，确定是否可以将四边形的正方形三角形切割成四个矩形三角形，如果可能的话，可以采用多少种方法来完成。 对于$40%$的数据，$n\leq {10}^{7}$。 对于另$10%$的数据，$n$为质数。 对于$100%$的数据，$n\leq {10} ^ {14}$，不超过$5$组数据。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200204165656.png"></p><p>易证$\triangle ABE \sim \triangle ECF$ 所以$\frac{X}{A}&#x3D;\frac{N}{N-X}$。 也就是$A&#x3D;\frac{X\times (N-X)}{N}$ 因为$A、X、N都是整数$ 所以$\frac{X\times (N-x)}{N}$是整数。 即：$\frac{X\times N - X^2}{N}$ 分式拆分下：$X-\frac{X^2}{N}$是整数。 就是$X^2 \mod N &#x3D;0$。 就是$X^2$可以整除$N$。 设$N&#x3D;\prod {p_i}^{q_i}$（把$N$分解质因数） 那么有$\prod {p_i}^{\lceil \frac{q_i}{2} \rceil }X$。 由于$X$取值范围是$\text{[}1,N\text{)}$。 那么答案就是$\frac{N}{\prod {p_i}^{\lceil \frac{q_i}{2} \rceil }} -1$. 化简下就是$\prod {p_i}^{\lfloor \frac{q_i}{2} \rfloor }-1$。 那么筛下素数再弄个快速幂就好了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re  </span><br><span class="line">#define int long long </span><br><span class="line">#define LD double</span><br><span class="line">#define MAXN 10000000</span><br><span class="line">#define mod 998244353</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">class Solve&#123;</span><br><span class="line">    private:</span><br><span class="line">        int prime[MAXN],tot,ans;</span><br><span class="line">        bool vis[MAXN+5];</span><br><span class="line">    public:</span><br><span class="line">        inline void get_prime()&#123;</span><br><span class="line">            for(int i=2;i&lt;=MAXN;i++)&#123;</span><br><span class="line">                if(vis[i]==0)&#123;</span><br><span class="line">                    prime[++tot]=i;</span><br><span class="line">                    for(int j=2*i;j&lt;=MAXN;j+=i) vis[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int fpow(int a,int b)&#123;</span><br><span class="line">            re int s=1;</span><br><span class="line">            while(b)&#123;</span><br><span class="line">                if(b&amp;1) s*=a;</span><br><span class="line">                a*=a;</span><br><span class="line">                b&gt;&gt;=1;</span><br><span class="line">            &#125;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            ans=1;</span><br><span class="line">            for(int s,i=1;prime[i]&lt;=n&amp;&amp;i&lt;=tot;i++)&#123;</span><br><span class="line">                s=0;</span><br><span class="line">                while(n%prime[i]==0) s++,n/=prime[i];</span><br><span class="line">                ans*=fpow(prime[i],s/2);</span><br><span class="line">            &#125;</span><br><span class="line">            I.write((ans-1ll)*8ll);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    S.get_prime();</span><br><span class="line">    while(n=I.read()) S.solve();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="B-「NOIP模拟赛-叁」卡车"><a href="#B-「NOIP模拟赛-叁」卡车" class="headerlink" title="B. 「NOIP模拟赛 叁」卡车"></a>B. 「NOIP模拟赛 叁」卡车</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>卡车在$ n $个城市之间运送货物，城市由$ n−1$条道路连成网络，使得任意两座城市之间存在唯一的道路。 城市网络中每个城市有一个权值$ d_i$，道路也都有一个权值$w_i$。 对于一条路径，令路径上所有城市权值$ d_i$的最小值为$ {min}_d$，路径上所有道路权值$w_i$的总和为$ {sum}_w$，则该条路径的总权值为$ {min}_d\times {sum}_w$。 路径的起点和终点可以是任意城市，且路径中不能出现重复的城市。 请求网络中所有路径总权值中的最大值。 $n\leq 2\times {10}^5 , 1 \leq d_i ,w_i \leq {10}^9$</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题有多种解法。首先是点分治的思想，在点分治的时候，我们每一次选取一个中心，先统计过中心的路径最大值，然后删掉中心，递归处理其它子树。统计过中心的路径最大值，我们以中心为根深度搜索一遍，一个需要注意的地方是路径的两个端点不能在同一子树内，因为这样可能会重复统计。所以我们把路径按子树分类，然后点权排序以后更新路径按子树分类的最大值和次大值，之和与当前点权的乘积就是答案。</p><p>本题还可以用并查集来解决。将所有点按照权值从大到小排序，对于将当前点和与其相连的所有点依次合并到一个集合中。并查集需要维护当前集合中的最长路径长度和对应的两个端点。在合并两个集合后，最终集合的最长路一定只有两类情况：一类是其中一个集合的最长路，一共有 2 种；一类是由两个集合的最长路的端点互相连接而成，一共有 2×2&#x3D;4 种。需要用到最近公共祖先的算法预处理求两点在树上的距离，离线处理即可。每次合并并查集之后用当前点的权值乘以最长路的总长度来更新最优结果即可。即使这个点不在当前合并后的集合的最长路上也是没有问题的，因为如果这样的话，必然已经在之前得到了对应的结果，这次合并不会对最终结果产生影响。</p><h3 id="Code-–点分治"><a href="#Code-–点分治" class="headerlink" title="Code –点分治"></a>Code –点分治</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re  </span><br><span class="line">#define int long long </span><br><span class="line">#define LD double</span><br><span class="line">#define MAXN 200010</span><br><span class="line">#define mod 998244353</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int n,d[MAXN],vis[MAXN],sz[MAXN],ans,t,cnt;</span><br><span class="line">struct node&#123;int d,w;bool operator &lt;(const node b)const&#123;return d&lt;b.d;&#125;&#125;;</span><br><span class="line">inline node make_node(int x,int y)&#123;node pp;pp=(node)&#123;x,y&#125;;return pp;&#125;</span><br><span class="line">struct Tree&#123;int d,w,t;&#125;tr[MAXN];</span><br><span class="line">inline Tree make_tr(int x,int y,int z)&#123;Tree pp;pp=(Tree)&#123;x,y,z&#125;;return pp;&#125;</span><br><span class="line">inline int cmp(Tree x,Tree y)&#123;return x.d&lt;y.d;&#125;</span><br><span class="line">class Edge&#123;</span><br><span class="line">    public:</span><br><span class="line">        int fir[MAXN*2],nxt[MAXN*2],son[MAXN*2],w[MAXN*2],tot;</span><br><span class="line">        inline void add(int x,int y,int z)&#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            nxt[tot]=fir[x];</span><br><span class="line">            fir[x]=tot;</span><br><span class="line">            son[tot]=y;</span><br><span class="line">            w[tot]=z;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;E;</span><br><span class="line">class Solve&#123;</span><br><span class="line">    public:</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            n=I.read();</span><br><span class="line">            for(int i=1;i&lt;=n;i++) d[i]=I.read();</span><br><span class="line">            for(int x,y,z,i=1;i&lt;n;i++)&#123;</span><br><span class="line">                x=I.read();y=I.read();z=I.read();</span><br><span class="line">                E.add(x,y,z);</span><br><span class="line">                E.add(y,x,z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inline node find(int x,int fa,int siz)&#123;//找当前树的重心</span><br><span class="line">            node res=make_node(2e18,-1);</span><br><span class="line">            re int Max=0;sz[x]=1;</span><br><span class="line">            for(int to,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(vis[to]==1to==fa) continue ;</span><br><span class="line">                res=min(res,find(to,x,siz));</span><br><span class="line">                sz[x]+=sz[to];</span><br><span class="line">                Max=max(Max,sz[to]);</span><br><span class="line">            &#125;</span><br><span class="line">            Max=max(Max,siz-sz[x]);</span><br><span class="line">            res=min(res,make_node(Max,x));</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void Get_Min_And_Sum(int x,int fa,int _d,int w)&#123;//更新点权最小值与边权之和</span><br><span class="line">            tr[++t]=make_tr(_d,w,cnt);</span><br><span class="line">            for(int to,_w,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];_w=E.w[i];</span><br><span class="line">                if(to==favis[to]==1) continue ;</span><br><span class="line">                Get_Min_And_Sum(to,x,min(_d,d[to]),w+_w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int get_nowans()&#123;//当前答案</span><br><span class="line">            sort(tr+1,tr+t+1,cmp);</span><br><span class="line">//          for(int i=1;i&lt;=t;i++)&#123;</span><br><span class="line">//              cout&lt;&lt;tr[i].d&lt;&lt;&quot; &quot;&lt;&lt;tr[i].w&lt;&lt;&quot; &quot;&lt;&lt;tr[i].t&lt;&lt;endl;</span><br><span class="line">//          &#125;</span><br><span class="line">            int res=0,sum1=tr[t].w,sum2=0,T=tr[t].t;</span><br><span class="line">            for(int i=t-1;i&gt;=1;i--)&#123;</span><br><span class="line">                if(tr[i].t!=T) res=max(res,tr[i].d*(tr[i].w+sum1));</span><br><span class="line">                else res=max(res,tr[i].d*(tr[i].w+sum2));</span><br><span class="line">                if(tr[i].w&gt;sum1)&#123;</span><br><span class="line">                    if(tr[i].t==T) sum1=tr[i].w;</span><br><span class="line">                    else sum2=sum1,sum1=tr[i].w,T=tr[i].t;</span><br><span class="line">                &#125;else if(tr[i].w&gt;sum2&amp;&amp;tr[i].t!=T) sum2=tr[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int get(int rt,int tot)&#123;//递归点分治</span><br><span class="line">            int x=find(rt,0,tot).w,res=0;</span><br><span class="line">            t=0;</span><br><span class="line">//          cout&lt;&lt;&quot;Get &quot;&lt;&lt;rt&lt;&lt;&quot; &quot;&lt;&lt;tot&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">            vis[x]=1;</span><br><span class="line">            tr[++t]=make_tr(d[x],0,cnt);</span><br><span class="line">            for(int to,w,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];w=E.w[i];</span><br><span class="line">                if(vis[to]==1) continue ;</span><br><span class="line">                ++cnt;</span><br><span class="line">                Get_Min_And_Sum(to,x,min(d[to],d[x]),w);</span><br><span class="line">            &#125;</span><br><span class="line">            res=max(res,get_nowans());</span><br><span class="line">            for(int to,i=E.fir[x];i;i=E.nxt[i])&#123;</span><br><span class="line">                to=E.son[i];</span><br><span class="line">                if(vis[to]==1) continue ;</span><br><span class="line">                res=max(res,get(to,sz[to]));</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            ans=get(1,n);</span><br><span class="line">            I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;S.init();S.solve();&#125; </span><br></pre></td></tr></table></figure><h2 id="C-「NOIP模拟赛-叁」骆驼"><a href="#C-「NOIP模拟赛-叁」骆驼" class="headerlink" title="C. 「NOIP模拟赛 叁」骆驼"></a>C. 「NOIP模拟赛 叁」骆驼</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>我们都熟悉走马步，现在我们定义一种新的移动方式——骆驼步，它在一个国际棋盘上的移动规则是这样的。</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200204172204.png"></p><p>可以看出，骆驼步可以向八个方向走动，且不能走出棋盘范围。</p><p>现在给出一个$ N\times N $的棋盘，其中$ N $是$5$的倍数。</p><p>你需要从左上角出发，每步按照骆驼步的规则，经过每个格子恰好一次，且当你走了$ N^2−1$步后，你离起点恰好只有一步的距离。</p><p>请给出一种合法的方案。 $N\leq 1000$。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>因为$N$是$5$的倍数。 自然而然地就会想到拿$5\times 5$的矩阵来构造$N\times N$的。 然后乱拼下就好了。</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3054 [USACO12OPEN]跑圈Running Laps 题解</title>
      <link href="/2020/01/27/luogu-p3054-usaco12open%E8%B7%91%E5%9C%88running-laps-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/01/27/luogu-p3054-usaco12open%E8%B7%91%E5%9C%88running-laps-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>农夫约翰让他的$ n (1 \leq n \leq 100,000) $头牛在长度为$ c $的跑道上进行跑$ l $圈的比赛，所有牛从同一起点，以不同的速度开始跑。直到当跑得最快的那一头牛跑完$ l $圈时，所有牛才同时停下。 约翰发现在跑圈过程中发生了几次“超越事件”。其定义是：在比赛结束前某时刻，奶牛$ x $已经超越了奶牛$ y $整整一圈，则称做一次“超越事件”。（注： 至少一圈 ，超越了$\frac{1}{2}$圈，或者超越了$\frac{1}{4}$圈等等都不算。且对于同一对奶牛$(x,y)$不会重复计算次数。） 约翰想知道比赛过程中发生了多少次“超越事件”。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设第$i$头奶牛跑了$a_i$圈，显而易见，$a_i&#x3D;v[i]*(l\div Max)$，其中$Max$为最大速度。 那么将奶牛按照跑的圈数从大到小排序，显而易见答案就是$\lfloor a_i - a_j \rfloor(i&lt;j)$，于是你就可以写出一个$O(N^2)$的程序跑出很好的成绩了 那么想办法优化这个式子，通过乱搞发现$\lfloor a_i \rfloor - \lfloor a_j \rfloor(i&lt;j)$和上面的式子很像啊，于是发现这两个式子最多只相差$1$。 那什么时候会相差$1$呢？举个栗子，当$a_i&#x3D;2.5,a_j&#x3D;1.9$时，这个式子就会多算$1$。但这个式子绝对不会少算。于是我们只要额外统计下多算的情况就好了。不难发现，当小数部分是逆序对时，此时就多算了。 所以把$a_i$分成整数部分$f[i].a$与余数部分$f[i].b$。（为什么不是小数部分呢？因为小数部分比较难以控制——精度问题严重，而除数都是一样的，都是$Max$，所以就用余数更简单啦） 接下来就是套树状数组求逆序对的板子了。 等等，你问我不多算的式子怎么求？直接统计个前缀和乱搞就好了呀…</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re  </span><br><span class="line">#define int long long </span><br><span class="line">#define LD double</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">&#125;f[100010];</span><br><span class="line">inline int cmp(node x,node y)&#123;return x.a&lt;y.a(x.a==y.a&amp;&amp;x.b&lt;y.b);&#125;</span><br><span class="line">class Array_Tree&#123;//树状数组求逆序对</span><br><span class="line">    private:</span><br><span class="line">        int c[1000010];</span><br><span class="line">    public:</span><br><span class="line">        inline void add(int x,int y)&#123;for(;x&lt;=1000000;x+=(x&amp;(-x))) c[x]+=y;&#125;</span><br><span class="line">        inline int getsum(int x)&#123;re int s=0;for(;x&gt;=1;x-=(x&amp;(-x))) s+=c[x];return s;&#125;</span><br><span class="line">        inline int query(int l,int r)&#123;return getsum(r)-getsum(l);&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">class Solve&#123;</span><br><span class="line">    private:</span><br><span class="line">        int n,l,c,v[100010],ans,Max;</span><br><span class="line">    public:</span><br><span class="line">        inline bool init()&#123;</span><br><span class="line">            n=I.read();l=I.read();c=I.read();</span><br><span class="line">            for(int i=1;i&lt;=n;i++) v[i]=I.read(),Max=max(Max,v[i]);</span><br><span class="line">            for(int i=1;i&lt;=n;i++) f[i].a=v[i]*l/Max,f[i].b=v[i]*l%Max;//整数部分和小数部分</span><br><span class="line">        &#125;</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            sort(f+1,f+n+1,cmp);</span><br><span class="line">            for(int sum=0,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                ans+=(f[i].a*(i-1)-sum)-T.query(f[i].b,1000000);//非多算部分-多算部分</span><br><span class="line">                sum+=f[i].a;//更新前缀和</span><br><span class="line">                if(f[i].b&gt;0) T.add(f[i].b,1);//树状数组上传</span><br><span class="line">            &#125;</span><br><span class="line">            I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  File</span><br><span class="line">    S.init();</span><br><span class="line">    S.solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay平衡树 学习笔记</title>
      <link href="/2020/01/20/splay%E5%B9%B3%E8%A1%A1%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/20/splay%E5%B9%B3%E8%A1%A1%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>突然想学$Link Cut Tree$了（当然不是因为我们班里有一个叫$LCT$的人 但是$LCT$有一个非常重要的前置知识，那就是$Splay$，于是就有了此篇文章。</p><h2 id="1-Splay原理"><a href="#1-Splay原理" class="headerlink" title="1 Splay原理"></a>1 Splay原理</h2><h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><p>要想理解$splay$的原理，就得先理解$BST$。 <a href="http://www.algolist.net/Data_structures/Binary_search_tree">二叉查找树(Binary Search Tree,简称BST)</a>是一棵二叉树,它的左子节点的值比父节点的值要小,右节点的值要比父节点的值大。它的高度决定了它的查找效率。 比如这个就是一棵二叉查找树：</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/Snipaste_2020-01-20_15-58-22.png"></p><p>但是如果这棵二叉树变得丑陋点，就成了这样：</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200120162634.png"></p><p>于是最坏查询情况就变成了$O(N)$这就尴尬了。</p><h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h3><p>那么怎么解决如上所示的问题呢？ 于是就变成了各种树。 其中有一位大佬叫$Tarjan$（怎么又是他 发明了$Splay$ 那么$Splay$是怎么解决这个问题的呢？ $Tarjan$想出了旋转。</p><h2 id="2-Splay详解"><a href="#2-Splay详解" class="headerlink" title="2 Splay详解"></a>2 Splay详解</h2><h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><p>如图，我们有一棵二叉树，$X,Y,Z$分别代表三个节点，$A,B,C$分别代表三个子树。</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200120163140.png"></p><p>现在，我们要把这棵二叉树的$X$节点转到$Y$节点的位置。 因为$X$是$Y$的左儿子，所以$X&lt;Y$，所以旋转后$Y$必定是$X$的右儿子。 因为$Y$是$Z$的左儿子，所以$Y&lt;Z$。 所以$X&lt;Z$，所以如果把$X转到Y$，旋转后$X$必定是$Z$的左儿子。 因为$X$的子树及$X$本身构成了$Y$的左儿子，所以$X$的子树及$X$本身一定$&lt;Y$。 所以$X&lt;B&lt;Y$，所以$B$旋转后是$Y$的左儿子。 因为$C$是$Y$的右儿子，所以$C&gt;Y$，旋转后$C$一定是$Y$的右儿子。 而$X$的左儿子$A$是最小的，所以不管他，旋转后$A$还是$X$的左儿子。 检查一遍：$A&lt;X&lt;B&lt;Y&lt;C&lt;Z$没有问题。 现在虽然树的形态变了，但是它还是一棵平衡树，并且好像更好看了（雾 自己再画画看，总共有$4$种情况。</p><p><img src="https://imgupd.oss-cn-beijing.aliyuncs.com/20200120163414.png"></p><p>图画完了，我们可以总结下规律了。</p><ol><li>$X$旋转后到$Y$的位置。</li><li>$Y$旋转后到$X$原来在$Y$的那个儿子的相对的儿子（如果$X$原来是$Y$的左儿子，$Y$旋转后就是$X$的右儿子）。</li><li>$Y$的另一个不是$X$的儿子不变，$X$的原来$X$在$Y$的方向的儿子不变（如果$X$原来是$Y$的左儿子，$X$的左儿子就不变，$Y$的右儿子不变）。</li><li>$X$的原来$X$在$Y$的方向相对的儿子旋转后变成了原来$X$在$Y$方向上的$Y$的儿子（如果$X$原来是$Y$的左儿子，$X$的右儿子就变成了$Y$的左儿子）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline void rotate(int x)&#123;</span><br><span class="line">    re int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;//y为x的父亲，z为y的父亲，x是y的哪个儿子 0 是左儿子，1 是右儿子</span><br><span class="line">    tr[z].ch[tr[z].ch[1]==y]=x;//1.</span><br><span class="line">    tr[x].fa=z;//x的父亲变为z</span><br><span class="line">    tr[y].ch[k]=tr[x].ch[k^1];//4.</span><br><span class="line">    tr[tr[x].ch[k^1]].fa=y;//更新父节点</span><br><span class="line">    tr[x].ch[k^1]=y;//2.</span><br><span class="line">    tr[y].fa=x;//更新父节点</span><br><span class="line">    upd(y);upd(x);//更新每个点的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Splay-1"><a href="#Splay-1" class="headerlink" title="Splay"></a>Splay</h3><p>接下来考虑下一个问题：怎样把一个节点旋转到根节点呢？（比如上文的$X$旋转到$Z$） 先把$X$转到$Y$，再把$Y$转到$Z$？显然这是不行的，可以自己动手画一画，在某些情况下某条链可能仍然存在，这种情况下，$Splay$极有可能会被卡。 图我就不画了（懒 总结在这：</p><ol><li>$X$和$Y$分别是$Y$和$Z$的同一个儿子（如$X$是$Y$的左儿子，$Y$是$Z$的左儿子），先旋转$Y$，再旋转$X$。</li><li>$X$和$Y$分别是$Y$和$Z$的不同儿子（如$X$是$Y$的左儿子，$Y$是$Z$的右儿子），对$X$旋转$2$次。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline void splay(int x,int rt)&#123;</span><br><span class="line">    while(tr[x].fa!=rt)&#123;//直到把x转成rt的儿子</span><br><span class="line">        re int y=tr[x].fa,z=tr[y].fa;//y，z分别为x的父节点、祖节点</span><br><span class="line">        if(z!=rt)//如果z不是根节点，分两类旋转</span><br><span class="line">        (tr[z].ch[0]==y)^(tr[y].ch[0]==x)?rotate(x):rotate(y);//分类</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    if(rt==0) root=x;//如果rt=0,把根节点更新为x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩下的操作"><a href="#剩下的操作" class="headerlink" title="剩下的操作"></a>剩下的操作</h3><p>剩下的操作和普通的$BST$差不多，这里就不再介绍。</p><h2 id="3-Splay-Code"><a href="#3-Splay-Code" class="headerlink" title="3 Splay Code"></a>3 Splay Code</h2><p><a href="https://www.luogu.com.cn/problem/P3369">Luogu P3369 【模板】普通平衡树</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re  </span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;tmp.in&quot;,&quot;r&quot;,stdin);freopen(&quot;tmp.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">class Splay&#123;</span><br><span class="line">//  private:</span><br><span class="line">    public:</span><br><span class="line">        int root,tot;</span><br><span class="line">        struct Tree&#123;</span><br><span class="line">            int fa,ch[2],val,cnt,size;</span><br><span class="line">        &#125;tr[100010];</span><br><span class="line">        inline void upd(int x)&#123;</span><br><span class="line">            tr[x].size=tr[tr[x].ch[0]].size+tr[tr[x].ch[1]].size+tr[x].cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void rotate(int x)&#123;</span><br><span class="line">            re int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;</span><br><span class="line">            tr[z].ch[tr[z].ch[1]==y]=x;</span><br><span class="line">            tr[x].fa=z;</span><br><span class="line">            tr[y].ch[k]=tr[x].ch[k^1];</span><br><span class="line">            tr[tr[x].ch[k^1]].fa=y;</span><br><span class="line">            tr[x].ch[k^1]=y;</span><br><span class="line">            tr[y].fa=x;</span><br><span class="line">            upd(y);upd(x);</span><br><span class="line">        &#125;</span><br><span class="line">        inline void splay(int x,int rt)&#123;</span><br><span class="line">            while(tr[x].fa!=rt)&#123;</span><br><span class="line">                re int y=tr[x].fa,z=tr[y].fa;</span><br><span class="line">                if(z!=rt) (tr[z].ch[0]==y)^(tr[y].ch[0]==x)?rotate(x):rotate(y);</span><br><span class="line">                rotate(x);</span><br><span class="line">            &#125;</span><br><span class="line">            if(rt==0) root=x;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void find(int x)&#123;</span><br><span class="line">            re int u=root;</span><br><span class="line">            if(!u) return ;</span><br><span class="line">            while(tr[u].ch[x&gt;tr[u].val]&amp;&amp;x!=tr[u].val) u=tr[u].ch[x&gt;tr[u].val]; </span><br><span class="line">            splay(u,0);</span><br><span class="line">        &#125;</span><br><span class="line">        inline void insert(int x)&#123;</span><br><span class="line">            re int u=root,ff=0;</span><br><span class="line">            while(u&amp;&amp;tr[u].val!=x)&#123;</span><br><span class="line">                ff=u;</span><br><span class="line">                u=tr[u].ch[x&gt;tr[u].val];</span><br><span class="line">            &#125;</span><br><span class="line">            if(u) tr[u].cnt++;</span><br><span class="line">            else&#123;</span><br><span class="line">                u=++tot;</span><br><span class="line">                if(ff) tr[ff].ch[x&gt;tr[ff].val]=u;</span><br><span class="line">                tr[u].ch[0]=tr[u].ch[1]=0;</span><br><span class="line">                tr[u].fa=ff;</span><br><span class="line">                tr[u].val=x;</span><br><span class="line">                tr[u].cnt=1;</span><br><span class="line">                tr[u].size=1;</span><br><span class="line">            &#125;</span><br><span class="line">            splay(u,0);</span><br><span class="line">        &#125;</span><br><span class="line">        inline int pre(int x)&#123;</span><br><span class="line">            find(x);</span><br><span class="line">            re int u=root;</span><br><span class="line">            if(tr[u].val&lt;x) return u;</span><br><span class="line">            u=tr[u].ch[0];</span><br><span class="line">            while(tr[u].ch[1]) u=tr[u].ch[1];</span><br><span class="line">            return u;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int nxt(int x)&#123;</span><br><span class="line">            find(x);</span><br><span class="line">            re int u=root;</span><br><span class="line">            if(tr[u].val&gt;x) return u;</span><br><span class="line">            u=tr[u].ch[1];</span><br><span class="line">            while(tr[u].ch[0]) u=tr[u].ch[0];</span><br><span class="line">            return u;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void del(int x)&#123;</span><br><span class="line">            re int Pre=pre(x),Nxt=nxt(x);</span><br><span class="line">            splay(Pre,0);splay(Nxt,Pre);</span><br><span class="line">            re int Del=tr[Nxt].ch[0];</span><br><span class="line">//          cout&lt;&lt;&quot;deling &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;Del&lt;&lt;&#x27; &#x27;&lt;&lt;tr[Del].cnt&lt;&lt;endl;</span><br><span class="line">            if(tr[Del].cnt&gt;1) tr[Del].cnt--,splay(Del,0);</span><br><span class="line">            else tr[Nxt].ch[0]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int rank(int x)&#123;</span><br><span class="line">            re int u=root;</span><br><span class="line">            if(tr[u].size&lt;x) return 0;</span><br><span class="line">            while(1)&#123;</span><br><span class="line">                re int y=tr[u].ch[0];</span><br><span class="line">                if(x&gt;tr[y].size+tr[u].cnt) x-=tr[y].size+tr[u].cnt,u=tr[u].ch[1];</span><br><span class="line">                else if(tr[y].size&gt;=x) u=y;</span><br><span class="line">                else return tr[u].val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int Rank(int x)&#123;</span><br><span class="line">            find(x);</span><br><span class="line">            return tr[tr[root].ch[0]].size;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void PrintSplay()&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Now Root = &quot;&lt;&lt;root&lt;&lt;endl;</span><br><span class="line">            for(int i=1;i&lt;=tot;i++)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Node id:&quot;&lt;&lt;i&lt;&lt;&quot; Fa:&quot;&lt;&lt;tr[i].fa&lt;&lt;&quot; CHL:&quot;&lt;&lt;tr[i].ch[0]&lt;&lt;&quot; CHR:&quot;&lt;&lt;tr[i].ch[1]&lt;&lt;&quot; &quot;&lt;&lt;tr[i].cnt&lt;&lt;&quot; &quot;&lt;&lt;tr[i].val&lt;&lt;&quot; sz:&quot;&lt;&lt;tr[i].size&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int n;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    T.root=0;T.tot=0;</span><br><span class="line">    T.insert(-2147483647);</span><br><span class="line">    T.insert(2147483647);</span><br><span class="line">    n=I.read();</span><br><span class="line">    for(int op,x,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        op=I.read();x=I.read();</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            T.insert(x);</span><br><span class="line">        &#125;else if(op==2)&#123;</span><br><span class="line">            T.del(x); </span><br><span class="line">        &#125;else if(op==3)&#123;</span><br><span class="line">            I.write(T.Rank(x));putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;else if(op==4)&#123;</span><br><span class="line">            I.write(T.rank(x+1));putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;else if(op==5)&#123;</span><br><span class="line">            I.write(T.tr[T.pre(x)].val);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;else if(op==6)&#123;</span><br><span class="line">            I.write(T.tr[T.nxt(x)].val);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">//      cout&lt;&lt;&quot;Round &quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span><br><span class="line">//      T.PrintSplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2503 [HAOI2006]均分数据 题解</title>
      <link href="/2019/12/27/luogu-p2503-haoi2006%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/12/27/luogu-p2503-haoi2006%E5%9D%87%E5%88%86%E6%95%B0%E6%8D%AE-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://www.luogu.com.cn/problem/P2503">题目传送门</a></p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>有$n$个数字$a_1,a_2,a_3\dots a_n$把他们分成$m$组，使得均方差最小。均方差公式如下： $\sigma &#x3D; \sqrt{\frac 1n \sum\limits_{i&#x3D;1}^n(\overline x – x_i)^2},\overline x &#x3D; \frac 1n \sum\limits_{i&#x3D;1}^n x_i$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然如果告诉你这$n$个数字固定的排列顺序就一定可以贪心求出最小值：将当前的数加入到最小的组中。 所以只需要$random\text{_} shuffle$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define LD double</span><br><span class="line">#define Temperature 500000</span><br><span class="line">//#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int n,m,a[25],b[25];</span><br><span class="line">LD sum,ans=20000000.0,s;</span><br><span class="line">class Solve&#123;</span><br><span class="line">    public:</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            memset(b,0,sizeof(b));</span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                re int j=1;</span><br><span class="line">                for(int k=1;k&lt;=m;k++)&#123;</span><br><span class="line">                    if(b[k]&lt;b[j]) j=k;</span><br><span class="line">                &#125;</span><br><span class="line">                b[j]+=a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            s=0.0;</span><br><span class="line">            for(int i=1;i&lt;=m;i++) s+=((LD)b[i]-sum)*(((LD)b[i]-sum));</span><br><span class="line">            s/=(LD)m;</span><br><span class="line">            ans=min(ans,s);</span><br><span class="line">        &#125;</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            n=I.read();m=I.read();</span><br><span class="line">            for(int i=1;i&lt;=n;i++) a[i]=I.read(),sum+=(LD)a[i];</span><br><span class="line">            sum/=(LD)m;</span><br><span class="line">            for(int i=1;i&lt;=Temperature;i++)&#123;</span><br><span class="line">                random_shuffle(a+1,a+n+1);</span><br><span class="line">                solve();</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%.2lf\n&quot;,sqrt(ans));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  File</span><br><span class="line">    S.init();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">6 3</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟退火 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 4399: 魔法少女LJJ 题解</title>
      <link href="/2019/12/09/bzoj-4399-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3ljj/"/>
      <url>/2019/12/09/bzoj-4399-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3ljj/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4399">BZOJ4399</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在森林中见过会动的树，在沙漠中见过会动的仙人掌过后，魔法少女LJJ已经觉得自己见过世界上的所有稀奇古怪的事情了 LJJ感叹道“这里真是个迷人的绿色世界,空气清新、淡雅,到处散发着醉人的奶浆味；小猴在枝头悠来荡去,好不自在；各式各样的鲜花争相开放,各种树枝的枝头挂满沉甸甸的野果；鸟儿的歌声婉转动听,小河里飘着落下的花瓣真是人间仙境” SHY觉得LJJ还是太naive，一天，SHY带着自己心爱的图找到LJJ，对LJJ说：“既然你已经见识过动态树，动态仙人掌了，那么今天就来见识一下动态图吧” LJJ：“要支持什么操作？” SHY：“ 1.新建一个节点，权值为x。 2.连接两个节点。 3.将一个节点a所属于的联通快内权值小于x的所有节点权值变成x。 4.将一个节点a所属于的联通快内权值大于x的所有节点权值变成x。 5.询问一个节点a所属于的联通块内的第k小的权值是多少。 6.询问一个节点a所属联通快内所有节点权值之积与另一个节点b所属联通快内所有节点权值之积的大小。 7.询问a所在联通快内节点的数量 8.若两个节点a，b直接相连，将这条边断开。 9.若节点a存在，将这个点删去。” LJJ：“我可以离线吗？” SHY：“可以，每次操作是不加密的，” LJJ：“我可以暴力吗？” SHY：“自重” LJJ很郁闷，你能帮帮他吗</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个正整数m，表示操作个数。 接下来m行，每行先给出1个正整数c。 若c&#x3D;1，之后一个正整数x，表示新建一个权值为x的节点，并且节点编号为n+1（当前有n个节点）。 若c&#x3D;2，之后两个正整数a，b，表示在a，b之间连接一条边。 若c&#x3D;3，之后两个正整数a，x，表示a联通快内原本权值小于x的节点全部变成x。 若c&#x3D;4，之后两个正整数a，x，表示a联通快内原本权值大于x的节点全部变成x。 若c&#x3D;5，之后两个正整数a，k，表示询问a所属于的联通块内的第k小的权值是多少。 若c&#x3D;6，之后两个正整数a，b，表示询问a所属联通快内所有节点权值之积与b所属联通快内所有节点权值之积的大小， 若a所属联通快内所有节点权值之积大于b所属联通快内所有节点权值之积，输出1，否则为0。 若c&#x3D;7，之后一个正整数a，表示询问a所在联通块大小 若c&#x3D;8，之后两个正整数a，b，表示断开a，b所连接的边。 若c&#x3D;9，之后一个正整数a，表示断开a点的所有连边 具体输出格式见样例</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">2 1 2</span><br><span class="line">2 2 3</span><br><span class="line">2 3 4</span><br><span class="line">2 4 5</span><br><span class="line">9 1</span><br><span class="line">3 2 5</span><br><span class="line">5 3 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对100%的数据 0&lt;&#x3D;m&lt;&#x3D;400000,c&lt;&#x3D;7,所有出现的数均&lt;&#x3D;1000000000,所有出现的点保证存在 请认真阅读题面</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一看感觉很不可做啊（事实上的确很不可做 然后$HINT$说要认真阅读题面，然后恍然发现**$c&lt;&#x3D;7$** 对于$c&#x3D;1$，新建一个节点为$n+1$。 对于$c&#x3D;2$，连接两个联通块，用并查集和线段树合并做 对于$c&#x3D;3$，权值线段树基本操作 对于$c&#x3D;4$，权值线段树基本操作 对于$c&#x3D;5$，权值线段树基本操作 对于$c&#x3D;6$，把权值转换成对数，$log_2(x\times y)&#x3D;log_2x+log_2y$ 对于$c&#x3D;7$，询问$a$连通块内根节点的$size$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define LD double</span><br><span class="line">//#define int long long </span><br><span class="line">#define gc getchar </span><br><span class="line">#define mod 100000007</span><br><span class="line">#define MAXN 400010*18 </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">//      #undef gc</span><br><span class="line">//      #define gc tc</span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">//      #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;4399.in&quot;,&quot;r&quot;,stdin);freopen(&quot;4399.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">struct Question&#123;int id,x,y;&#125;q[MAXN];</span><br><span class="line">int m,cnt;</span><br><span class="line"></span><br><span class="line">class Discretization&#123;</span><br><span class="line">    public:</span><br><span class="line">        int lsh[MAXN],n;</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                if(q[i].id==3q[i].id==4) lsh[++n]=q[i].y;</span><br><span class="line">                if(q[i].id==1) lsh[++n]=q[i].x;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(lsh+1,lsh+n+1);</span><br><span class="line">            n=unique(lsh+1,lsh+n+1)-(lsh+1);</span><br><span class="line">        &#125;</span><br><span class="line">        inline int getlsh(int x)&#123;</span><br><span class="line">            return lower_bound(lsh+1,lsh+n+1,x)-lsh;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;L;</span><br><span class="line"></span><br><span class="line">class Segment_tree&#123;</span><br><span class="line">    public:</span><br><span class="line">        int rt[MAXN],sz[MAXN],son[MAXN][2],tag[MAXN],tot;</span><br><span class="line">        LD sum[MAXN];</span><br><span class="line">        inline void Upd(int x)&#123;</span><br><span class="line">            sz[x]=sz[son[x][0]]+sz[son[x][1]];</span><br><span class="line">            sum[x]=sum[son[x][0]]+sum[son[x][1]];</span><br><span class="line">        &#125;</span><br><span class="line">        inline void Psd(int x)&#123;</span><br><span class="line">            if(tag[x]==0) return ;</span><br><span class="line">            tag[son[x][0]]=1;sz[son[x][0]]=sum[son[x][0]]=0;</span><br><span class="line">            tag[son[x][1]]=1;sz[son[x][1]]=sum[son[x][1]]=0;</span><br><span class="line">            tag[x]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void insert(int x,int l,int r,int now,int sm,LD logsum)&#123;</span><br><span class="line">            re int mid=l+r&gt;&gt;1;</span><br><span class="line">            Psd(x);</span><br><span class="line">            if(l==r)&#123;</span><br><span class="line">                sz[x]=sm;</span><br><span class="line">                sum[x]=logsum;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(now&lt;=mid) insert(son[x][0]==0?son[x][0]=++tot:son[x][0],l,mid,now,sm,logsum);</span><br><span class="line">            else insert(son[x][1]==0?son[x][1]=++tot:son[x][1],mid+1,r,now,sm,logsum);</span><br><span class="line">            Upd(x);</span><br><span class="line">        &#125;</span><br><span class="line">        inline int merge(int x,int y,int l,int r)&#123;</span><br><span class="line">            if(x==0y==0) return x+y;</span><br><span class="line">            sum[x]+=sum[y];</span><br><span class="line">            sz[x]+=sz[y];</span><br><span class="line">            re int mid=l+r&gt;&gt;1;</span><br><span class="line">            if(l==r) return x;</span><br><span class="line">            Psd(x);Psd(y);</span><br><span class="line">            son[x][0]=merge(son[x][0],son[y][0],l,mid);</span><br><span class="line">            son[x][1]=merge(son[x][1],son[y][1],mid+1,r);</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        inline int query(int x,int l,int r,int L,int R)&#123;</span><br><span class="line">            if(x==0) return 0;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R) return sz[x];</span><br><span class="line">            re int mid=l+r&gt;&gt;1;</span><br><span class="line">            Psd(x);</span><br><span class="line">            re int s=0;</span><br><span class="line">            if(L&lt;=mid) s+=query(son[x][0],l,mid,L,R);</span><br><span class="line">            if(R&gt;mid) s+=query(son[x][1],mid+1,r,L,R);</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void add(int x,int l,int r,int L,int R)&#123;</span><br><span class="line">            if(x==0) return ;</span><br><span class="line">            if(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">                sum[x]=sz[x]=0;</span><br><span class="line">                tag[x]=1;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            re int mid=l+r&gt;&gt;1;</span><br><span class="line">            Psd(x);</span><br><span class="line">            if(L&lt;=mid) add(son[x][0],l,mid,L,R);</span><br><span class="line">            if(R&gt;mid) add(son[x][1],mid+1,r,L,R);</span><br><span class="line">            Upd(x);</span><br><span class="line">        &#125;</span><br><span class="line">        inline int getsz(int now,int l,int r,int x)&#123;</span><br><span class="line">            if(l==r) return L.lsh[l];</span><br><span class="line">            re int mid=l+r&gt;&gt;1;</span><br><span class="line">            Psd(now);</span><br><span class="line">            if(sz[son[now][0]]&gt;=x) return getsz(son[now][0],l,mid,x);</span><br><span class="line">            else return getsz(son[now][1],mid+1,r,x-sz[son[now][0]]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line">class Union_Checking_Set&#123;</span><br><span class="line">    public:</span><br><span class="line">        int fa[MAXN];</span><br><span class="line">        inline int getfa(int x)&#123;</span><br><span class="line">            return x==fa[x]?x:fa[x]=getfa(fa[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        inline void merge(int x,int y)&#123;</span><br><span class="line">            x=getfa(x);y=getfa(y);</span><br><span class="line">            if(x==y) return ;</span><br><span class="line">            fa[y]=x;T.rt[x]=T.merge(T.rt[x],T.rt[y],1,L.n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;U;</span><br><span class="line"></span><br><span class="line">class Solve&#123;</span><br><span class="line">    public:</span><br><span class="line">        inline void init()&#123;</span><br><span class="line">            m=I.read();</span><br><span class="line">            for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                q[i].id=I.read();</span><br><span class="line">                if(q[i].id==1q[i].id==7) q[i].x=I.read();</span><br><span class="line">                else q[i].x=I.read(),q[i].y=I.read();</span><br><span class="line">            &#125;</span><br><span class="line">            L.init();</span><br><span class="line">        &#125;</span><br><span class="line">        inline void solve()&#123;</span><br><span class="line">            for(int x,y,s,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                switch(q[i].id)&#123;</span><br><span class="line">                    case 1:++cnt,T.insert(T.rt[cnt]==0?T.rt[cnt]=++T.tot:T.rt[cnt],1,L.n,L.getlsh(q[i].x),1,log2(q[i].x)),U.fa[cnt]=cnt;break;</span><br><span class="line">                    case 2:U.merge(q[i].x,q[i].y);break;</span><br><span class="line">                    case 3:x=U.getfa(q[i].x),y=L.getlsh(q[i].y),s=T.query(T.rt[x],1,L.n,1,y),T.add(T.rt[x],1,L.n,1,y),T.insert(T.rt[x]==0?T.rt[x]=++T.tot:T.rt[x],1,L.n,y,s,s*log2(q[i].y));break;</span><br><span class="line">                    case 4:x=U.getfa(q[i].x),y=L.getlsh(q[i].y),s=T.query(T.rt[x],1,L.n,y,L.n),T.add(T.rt[x],1,L.n,y,L.n),T.insert(T.rt[x]==0?T.rt[x]=++T.tot:T.rt[x],1,L.n,y,s,s*log2(q[i].y));break;</span><br><span class="line">                    case 5:I.write(T.getsz(T.rt[U.getfa(q[i].x)],1,L.n,q[i].y)),putchar(&#x27;\n&#x27;);break;</span><br><span class="line">                    case 6:I.write(T.sum[T.rt[U.getfa(q[i].x)]]&gt;T.sum[T.rt[U.getfa(q[i].y)]]?1:0),putchar(&#x27;\n&#x27;);break;</span><br><span class="line">                    default:I.write(T.sz[T.rt[U.getfa(q[i].x)]]),putchar(&#x27;\n&#x27;);break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    File  </span><br><span class="line">    S.init();</span><br><span class="line">    S.solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">11</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">2 1 2</span><br><span class="line">2 2 3</span><br><span class="line">2 3 4</span><br><span class="line">2 4 5</span><br><span class="line">3 2 5</span><br><span class="line">5 3 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bzoj 1052: [HAOI2007]覆盖问题 &amp; Luogu P2218 [HAOI2007]覆盖问题 题解</title>
      <link href="/2019/12/08/bzoj-1052-haoi2007%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-luogu-p2218-haoi2007%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/12/08/bzoj-1052-haoi2007%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-luogu-p2218-haoi2007%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在平面直角坐标系中有$n$个点，现在给你$3$个$L\times L$的正方形，问要用这$3$个正方形盖住所有点的最小的$L$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>终于开始刷$bzoj$了$QwQ$… 非常明显，这道题肯定要二分，那么怎么写$check$呢？ 可以考虑如果用一个非常大的正方形盖住了所有点，那么必定会有点在这个正方形的四条边上。所以有正方形必须在边上。但是只有$3$个小正方形，而大正方形有$4$条边，所以肯定有一个小正方形的两条边分别在大正方形的两条边上，换句话说就一定有一个小正方形在大正方形的一个角上。 <img src="https://s2.ax1x.com/2019/12/08/QamcBq.png" alt="大正方形围住所有点"> <strong>大正方形围住所有点↑</strong> <img src="https://s2.ax1x.com/2019/12/08/QanBa6.png" alt="3个小正方形"> <strong>3个小正方形↑</strong> 那么$check$只需要枚举一下这个小正方形是在大正方形的哪一个角上即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define It std::set&lt;int&gt;::iterator</span><br><span class="line">//#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">    //  #define gc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">    //  #undef gc()</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line"></span><br><span class="line">int n,vis[20010];</span><br><span class="line">struct node&#123;int x,y;&#125;a[20010];</span><br><span class="line">inline bool cmp(node qx,node qy)&#123;return qx.x&lt;qy.x(qx.x==qy.x&amp;&amp;qx.y&lt;qy.y);&#125;</span><br><span class="line">inline bool dfs(int x,int L)&#123;</span><br><span class="line">    re int Minx=2e9,Maxx=-2e9,Miny=2e9,Maxy=-2e9;//求出大正方形的四个点的坐标</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i]==0)&#123;</span><br><span class="line">            Maxx=max(Maxx,a[i].x);</span><br><span class="line">            Minx=min(Minx,a[i].x);</span><br><span class="line">            Maxy=max(Maxy,a[i].y);</span><br><span class="line">            Miny=min(Miny,a[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    re int lenx=Maxx-Minx,leny=Maxy-Miny;//如果大正方形的边长&lt;=L那么肯定可以</span><br><span class="line">    if(max(lenx,leny)&lt;=L) return 1;</span><br><span class="line">    if(x==3) return 0;//如果已经放了3个正方形却不行，那么就肯定不行</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==0&amp;&amp;Minx&lt;=a[i].x&amp;&amp;a[i].x&lt;=Minx+L&amp;&amp;Miny&lt;=a[i].y&amp;&amp;a[i].y&lt;=Miny+L) vis[i]=x;&#125;//4个角的情况，分别dfs</span><br><span class="line">    if(dfs(x+1,L)) return 1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==x) vis[i]=0;&#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==0&amp;&amp;Maxx-L&lt;=a[i].x&amp;&amp;a[i].x&lt;=Maxx&amp;&amp;Miny&lt;=a[i].y&amp;&amp;a[i].y&lt;=Miny+L) vis[i]=x;&#125;</span><br><span class="line">    if(dfs(x+1,L)) return 1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==x) vis[i]=0;&#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==0&amp;&amp;Minx&lt;=a[i].x&amp;&amp;a[i].x&lt;=Minx+L&amp;&amp;Maxy-L&lt;=a[i].y&amp;&amp;a[i].y&lt;=Maxy) vis[i]=x;&#125;</span><br><span class="line">    if(dfs(x+1,L)) return 1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==x) vis[i]=0;&#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==0&amp;&amp;Maxx-L&lt;=a[i].x&amp;&amp;a[i].x&lt;=Maxx&amp;&amp;Maxy-L&lt;=a[i].y&amp;&amp;a[i].y&lt;=Maxy) vis[i]=x;&#125;</span><br><span class="line">    if(dfs(x+1,L)) return 1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;if(vis[i]==x) vis[i]=0;&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">inline bool check(int x)&#123;memset(vis,0,sizeof(vis));return dfs(1,x);&#125;//每次check前清空</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=I.read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i].x=I.read(),a[i].y=I.read();</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    int l=0,r=2e9,ans=2e9;//二分</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        re int mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid)) ans=mid,r=mid-1;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块 学习笔记</title>
      <link href="/2019/11/03/%E5%88%86%E5%9D%97-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/03/%E5%88%86%E5%9D%97-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>忽然发现分块大法很好用，然而本蒟蒻不会…所以心血来潮学习了分块</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a><a href="https://www.luogu.org/problem/P3372">Link</a></h3><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define It std::set&lt;int&gt;::iterator</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">struct FastIO&#123;</span><br><span class="line">    static const int S=1048576;</span><br><span class="line">    char buf[S],*L,*R;int stk[20],Top;</span><br><span class="line">    ~FastIO()&#123;clear();&#125;</span><br><span class="line">    inline char nc()&#123;return L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;&#125;</span><br><span class="line">    inline void clear()&#123;fwrite(buf,1,Top,stdout);Top=0;&#125;</span><br><span class="line">    inline void pc(char ch)&#123;Top==S&amp;&amp;(clear(),0);buf[Top++]=ch;&#125;</span><br><span class="line">    inline void endl()&#123;pc(&#x27;\n&#x27;);&#125;</span><br><span class="line">    FastIO&amp; operator &gt;&gt; (int&amp; ret)&#123;</span><br><span class="line">        ret=0;int f=1;char ch=nc();</span><br><span class="line">        while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-f;ch=nc();&#125;</span><br><span class="line">        while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;ret=ret*10+ch-&#x27;0&#x27;;ch=nc();&#125;</span><br><span class="line">        ret*=f;return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO&amp; operator &gt;&gt; (char* s)&#123;</span><br><span class="line">        re int Len=0;re char ch=nc();</span><br><span class="line">        while(ch!=&#x27;\n&#x27;)&#123;</span><br><span class="line">            *(s+Len)=ch;</span><br><span class="line">            Len++;</span><br><span class="line">            ch=nc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO&amp; operator &lt;&lt; (int x)&#123;</span><br><span class="line">        if(x&lt;0)&#123;pc(&#x27;-&#x27;);x=-x;&#125;</span><br><span class="line">        do&#123;stk[++stk[0]]=x%10;x/=10;&#125;while(x);</span><br><span class="line">        while(stk[0]) pc(&#x27;0&#x27;+stk[stk[0]--]);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO&amp; operator &lt;&lt; (char ch)&#123;pc(ch);return *this;&#125;</span><br><span class="line">    FastIO&amp; operator &lt;&lt; (string str)&#123;</span><br><span class="line">        re int Len=str.size()-1;for(stk[0]=0;Len&gt;=0;Len--) stk[++stk[0]]=str[Len];</span><br><span class="line">        while(stk[0]) pc(stk[stk[0]--]);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;fin,fout;</span><br><span class="line">int n,m,ans,a[100010],lef[100010],rig[100010],id[100010],sum[100010],add[100010],tot,sz;</span><br><span class="line">#define File freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">inline void Print()&#123;</span><br><span class="line">    for(int i=1;i&lt;=tot;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;lef[i]&lt;&lt;&quot; &quot;&lt;&lt;rig[i]&lt;&lt;&quot; &quot;&lt;&lt;add[i]&lt;&lt;&quot; &quot;&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fin&gt;&gt;a[i];</span><br><span class="line">    sz=sqrt(n);tot=sz;//每个块大小为sqrt(n)</span><br><span class="line">    if(sz*sz&lt;=n) ++tot;//还有多余</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        id[i]=(i/sz)+(i%sz==0?0:1);//每个数所属的块的编号</span><br><span class="line">        sum[id[i]]+=a[i];//每个块内的和</span><br><span class="line">        if(id[i]==tot) lef[i]=sz*sz,rig[i]=n;//确定最后一个块的左右端点</span><br><span class="line">        lef[id[i]]=id[i]*sz-sz+1;rig[id[i]]=id[i]*sz;//确定这个块的左右端点</span><br><span class="line">    &#125;</span><br><span class="line">    for(int op,l,r,v,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        fin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            fin&gt;&gt;v;</span><br><span class="line">            for(int i=l;i&lt;=min(r,rig[id[l]]);i++) a[i]+=v,sum[id[i]]+=v;//把左边的暴力加入</span><br><span class="line">            for(int i=max(l,lef[id[r]]);i&lt;=r;i++) a[i]+=v,sum[id[i]]+=v;//把右边的暴力加入</span><br><span class="line">            for(int i=id[l]+1;i&lt;=id[r]-1;i++) add[i]+=v;//把中间的加入</span><br><span class="line">            if(id[l]==id[r]) for(int i=l;i&lt;=r;i++) a[i]-=v;//注意当l,r在同一个块内情况</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans=0;</span><br><span class="line">            for(int i=l;i&lt;=min(r,rig[id[l]]);i++) ans+=a[i]+add[id[i]];//同上</span><br><span class="line">            for(int i=max(l,lef[id[r]]);i&lt;=r;i++) ans+=a[i]+add[id[i]];//同上</span><br><span class="line">            for(int i=id[l]+1;i&lt;=id[r]-1;i++) ans+=sum[i]+add[i]*(rig[i]-lef[i]+1);//同上</span><br><span class="line">            if(id[l]==id[r]) ans-=a[l]+a[r]+add[id[l]]+add[id[r]];//注意当l,r在同一个块内情况</span><br><span class="line">            fout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3535 [POI2012]TOU-Tour de Byteotia 题解</title>
      <link href="/2019/10/21/luogu-p3535-poi2012tou-tour-de-byteotia-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/10/21/luogu-p3535-poi2012tou-tour-de-byteotia-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a><a href="https://www.luogu.org/problem/P3535">Link</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个$n$个点$m$条边的无向图，问最少删掉多少条边能使得编号小于等于$k$的点都不在环上。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要想让编号<strong>小于等于</strong>$k$的点都<strong>不</strong>在环上，那么就最好让所有编号大于$k$的边都在环上。 那么可以用并查集把所有编号大于$k$的边连起来，再判断编号小于等于$k$的边是否在环上即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();return res*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,k,fa[1000010],ans,x[1000010],y[1000010];</span><br><span class="line">inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;</span><br><span class="line">inline void merge(int x,int y)&#123;</span><br><span class="line">    x=getfa(x);</span><br><span class="line">    y=getfa(y);</span><br><span class="line">    if(x==y) ;</span><br><span class="line">    else fa[y]=x;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();k=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        x[i]=read();y[i]=read();</span><br><span class="line">        if(x[i]&gt;k&amp;&amp;y[i]&gt;k) merge(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        if(x[i]&gt;k&amp;&amp;y[i]&gt;k) continue ;</span><br><span class="line">        x[i]=getfa(x[i]);y[i]=getfa(y[i]);</span><br><span class="line">        if(x[i]==y[i]) ans++;</span><br><span class="line">        else merge(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隔板法 学习笔记</title>
      <link href="/2019/10/07/%E9%9A%94%E6%9D%BF%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/07/%E9%9A%94%E6%9D%BF%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>$2019.10.19$就$CSP$第一轮了<img src="https://s2.ax1x.com/2019/10/06/uceGB8.png">（好慌</p><h2 id="隔板法定义"><a href="#隔板法定义" class="headerlink" title="隔板法定义"></a>隔板法定义</h2><p>在组合数学中，隔板法（又叫插板法）是排列组合的推广，主要用于解决不相邻组合与追加排列的问题。 隔板法就是在$n$个元素间插入$(b-1)$个板，即把$n$个元素分成$b$组的方法。——百度百科</p><h2 id="普通隔板法"><a href="#普通隔板法" class="headerlink" title="普通隔板法"></a>普通隔板法</h2><h3 id="经典问题：求-x-y-z-x3D-10-的正整数解的个数。"><a href="#经典问题：求-x-y-z-x3D-10-的正整数解的个数。" class="headerlink" title="经典问题：求$x+y+z&#x3D;10$的正整数解的个数。"></a>经典问题：求$x+y+z&#x3D;10$的正整数解的个数。</h3><p>这个问题与此问题相同：如图，有$10$个小球，现要插入$2$块板，问总共有多少种方法？ <img src="https://s2.ax1x.com/2019/10/09/uInhz6.png"> 就比如这种情况：当$x&#x3D;2,y&#x3D;5,z&#x3D;3$时，等式成立，同时转换成的隔板问题的情况是这样的： <img src="https://s2.ax1x.com/2019/10/09/uIuVS0.png"> 很显然，$10$个小球之间有$10-1&#x3D;9$个空隙，插$2$块板，不难得出答案就是$C_{2}^{9}&#x3D;36$种方法。 （不会组合数？那就戳<a href="https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%95%B0/2153250?fr=aladdin">这里</a>）</p><h2 id="添元素隔板法"><a href="#添元素隔板法" class="headerlink" title="添元素隔板法"></a>添元素隔板法</h2><h3 id="例-1-：求-x-y-z-x3D-10-的非负整数解的个数。"><a href="#例-1-：求-x-y-z-x3D-10-的非负整数解的个数。" class="headerlink" title="例$1$：求$x+y+z&#x3D;10$的非负整数解的个数。"></a>例$1$：求$x+y+z&#x3D;10$的非负整数解的个数。</h3><p>我：这题和上题不是一模一样吗（小声bb 大佬：对对对，这题和上题一样水 （言归正传 本题注意是<strong>非负整数解</strong>，所以$x,y,z$可以有$0$（废话） 所以我们可以在等式两边同时加上$3$ 然后等式就变成了$x+y+z+3&#x3D;10+3$ 整理一下：$(x+1)+(y+1)+(z+1)&#x3D;13$ 然后设$A&#x3D;x+1,B&#x3D;y+1,C&#x3D;z+1$，代回原式：$A+B+C&#x3D;13$ 这格式好像和上题一模一样…<img src="https://s2.ax1x.com/2019/10/09/uIQAfA.png"> 因为$x,y,z$为<strong>非负整数</strong>，那么显而易见$A,B,C$均为正整数，所以$A,B,C$的方案数可以通过上一题的方法快速地求出，即：$C_{2}^{12}&#x3D;66$。 <img src="https://s2.ax1x.com/2019/10/09/uIlp3n.png"> <img src="https://s2.ax1x.com/2019/10/09/uIlJ4H.png"> 因为每一组得出的$A,B,C$对应着唯一一组$x,y,z$，所以$x,y,z$的方案数也是$66$。</p><h3 id="例-2-：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。"><a href="#例-2-：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。" class="headerlink" title="例$2$：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。"></a>例$2$：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。</h3><p>首先，我们假设这类自然数的前两位数为$a,b$，显然，确定了前两位数，这个数字就确定了（因为每个数都要到不能写为止）。 根据题意，这个数必须有第三位，所以$a+b\leq 9$，并且$a$是最高位$a\not&#x3D;0$。 我：那我还是照着之前的思路，放$9$个球，插$1$个板，如下图，答案就是$C_{1}^{8}&#x3D;8$。 <img src="https://s2.ax1x.com/2019/10/09/uI1rsx.png"> 大佬：不对啊，$a\not&#x3D;0$，但是$b$可以为$0$啊，所以等式两边同时$+1$，所以$a+(b+1)\leq 10$，所以放$10$个球，插$1$个板，如下图，答案就是$C_{1}^{9}&#x3D;9$。 <img src="https://s2.ax1x.com/2019/10/09/uI3AfJ.png"> 我：原来是这样啊。 （这时，奆佬走了过来把纸撕了） 奆佬：不不不，你们都错了。 <img src="https://s2.ax1x.com/2019/10/09/uI3o9J.png"> 奆佬：$a+b$不一定等于$9$，所以我们应该再设一个变量$c$，使得$a+b+c&#x3D;9(c\ge 0)$，然后等式两边同时加$2$，所以$a+(b+1)+(c+1)&#x3D;11$，所以放$11$个球，插$2$个板，如下图，答案就是$C_{2}^{10}&#x3D;45$。 <img src="https://s2.ax1x.com/2019/10/09/uIJe6s.png"></p><h2 id="添板插板法"><a href="#添板插板法" class="headerlink" title="添板插板法"></a>添板插板法</h2><h3 id="例题：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。（同上题）"><a href="#例题：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。（同上题）" class="headerlink" title="例题：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。（同上题）"></a>例题：有一类自然数，从第三位开始每一位上的数字都是前两位数字之和，直至不能写为止，问这类自然数有多少个。（同上题）</h3><p>奆佬：上题还可以用添板插板法做 我：（大吃一惊） 我们还是设前两位为$a,b$，那么$a+b\leq 9,a\not&#x3D;0$。 <img src="https://s2.ax1x.com/2019/10/09/uIYQKA.png"> 我们可以在前$9$个空位中插$2$个隔板，分成$3$组，当$b&#x3D;0$时，则在第$10$个空位上插隔板。 那么答案就是总共在$10$个空位插$2$个隔板，$C_{2}^{10}&#x3D;45$。</p><h2 id="选板法"><a href="#选板法" class="headerlink" title="选板法"></a>选板法</h2><h3 id="例题：有-10-颗糖，每天至少吃一颗，吃完为止，问有多少种吃法。"><a href="#例题：有-10-颗糖，每天至少吃一颗，吃完为止，问有多少种吃法。" class="headerlink" title="例题：有$10$颗糖，每天至少吃一颗，吃完为止，问有多少种吃法。"></a>例题：有$10$颗糖，每天至少吃一颗，吃完为止，问有多少种吃法。</h3><p>(我吃糖你还管我<img src="https://s2.ax1x.com/2019/10/09/uIYIVx.png"> <img src="https://s2.ax1x.com/2019/10/09/uIYvqI.png"> 如上图，有$9$个空位，可以插入$9$个板，每个板可以放或不放，所以总共有$2^9&#x3D;512$种吃法。 我：哇，有这么多种吃法，我每$10$天试一种，那我要吃多少天呢…</p><h2 id="分类插板"><a href="#分类插板" class="headerlink" title="分类插板"></a>分类插板</h2><h3 id="例题：有-15-颗糖，每天至少吃三颗，吃完为止，问有多少种吃法。"><a href="#例题：有-15-颗糖，每天至少吃三颗，吃完为止，问有多少种吃法。" class="headerlink" title="例题：有$15$颗糖，每天至少吃三颗，吃完为止，问有多少种吃法。"></a>例题：有$15$颗糖，每天至少吃三颗，吃完为止，问有多少种吃法。</h3><p>(这题好像和上一题又是一模一样 因为题目中并没有规定要吃几天，也没有规定每天一定要吃几颗，所以需要分类讨论。 当吃$1$天时，答案就是$1$种（一天吃$15$颗糖） 当吃$2$天时，每天先吃$2$块，即有$11$颗糖，每天至少吃$1$颗，吃$2$天，有$C_{1}^{10}&#x3D;10$种情况。 当吃$3$天时，每天先吃$2$块，即有$9$颗糖，每天至少吃$1$颗，吃$3$天，有$C_{2}^{8}&#x3D;28$种情况。 当吃$4$天时，每天先吃$2$块，即有$7$颗糖，每天至少吃$1$颗，吃$4$天，有$C_{3}^{6}&#x3D;20$种情况。 当吃$5$天时，答案就是$1$种（每天吃$3$颗糖） 所以最终的答案就是$1+10+28+20+1&#x3D;60$种吃法。</p><h2 id="逐步插板"><a href="#逐步插板" class="headerlink" title="逐步插板"></a>逐步插板</h2><h3 id="例题：在一张节目单中原有-6-个节目，若保持这些节目相对次序不变，再添加-3-个节目，共有几种情况？"><a href="#例题：在一张节目单中原有-6-个节目，若保持这些节目相对次序不变，再添加-3-个节目，共有几种情况？" class="headerlink" title="例题：在一张节目单中原有$6$个节目，若保持这些节目相对次序不变，再添加$3$个节目，共有几种情况？"></a>例题：在一张节目单中原有$6$个节目，若保持这些节目相对次序不变，再添加$3$个节目，共有几种情况？</h3><p><img src="https://s2.ax1x.com/2019/10/09/uIabTI.png"> 可以用一个节目去插$7$个空位，再用第二个节目去插$8$个空位，用最后个节目去插$9$个空位。 所以一共是$C_{1}^{7}\times C_{1}^{8}\times C_{1}^{9}&#x3D;504$种。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="隔板法应用的条件"><a href="#隔板法应用的条件" class="headerlink" title="隔板法应用的条件"></a>隔板法应用的条件</h3><h4 id="分成的组别要不同"><a href="#分成的组别要不同" class="headerlink" title="分成的组别要不同"></a>分成的组别要不同</h4><h4 id="分的每组至少有-1-个元素"><a href="#分的每组至少有-1-个元素" class="headerlink" title="分的每组至少有$1$个元素"></a>分的每组至少有$1$个元素</h4><h4 id="n-个元素不同"><a href="#n-个元素不同" class="headerlink" title="$n$个元素不同"></a>$n$个元素不同</h4><h3 id="隔板法就是在-n-个元素间-n-1-个空中插入-k-个板，可以把-n-个元素分成-k-1-组的方法"><a href="#隔板法就是在-n-个元素间-n-1-个空中插入-k-个板，可以把-n-个元素分成-k-1-组的方法" class="headerlink" title="隔板法就是在$n$个元素间$(n-1)$个空中插入$k$个板，可以把$n$个元素分成$k+1$组的方法"></a>隔板法就是在$n$个元素间$(n-1)$个空中插入$k$个板，可以把$n$个元素分成$k+1$组的方法</h3><p>完结撒花❀O(∩_∩)O❀</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初赛 </tag>
            
            <tag> 隔板法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exgcd学习笔记</title>
      <link href="/2019/10/07/exgcd%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/07/exgcd%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天膜你赛竟然要套$exgcd$<img src="https://s2.ax1x.com/2019/10/06/uceGB8.png"></p><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline int gcd(int a,int b)&#123;</span><br><span class="line">    return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h2><p>形如$ax+by&#x3D;c$的方程，当$gcd(a,b)c$时，存在整数解$x,y$。 也就是说$exgcd$可以解$ax+by&#x3D;gcd(a,b)$的方程。 令$a&#x3D;b,b&#x3D;a\mod b$，那么$bx+a\mod b\times y&#x3D;gcd(b,a\mod b)$。 因为$gcd(a,b)&#x3D;gcd(b,a\mod b)$。 所以$bx+a\mod b\times y&#x3D;gcd(a,b)$。 又因为$a\mod b&#x3D;a-b\times \lfloor {a&#x2F;b} \rfloor$ 所以$bx+(a-b\times \lfloor {a&#x2F;b} \rfloor)\times y &#x3D;gcd(a,b)$。 整理得：$a\times y+b\times (x-\lfloor {a&#x2F;b} \rfloor)&#x3D;gcd(a,b)$。 所以可以转化为$x_{new}&#x3D;y,y_{new}&#x3D;x-\lfloor {a&#x2F;b} \rfloor$，继续求解即可。 当$b&#x3D;0$时，$y&#x3D;0,x&#x3D;1,gcd&#x3D;a$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline void exgcd(int a,int b,int &amp;x,int &amp;y,int &amp;gcd)&#123;</span><br><span class="line">    if(!b) gcd=a,y=0,x=1;</span><br><span class="line">    else&#123;</span><br><span class="line">        gcd(b,a%b,x,y,gcd);</span><br><span class="line">        int tmp=x;x=y;y=tmp-(a/b)*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exgcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.10.6 CSP-S模拟赛T1</title>
      <link href="/2019/10/06/2019-10-6-csp-s%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
      <url>/2019/10/06/2019-10-6-csp-s%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>考完以后感觉炸了，结果还好（大雾，竟然没有垫底 5+80+20&#x3D;105(21&#x2F;52)</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于任意的$1\leq k \leq N$，求有多少个恰好有$k$个<strong>叶子</strong>节点的二叉树，满足每个节点要么没有<strong>子</strong>节点，要么有两个<strong>子</strong>节点，同时<strong>不</strong>存在一个<strong>叶子</strong>节点，使得根到它的路径上有<strong>不少于</strong>$M$条向<strong>左</strong>的边。 答案对$998244353$取模。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>此题发下来时语意不清，上标黑字体还有错误（大雾 搞了半天还没看懂<img src="https://s2.ax1x.com/2019/10/06/uceGB8.png"> 于是自己瞎推了一下样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:3 5</span><br><span class="line">Output:1 1 2 4 8</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/06/ucmrRA.png"> （似乎发现了什么，忽略$M$的限制，打表竟然打出了像卡特兰数的东西……于是转移到平面直角坐标系，dp 设$f[i][j]$表示$i$个<strong>叶子</strong>节点，往左的边的数量与往右边的数量之差为$j$。 若$j&lt;m-1$，那么$f[i][j+1]+&#x3D;f[i][j]$ 若$j&gt;0$，那么$f[i+1][j-1]+&#x3D;f[i][j]$ 画图大概是这样的： <img src="https://s2.ax1x.com/2019/10/06/uc87Qg.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">    //  #define gc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">    //  #undef gc()</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;pa.in&quot;,&quot;r&quot;,stdin);freopen(&quot;pa.out&quot;,&quot;w&quot;,stdout); </span><br><span class="line"></span><br><span class="line">int m,n,las,f[5010][5010];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    File</span><br><span class="line">    m=I.read();n=I.read();</span><br><span class="line">    f[1][0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++) f[i][j+1]+=f[i][j],f[i][j+1]%=998244353,f[i+1][j-1]+=f[i][j],f[i+1][j-1]%=998244353;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) I.write(f[i][0]),putchar(&#x27;\n&#x27;); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS&amp;exBSGS 学习笔记</title>
      <link href="/2019/09/20/bsgsexbsgs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/20/bsgsexbsgs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在某次集训比赛时遇到了$esBSGS$毒瘤题，被大佬们暴捶，过了一个多月本蒟蒻才开始学习$BSGS\text{&amp;}exBSGS$</p><h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>$BabyStepGiantStep$算法，即大步小步算法，缩写为$BSGS$，而$esBSGS$，顾名思义，就是$BSGS$的拓展。 $BSGS$用来解决如下问题： 给定一个质数$P(2\leq P &lt; 2^{31})$，以及一个整数$Y(2\leq A &lt; P)$，一个整数$Z(2\leq Z &lt;P)$，求最小的$X$，满足$Y^X \equiv Z \mod P$ 例题：<a href="https://www.luogu.org/problem/P3846">Luogu P3846 [TJOI2007]可爱的质数</a> 算法思路如下： 设$m&#x3D;\sqrt{P}$，$X&#x3D;a\times m-b$，$a\in [0,m+1]$，$n \in [0,m)$。 那么$Y^{a \times m-b}\equiv Z \mod P$ $Y^{a\times m}\equiv Z \times Y^{b} \mod P$， 所以只要$O(m)$记录一下右边的值，然后枚举左边，查表即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;%name%.in&quot;,&quot;r&quot;,stdin);freopen(&quot;%name%.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line"></span><br><span class="line">int p,y,z,m,ans;</span><br><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">int fpow(int a,int b)&#123;</span><br><span class="line">    int s=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) s*=a,s%=p;</span><br><span class="line">        a*=a;</span><br><span class="line">        a%=p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">int calc(int x)&#123;</span><br><span class="line">    int s=z;</span><br><span class="line">    s*=fpow(y,x);s%=p;</span><br><span class="line">    return s; </span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  File</span><br><span class="line">    p=I.read();y=I.read();z=I.read();</span><br><span class="line">    if(y==1) return puts(&quot;0&quot;),0;</span><br><span class="line">    m=sqrt(p)+1;</span><br><span class="line">    mp.clear();</span><br><span class="line">    for(int pw=z,i=0;i&lt;m;i++)&#123;</span><br><span class="line">        mp[pw]=i;</span><br><span class="line">        pw*=y;pw%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=-1;</span><br><span class="line">    for(int s=1,pw=fpow(y,m),i=1;i&lt;=m+1;i++)&#123;</span><br><span class="line">        s*=pw;s%=p;</span><br><span class="line">        if(mp.count(s))&#123;</span><br><span class="line">            ans=i*m-mp[s];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans==-1) return puts(&quot;no solution&quot;),0;</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h2><p>$exBSGS$顾名思义（大雾），就是$BSGS$的拓展。适用于解决如下问题： 给定一个<strong>整数</strong>$P(2\leq P &lt; 2^{31})$，以及一个整数$Y(2\leq A &lt; P)$，一个整数$Z(2\leq Z &lt;P)$，求最小的$X$，满足$Y^X \equiv Z \mod P$ 例题：<a href="https://www.luogu.org/problem/P4195">Luogu P4195 【模板】exBSGS&#x2F;Spoj3105 Mod</a> 算法思路如下： 对于$gcd(y, p)\ne1$怎么办？ 我们把它写成$y\times y^{x-1}+k\times p&#x3D;z, k\in Z$的形式 根据$exgcd$的理论 那么如果$gcd(y,p)$不是$z$的约数就不会有解 设$d&#x3D;gcd(y,p)$ 那么$\frac{y}{d}\times y^{x-1}+k\times \frac{p}{d}&#x3D;\frac{z}{d}$ 递归到$d&#x3D;1$ 设之间的所有的$d$乘积为$g$，递归$c$次 令$x’&#x3D;x-c, p’&#x3D;\frac{p}{g},z’&#x3D;\frac{z}{g}$ 那么$y^{x’}\times \frac{y^c}{g}&#x3D;z’(mod \ p’)$ 那么$BSGS$求解就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;%name%.in&quot;,&quot;r&quot;,stdin);freopen(&quot;%name%.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">int p,y,z,m,ans;</span><br><span class="line">std::unordered_map&lt;int,int&gt; Hash;</span><br><span class="line">int fpow(int a,int b)&#123;</span><br><span class="line">    int s=1;a%=p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) s*=a,s%=p;</span><br><span class="line">        a*=a;</span><br><span class="line">        a%=p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int EX_BSGS()&#123;</span><br><span class="line">    y%=p;z%=p;</span><br><span class="line">    if(y==1) return puts(&quot;0&quot;),0;</span><br><span class="line">    Hash.clear(); </span><br><span class="line">    re int cnt=0,t=1; </span><br><span class="line">    for(int d=gcd(y,p);d!=1;d=gcd(y,p))&#123;</span><br><span class="line">        if(z%d) return puts(&quot;No Solution&quot;),0;</span><br><span class="line">        ++cnt,z/=d,p/=d,t=1ll*t*y/d%p;</span><br><span class="line">        if(z==t) return I.write(cnt),putchar(&#x27;\n&#x27;),0;</span><br><span class="line">    &#125;</span><br><span class="line">    m=sqrt(p)+1;</span><br><span class="line">    for(int pw=z,i=0;i&lt;m;i++)&#123;</span><br><span class="line">        Hash[pw]=i;</span><br><span class="line">        pw*=y;pw%=p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=-1;</span><br><span class="line">    for(int s=t,pw=fpow(y,m),i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        s*=pw;s%=p;</span><br><span class="line">        if(Hash.find(s)!=Hash.end())&#123;</span><br><span class="line">            ans=i*m-Hash[s]+cnt;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ans==-1) return puts(&quot;No Solution&quot;),0;</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  File</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        y=I.read();p=I.read();z=I.read();</span><br><span class="line">        if(p==0&amp;&amp;y==0&amp;&amp;z==0) return 0;</span><br><span class="line">        EX_BSGS();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSGS </tag>
            
            <tag> exBSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.9.15 CSP-S模拟赛</title>
      <link href="/2019/09/15/2019-9-15-csp-s%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
      <url>/2019/09/15/2019-9-15-csp-s%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一大波原题来袭!!!（大雾 考得不太好吧0+100+0&#x3D;100（T3数据出锅了</p><h2 id="T1-P5424-USACO19OPEN-Snakes"><a href="#T1-P5424-USACO19OPEN-Snakes" class="headerlink" title="T1-P5424 [USACO19OPEN]Snakes"></a>T1-<a href="https://www.luogu.org/problem/P5424">P5424 [USACO19OPEN]Snakes</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$n$组蛇，每一组蛇有$a_i$条蛇，你有一张网，需要将蛇全部抓住。一次抓一组蛇，因此每次要使网比当前组的蛇的数量大。你可以改变$k$次网的大小，问抓住所有蛇的总浪费空间的最小值？ 对于$100 \% $的数据$1\leq n \leq 400,0\leq a_i \leq 10^6$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑$DP$，设$f[i][j]$表示前$i$组蛇，改变了$j$次网的大小的最小浪费空间值。 那么$f[i][j]&#x3D;min(f[i][j],f[k][j-1]+(i-k)*Max[k+1][i]-(sum[i]-sum[k]))$ 其中$sum$表示前缀和，$Max$表示区间最大值。 所以只要先维护前缀和与区间最大值即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">//#define int int </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;pa.in&quot;,&quot;r&quot;,stdin);freopen(&quot;pa.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">int n,K,a[410],f[410][410],sum[410],Max[410][410],ans=2e9;</span><br><span class="line">int main()&#123;</span><br><span class="line">    File</span><br><span class="line">    n=I.read();K=I.read();K++;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=I.read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        for(int j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            if(i==j) Max[i][j]=a[i];</span><br><span class="line">            else Max[i][j]=max(Max[i][j-1],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    memset(f,63,sizeof(f));f[0][0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=K;j++)&#123;</span><br><span class="line">            for(int k=0;k&lt;i;k++)&#123;</span><br><span class="line">                f[i][j]=min(f[i][j],f[k][j-1]+(i-k)*Max[k+1][i]-(sum[i]-sum[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=K;i++) ans=min(ans,f[n][i]);</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2-P5425-USACO19OPEN-I-Would-Walk-500-Miles"><a href="#T2-P5425-USACO19OPEN-I-Would-Walk-500-Miles" class="headerlink" title="T2-P5425 [USACO19OPEN]I Would Walk 500 Miles"></a>T2-<a href="https://www.luogu.org/problem/P5425">P5425 [USACO19OPEN]I Would Walk 500 Miles</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>（你自己点链接看，(╯▔皿▔)╯</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>乱搞贪心，比赛时候竟然过了？(￣▽￣)” 贪心将其分组成一下形式：$(1),(2),(3),(4),…,(P),(P+1,P+2,P+3,…,N-1,N)$ 然后跑一遍求值。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define re register</span><br><span class="line">#define int long long </span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    private:</span><br><span class="line">        static const int S=1&lt;&lt;21;</span><br><span class="line">        #define tc() (A==B&amp;&amp;(B=(A=Rd)+fread(Rd,1,S,stdin),A==B)?EOF:*A++)</span><br><span class="line">        char Rd[S],*A,*B;</span><br><span class="line">        #define pc putchar</span><br><span class="line">    public:</span><br><span class="line">        #undef gc</span><br><span class="line">        #define gc getchar </span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line">#define File freopen(&quot;pb.in&quot;,&quot;r&quot;,stdin);freopen(&quot;pb.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">int n,k,ans=2e18;</span><br><span class="line">inline int dis(int x,int y)&#123;</span><br><span class="line">    return (2019201913*x%2019201997+2019201949*y%2019201997)%2019201997;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    File</span><br><span class="line">    n=I.read();k=I.read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(i&gt;=k&amp;&amp;j&gt;=k) ;</span><br><span class="line">            else ans=min(ans,dis(i,j)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    I.write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T3-P5423-USACO19OPEN-Valleys"><a href="#T3-P5423-USACO19OPEN-Valleys" class="headerlink" title="T3-P5423 [USACO19OPEN]Valleys"></a>T3-<a href="https://www.luogu.org/problem/P5423">P5423 [USACO19OPEN]Valleys</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>（还是自己看┗｀O′┛</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>（留个坑，似乎是个定理题 粘个题解慢慢看：<img src="https://img.abc233.site/2019/09/15/f8af419576c70.png"> <a href="https://blog.csdn.net/qq_39972971/article/details/89296244">题解出自这里</a></p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part2 NBCX Day11 bracket 题解</title>
      <link href="/2019/08/16/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day11-bracket-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/16/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day11-bracket-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>现在有一个长度为$ n $且合法的括号序列，每次询问将会翻转其中一个括号（左括号与右括号互相变换），你要对于每个询问，再翻转一个括号（可以与讯问中的相同），使得括号序列仍旧合法，且翻转的位置尽量靠前。 询问和回应的效果都是是叠加的，也就是括号序列在某个询问后，会按照询问和回应永久改变。 对于$100\text</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part2 NBCX Day8 Cloud 题解</title>
      <link href="/2019/08/13/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day8-cloud-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/13/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day8-cloud-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出每个云的位置及大小以及移动方向，它们的移动速度均为$1$个单位长度每单位时间，在时刻0，所有的云没有重叠，问在所有时刻中（从负无穷到正无穷）中，云重叠层数最多是多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>非常显然，答案只有可能是$1$或$2$。 所以，直接$rand()\text</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3515 [POI2011]Lightning Conductor 题解</title>
      <link href="/2019/08/13/luogu-p3515-poi2011lightning-conductor-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/13/luogu-p3515-poi2011lightning-conductor-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://www.luogu.org/problem/P3515">题目传送门</a> 已知一个长度为$n$的序列$a_1,a_2,…,a_n$。 对于每个$1\leq i\leq n$，找到最小的非负整数$p$满足 对于任意的$j$,$ a_j \leq a_i + p - \sqrt{ i-j }$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先先把题目中的式子化简一下： $p\geq a_j+\sqrt{i-j}-a_i$ <img src="https://s2.ax1x.com/2019/08/13/mp7vin.gif"> 原来就是求对于每个$1\leq i \leq n$，对于任意的$j$,求出$a_j+\sqrt{i-j}-a_i$的最大值啊~~~ 考虑跑两次决策单调性，一次$i&gt;j$，另一次$i&lt;j$，那么就可以把绝对值去掉了。 这里就只考虑$i&gt;j$的情况。 对于每个$1\leq i \leq n$，只要求出最大的$a_j+\sqrt{i-j}$即可。 然而发现$a_j+\sqrt{i-j}$可以决策单调性优化。 也就是说，当i增大时 $a[j1]+sqrt(abs(i-j1))$增大值比$a[j2]+sqrt(abs(i-j2))$增大值小。 存在一个临界点$k$ 对于$j2+1&lt;&#x3D;i&lt;&#x3D;k，a[j1]+sqrt(abs(i-j1))&gt;a[j2]+sqrt(abs(i-j2))$ 对于$k&lt;i，a[j1]+sqrt(abs(i-j1))&lt;a[j2]+sqrt(abs(i-j2))$ 考虑使用分治来做决策单调性优化。 $Solve(l,r,ql,qr)$表示在区间$[ql,qr]$中，已经决策出最大值在区间$[l,r]$中。 对于每次$Solve(l,r,ql,qr)$直接暴力扫一遍$[l,r]$求出其中的最大值，所以在区间$[ql,mid-1]$中，最大值肯定在$[l,这个区间的最大值所在位置]$，同理，在区间$[mid+1,qr]$中，最大值肯定在$[这个区间的最大值所在位置,r]$。 那么就好了呀O(∩_∩)O。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define LD double</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a[500010],f[2][500010];</span><br><span class="line">LD calc(int x,int y)&#123;</span><br><span class="line">    return (LD)(sqrt((LD)abs((x-y)))+(LD)a[x]);</span><br><span class="line">&#125;</span><br><span class="line">void solve(int l,int r,int ql,int qr,int dd)&#123;</span><br><span class="line">    if(l&gt;rql&gt;qr) return;</span><br><span class="line">    int s=l,mid=ql+qr&gt;&gt;1ll;</span><br><span class="line">    double tmp=-19260817.19260817;</span><br><span class="line">    for(int i=l;i&lt;=r&amp;&amp;i&lt;=mid;i++)</span><br><span class="line">        if(tmp&lt;=calc(i,mid)) tmp=calc(i,mid),s=i;</span><br><span class="line">    f[dd][mid]=max(f[dd][mid],((int)tmp)+(((LD)((int)tmp))!=(LD)tmp)-a[mid]);</span><br><span class="line">    solve(l,s,ql,mid-1ll,dd);</span><br><span class="line">    solve(s,r,mid+1ll,qr,dd);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,a+i);</span><br><span class="line">    solve(1,n,1,n,0);</span><br><span class="line">    for(int i=1;i&lt;=n/2;i++) swap(a[i],a[n-i+1]);</span><br><span class="line">    solve(1,n,1,n,1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,max(f[0][i],f[1][n-i+1]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 决策单调性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part2 NBCX Day7 timegate 题解</title>
      <link href="/2019/08/12/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day7-timegate-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/12/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day7-timegate-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="http://hihocoder.com/problemset/problem/1147">原题链接</a> <a href="http://www.topoi.top/contests/view/1553/2">订正链接</a> 构造一个图，图的所有边权等于$1$，求使$1$到$n$的最短路距离为$k$的方案数。 对于$ 100\text</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part2 NBCX Day3 course 题解</title>
      <link href="/2019/08/08/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day3-course-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/08/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day3-course-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>神秘男子的学校安排了$ N $门课，每门从时间$ start_i $上到时间$ end_i$。神秘男子一次只能上一门课。神秘男子想法很多，他想知道$ Q $个时间段$ planstart_j $到$ planend_j $内, 他分别最多上几节课。 对于$100\text</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part2 NBCX Day2 XVII 题解</title>
      <link href="/2019/08/07/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day2-xvii-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/08/07/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart2-nbcx-day2-xvii-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个长度为$32$的只包含小写字母的字符串，问每个字符串读入时它之前有没有出现过？ 输出$n$行，每行输出$Yes$或$No$。 时间限制：$6s$ 空间限制：**$2M$**</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>出题人<strong>好心</strong>地帮我们把$2M$标红了… 考虑使用$map$，虽然$map$的准确性高，但是不仅常数大（但出题人好心地给了$6s$）空间上也会$MLE$。 考虑使用$hash$，虽然$hash$的空间消耗小（小？？？），但是准确性很低，在大数据时准确率几乎为$0$。 考虑使用布隆过滤器（Bloom Filter）。（什么鬼？？？我不会：<a href="https://baike.baidu.com/item/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/5384697?fr=aladdin">百度百科</a> 因为我太菜了又不想学，于是就做了一个玄学方法。 首先把输入数据分为$10$组，每组划分的依据是$hash$第一次过后的$hash$值。 然后$hash$数组就可以减少$10$了，O(∩_∩)O~~ 接着对于每一组再一次$hash$，并且把这第二次的$hash$值作为$hash$邻接表的$son$值（即$hash$匹配值，原为字符串） 然后都是$hash$的操作啦~~~</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define N 100001</span><br><span class="line">#define re register</span><br><span class="line">#define S 8192</span><br><span class="line">char buf[S],*L,*R;</span><br><span class="line">#define pc putchar</span><br><span class="line">inline int gc()&#123;return (L==R&amp;&amp;(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++);&#125;</span><br><span class="line"></span><br><span class="line">class Quick_Input_Output&#123;</span><br><span class="line">    public:</span><br><span class="line">        inline int read()&#123;</span><br><span class="line">            int res=0,f=1;char ch=gc();</span><br><span class="line">            while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=gc();&#125;</span><br><span class="line">            while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=gc();</span><br><span class="line">            return res*f;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void write(int x)&#123;</span><br><span class="line">            if(x&lt;0) pc(&#x27;-&#x27;),x=-x;</span><br><span class="line">            if(x&lt;10) pc(x+&#x27;0&#x27;);</span><br><span class="line">            else write(x/10),pc(x%10+&#x27;0&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">//      #undef gc</span><br><span class="line">        #undef pc</span><br><span class="line">&#125;I;</span><br><span class="line"></span><br><span class="line">#define File freopen(&quot;xvii.in&quot;,&quot;r&quot;,stdin);freopen(&quot;xvii.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">#define ReFile fclose(stdin);freopen(&quot;xvii.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line"></span><br><span class="line">bitset&lt;480001&gt; ans;</span><br><span class="line"></span><br><span class="line">class Hash&#123;</span><br><span class="line">    private:</span><br><span class="line">        int fir[N],nxt[65000],son[65000],tot;</span><br><span class="line">    public:</span><br><span class="line">        inline int get(string str,int base,int Md)&#123;//hash</span><br><span class="line">            re int s=0;</span><br><span class="line">            for(int i=0;i&lt;32;i++) s=((long long)s*base+str[i]-&#x27;a&#x27;)%Md;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void clean()&#123;//清空</span><br><span class="line">            memset(fir,0,sizeof(fir));tot=0;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void add(int x,int y)&#123;//邻接表</span><br><span class="line">            ++tot;</span><br><span class="line">            nxt[tot]=fir[x];</span><br><span class="line">            fir[x]=tot;</span><br><span class="line">            son[tot]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        inline void Work(int i,int V1,int V2)&#123;//先搜索，没有则加入，有则标记答案</span><br><span class="line">            for(int to,j=fir[V1];j;j=nxt[j])&#123;</span><br><span class="line">                to=son[j];</span><br><span class="line">                if(to==V2)&#123;</span><br><span class="line">                    ans.set(i);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ans.test(i)==0) add(V1,V2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;H;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int n,V1,V2;</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    File</span><br><span class="line">    ans.reset();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    re int L,R,i,j;</span><br><span class="line">    for(L=0;L&lt;1000000;L+=100000)&#123;//分成10个区间</span><br><span class="line">        H.clean();</span><br><span class="line">        R=L+100000-1;</span><br><span class="line">        n=I.read();</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            c=gc();str=&quot;&quot;;</span><br><span class="line">            while(c&lt;&#x27;a&#x27;&amp;&amp;c&gt;&#x27;z&#x27;) c=gc();</span><br><span class="line">            for(j=0;j&lt;32;j++)&#123;</span><br><span class="line">                str+=c;c=gc();</span><br><span class="line">            &#125;</span><br><span class="line">            V1=H.get(str,233,1000000);//第一次hash</span><br><span class="line">            V2=H.get(str,114514,1000000009);//第二次hash</span><br><span class="line">            if(V1&lt;LV1&gt;R) continue ;//是否在区间内</span><br><span class="line">            V1-=L;//减去边界值，防止越界</span><br><span class="line">            H.Work(i,V1,V2);//计算答案</span><br><span class="line">        &#125;</span><br><span class="line">        ReFile         //再次打开文件（即下一个区间</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++) puts(ans.test(i)==0?&quot;No&quot;:&quot;Yes&quot;);//三位运算符</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
            <tag> 玄学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part1 QZEZ Day6 B 题解</title>
      <link href="/2019/07/21/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-day6-b-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/07/21/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-day6-b-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一只萌萌的$ Galo $在沙滩上散步。突然，可怕的事情发生了！一只$ OvO $正在看着他！ 为了逃脱被吃掉的命运，$Galo $稽中生智，扔出了自己研究了很久的一道题给昆西： 斐波那契数列是这样的一个数列 $F_0 &#x3D; 1, F_1 &#x3D; 2$ $F_i &#x3D; F_{i−1} + F_{i−2}$ 对于一个数，Galo 定义它的斐波那契表示为将其表示为一些斐波那契数的和, 并将其转化为二进制数。 例如 $G(9) &#x3D; G(8 + 1) &#x3D; G(F4 + F0) &#x3D; (10001)_2 &#x3D; 16 + 1 &#x3D; 17$ 那么$ 9 $就可以表示为$10001$。注意到这种表示并不是唯一的，例如$9$也可以表示为$ 1101$。为了使这种表 示唯一，$Galo $决定使用如下程序来得出表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int decompose (n) &#123;</span><br><span class="line">    ans = 0</span><br><span class="line">    while (n) &#123;</span><br><span class="line">        f i n d the l a r g e s t F[ i ] &lt;= n</span><br><span class="line">        ans = (1 &lt;&lt; i )</span><br><span class="line">        n = n − F[ i ]</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这样就可以使每个数有唯一的表示了！例如$ G(30) &#x3D; (1010001)_2 &#x3D; 64 + 16 + 1 &#x3D; 81$ 现在$ Galo $给出了一个区间$ [A, B]$, 他想知道$ G(A) \text{ xor } G(A + 1) .. \text{ xor } G(B - 1) \text{ xor } G(B) $是多少 昆西当然不知道怎么做了啊！这个问题就交给你了！ 答案对$10^9+7$取模。 $A,B\leq 10^{15}$</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先发现$A,B$范围很大，考虑使用异或前缀和。 那么答案就是$Ans_B \text{ xor } Ans_{A-1}$ 定义$F(x)$表示$G(1) \text{ xor } G(2) \text{ xor }…\text{ xor } G(x)$ 记$ P[i] &#x3D; F({Fib}_i − 1)$ 对于求一般的$ F(n)$, 对于求考虑逐位确定答案。 记$ i $为最大的$ Fib $数，满足$ {Fib}_i ≤ x$ 那么第$ i $位的答案只与$ n − F ibi + 1 $的奇偶性有关 用$C++STL$中$bitset$实现</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>顺便介绍一下$bitset$ 常见操作有：位运算、$set$（将某位改为1）,$reset$（将某位改为0）,$flip$将某位取反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define mod 1000000007</span><br><span class="line">#define int long long</span><br><span class="line">#define S bitset&lt;105&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int fib[110],P[88],V,A,B,ans;</span><br><span class="line">S f[110],Ans;</span><br><span class="line">void Print(S n)&#123;</span><br><span class="line">    ans=0;for(int i=80;i&gt;=0;i--) ans=(ans*2+n.test(i))%mod;</span><br><span class="line">    write(ans);</span><br><span class="line">&#125;</span><br><span class="line">S Get(int x)&#123;</span><br><span class="line">    if(x==0)&#123;S s;s.reset();return s;&#125;</span><br><span class="line">    for(int i=80;i&gt;=0;i--)&#123;</span><br><span class="line">        if(fib[i]&gt;x) ;</span><br><span class="line">        else&#123;</span><br><span class="line">            S s;s.reset();</span><br><span class="line">            s=f[i]^Get(x-fib[i]);</span><br><span class="line">            if((x-fib[i]+1)&amp;1==1) s.flip(i);</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    fib[0]=1;fib[1]=2;</span><br><span class="line">    for(int i=2;i&lt;=80;i++)&#123;</span><br><span class="line">        fib[i]=fib[i-1]+fib[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    f[0].reset();f[1].set(0);</span><br><span class="line">    for(int i=2;i&lt;=80;i++)&#123;</span><br><span class="line">        f[i]=f[i-1]^f[i-2];</span><br><span class="line">        if((fib[i]-fib[i-1])&amp;1==1) f[i].flip(i-1);</span><br><span class="line">    &#125;</span><br><span class="line">    A=read();B=read();</span><br><span class="line">    Ans=Get(B)^Get(A-1);</span><br><span class="line">    Print(Ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xor </tag>
            
            <tag> bitset </tag>
            
            <tag> 斐波那契 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part1 QZEZ Day2 A洗牌 题解</title>
      <link href="/2019/07/16/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-day2-a%E6%B4%97%E7%89%8C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/07/16/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-day2-a%E6%B4%97%E7%89%8C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>无聊的时间，小$ K $喜欢和他的室友们一起打扑克（这副扑克很神奇，上面写着$ 1 $到$ n $的数字各一张），打扑克前当然要先洗牌啦。 宿舍洗牌的方式十分简单，先将所有牌平均分成两份，然后交叉地混合到一起，举个例子，六张牌$ 1$ $ 2$ $3$ $ 4 $ $5 $ $6$ 在混合后后会变成 $1$ $4$ $2$ $5 $ $ 3$ $6$，但是这样的问题很明显，第一张牌和最后一张牌一定不会变化，所以他们还要将最后的$ k $张牌移动到最前面，如此的过程，混合加上切牌，称为一次洗牌。 小$ Y $并不信任小$ K $的洗牌姿势，他决定让小$ K $进行若干次洗牌后，检查其中某些牌牌面的数字，来确定小$ K $是否手上抹油，他知道这样洗牌的结果是固定的，但却不知道应该是什么，你能帮帮他吗？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>抹油是什么意思？QWQ 转入正题，首先一看这数据范围就是$O(N$ $logN)$的复杂度，设这个变换函数为$f(x)$，然后第一次变换后就是$f(x)$，两次是$f(f(x))$，三次是$f(f(f(x)))$，以此类推$\dots$。 所以这个函数$f(x)$支持倍增。 那么就预先处理出$2^n$变换的$f$函数，对于每次询问倍增就好了。 设$f[i][j]$为$2^i$次，第$j$位的变换。 那么：$f[i][j]&#x3D;f[i-1][f[i-1][j]];$ 但是毒瘤出题人卡了倍增，但卡卡常也就过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#pragma GCC optimize(3)</span><br><span class="line">#define pc(ch) (Ftop&lt;100000?Fout[Ftop++]=ch:(fwrite(Fout,1,100000,stdout),Fout[(Ftop=0)++]=ch))</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline char nc()&#123;</span><br><span class="line">    static char buf[100000],*p1=buf,*p2=buf;</span><br><span class="line">    return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line">// 整 数 快 速 读 入</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool rn(T&amp; _v) &#123;</span><br><span class="line">bool negative = false;</span><br><span class="line">char ch;</span><br><span class="line">_v = 0;</span><br><span class="line">while (!isdigit(ch = nc()) &amp;&amp; ch != EOF) &#123; negative = ch == &#x27;-&#x27;; &#125;;</span><br><span class="line">if (ch == EOF)return false;</span><br><span class="line">do &#123;</span><br><span class="line">_v *= 10;</span><br><span class="line">_v += ch - &#x27;0&#x27;;</span><br><span class="line">&#125; while (isdigit(ch = nc()));</span><br><span class="line">if (negative) _v = -_v;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">// 整 数 快 速 输 出</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">inline void o(T p) &#123;</span><br><span class="line">static int stk[70], tp;</span><br><span class="line">if (p == 0) &#123; putchar(&#x27;0&#x27;); return; &#125;</span><br><span class="line">if (p &lt; 0) &#123; p = -p; putchar(&#x27;-&#x27;); &#125;</span><br><span class="line">while (p) stk[++tp] = p % 10, p /= 10;</span><br><span class="line">while (tp) putchar(stk[tp--] + &#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,k,a[500010],f[41][500011];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    rn(n);rn(m);rn(k);</span><br><span class="line">    register int i,j,Ta,b;</span><br><span class="line">    for(i=1;i&lt;=(n&gt;&gt;1);i++)&#123;</span><br><span class="line">        a[(i&lt;&lt;1)]=(n&gt;&gt;1)+i,a[(i&lt;&lt;1)-1]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        f[0][i]=(i&lt;=k%n)?a[n-k+i]:a[i-(k%n)];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;40;i++)&#123;</span><br><span class="line">        for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            f[i][j]=f[i-1][(f[i-1][j])];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long long res=0,tot=0;</span><br><span class="line">    for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        rn(Ta);rn(b);</span><br><span class="line">        tot+=Ta;</span><br><span class="line">        res=tot;</span><br><span class="line">        for(j=0;res;res&gt;&gt;=1,j++)&#123;</span><br><span class="line">            if(res&amp;1ll) b=f[j][b];</span><br><span class="line">        &#125; </span><br><span class="line">        o(b);putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三校集训Part1 QZEZ 2019.7.15~2019.7.26</title>
      <link href="/2019/07/15/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-2019-7-152019-7-26/"/>
      <url>/2019/07/15/%E4%B8%89%E6%A0%A1%E9%9B%86%E8%AE%ADpart1-qzez-2019-7-152019-7-26/</url>
      
        <content type="html"><![CDATA[<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>没想到窝又来集训了，其实这个Day0与<a href="https://yzx233.xyz/archives/774">绍兴集训</a>的Day10是连在一起的。╮(╯▽╰)╭ 三校集训，故名思议就是三个学校的人一起集训(逃： 哪三个学校呢？当然是：qzez,cixi,yiwu</p><h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>一觉醒来已经是$7:30$，早饭在自己家里吃，中饭在食堂吃，菜还可以，但窝太菜点了一种最难吃的。。。上午讲题，是$zyr$巨佬讲的，我听得聚(dou)精(kuai)会(shui)神(le)，下午模拟赛，成绩不太好，$40+5+4&#x3D;49$(27&#x2F;93)，T1的负数忘记判了，本来可以有$50$分的。晚饭吃快餐，20元还有鱼吃，好评！ 晚上订正题目（反正窝都订正不来）</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>早饭还是在自己家里吃的，吃了碗稀饭+吞鸡蛋（好像是这样打的，不管他啦<del>(≧▽≦)&#x2F;</del>），早上听了$zyr$的计算几何讲座（为啥不是解析几何捏？因为运算有误差——By zyr）。听了一大堆法向量、凸壳等等（反正窝都听不懂），只看到大佬们一次又一次自信的走上讲台，谦虚地报上了蒟蒻们的名字。 中饭又是盒饭，味道还行( ⊙ _ ⊙ )，下午又是模拟赛，╮(╯▽╰)╭，成绩还是不太好$30+5+20&#x3D;55$(23&#x2F;81)机房里的部分大佬都去打$NOI$网络赛了，所以没来虐场。 晚饭还是盒饭，味道不错( ^_^ ) 晚上订正题目，（出题人好懒啊，就甩手一个Sol.pdf然后问我们看懂没…</p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>今天打了vjudge的ACM作业赛（就是作业）挂个链接：<a href="https://vjudge.net/contest/311832">vjudge homework contest</a> 又是被吊打的一天</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>今天打了<a href="https://acm.ecnu.edu.cn/">ECNU</a>华东师范大学的OJ上的ACM，同是切了3题，排名相差50+，泪奔┭┮﹏┭┮</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>今天爆炸了（我哪天不爆炸） 模拟赛：0+20+0&#x3D;20 (62&#x2F;87) 感觉要退役了</p><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天总算回升了（窝好菜啊） 90+40+0&#x3D;130 (23&#x2F;87)</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绍兴游记Day8 b 题解</title>
      <link href="/2019/07/12/day8-b-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/07/12/day8-b-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://loj.ac/problem/541">官方题目传送门</a> <a href="https://loj.ac/article/191">官方题解传送门</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$Hzy$有一个集合，一开始有$[0\dots a]$这些数字（如果$a&#x3D;-1$则说明集合为空）。接下来有$m$个时刻，每个时刻都会有一种操作。 1. 插入一个数字$x$，保证$x$不在集合中。 2. 删去一个数字$x$。 3. 把目前不在集合中的最早被删除的数字，插回到集合中（如果一个数字曾经被删去被插回来过然后再删去，这里认为其删去的时间为最近一次删去的时间）。 由于描述这$m$个时刻的操作实在太麻烦了，所以$Hzy$用了一个长度为$m$的序列$p$来描述每个时刻的操作种类。对于每个操作，满足以下约定。 1. 这个序列$p$里所有元素均为$[-1,b)$的整数 2. 若$p_i&#x3D;-1$，则表示时刻i的操作为第三种，如果此时并不存在满足条件且被删去的数字，则忽略此操作。 3. 否则，如果时刻$i$中，大小为$p_i$的数字一开始不在集合中且也从来没有通过第一种操作插入集合中，则表示第$i$个操作为向集合中插入一个大小为$p_i$的数字，即第一种操作。 4. 否则，如果时刻$i$中，大小为$p_i$的数字在集合中，则把$p_i$从集合里删除，即第二种操作。 5. 否则，表示时刻i的操作为第三种，如果此时并不存在满足条件且被删去的数字，则忽略此操作。 $Hzy$现在想知道在第$i$个时刻的操作进行完后，集合的$mex$是什么，即在集合中未出现过的最小的自然数。第$i$个操作的答案设为$ans_i$（如果第$i$个操作被忽略，$ans_i&#x3D;0$）。但是她不满足仅知道$ans_i$，她想知道$ans_i×(i^2+7i) \mod 998244353$的异或和 如果某个时刻的操作被忽略，那么$Hzy$将不会进行任何操作，也不计算此时的答案。 下面是$IO$输入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace IO&#123;</span><br><span class="line">    int c;</span><br><span class="line">    unsigned int seed;</span><br><span class="line">    unsigned int randnum()&#123;seed^=seed&lt;&lt;13;seed^=seed&gt;&gt;17;seed^=seed&lt;&lt;5;return seed;&#125;</span><br><span class="line">    inline int read(int &amp;x)&#123;scanf(&quot;%d&quot;,&amp;x);return x;&#125;</span><br><span class="line">    inline void init_case(int &amp;m,int &amp;a,int &amp;b,int &amp;d,int p[])&#123;scanf(&quot;%d%u%d%d%d%d&quot;,&amp;m,&amp;seed,&amp;a,&amp;b,&amp;c,&amp;d);for(int i=1;i&lt;=m;i++)&#123;if(randnum()%c==0)p[i]=-1;else p[i]=randnum()%b;&#125;&#125;</span><br><span class="line">    inline void update_ans(unsigned int &amp;ans_sum,unsigned int cur_ans,int no)&#123;const static unsigned int mod=998244353;ans_sum^=(long long)no*(no+7)%mod*cur_ans%mod;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解-amp-Code"><a href="#题解-amp-Code" class="headerlink" title="题解&amp;Code"></a>题解&amp;Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">namespace IO&#123;</span><br><span class="line">    int c;</span><br><span class="line">    unsigned int seed;</span><br><span class="line">    unsigned int randnum()&#123;seed^=seed&lt;&lt;13;seed^=seed&gt;&gt;17;seed^=seed&lt;&lt;5;return seed;&#125;</span><br><span class="line">    inline int read(int &amp;x)&#123;scanf(&quot;%d&quot;,&amp;x);return x;&#125;</span><br><span class="line">    inline void init_case(int &amp;m,int &amp;a,int &amp;b,int &amp;d,int p[])&#123;scanf(&quot;%d%u%d%d%d%d&quot;,&amp;m,&amp;seed,&amp;a,&amp;b,&amp;c,&amp;d);for(int i=1;i&lt;=m;i++)&#123;if(randnum()%c==0)p[i]=-1;else p[i]=randnum()%b;&#125;&#125;</span><br><span class="line">    inline void update_ans(unsigned int &amp;ans_sum,unsigned int cur_ans,int no)&#123;const static unsigned int mod=998244353;ans_sum^=(long long)no*(no+7)%mod*cur_ans%mod;&#125;</span><br><span class="line">&#125;</span><br><span class="line">void write(int x)&#123;if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;if(x&lt;10) putchar(x+&#x27;0&#x27;);else&#123;write(x/10);putchar(x%10+&#x27;0&#x27;);&#125;&#125;</span><br><span class="line">unsigned int ans_sum;</span><br><span class="line">int T,m,a,b,d,ans,p[4000010],f[4000010],vis[4000010],num[4000010],h,t,g[4000010];</span><br><span class="line">bool did[4000010],tag;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">namespace Solve&#123;</span><br><span class="line">    inline void Step1(int x)&#123;vis[x]=1;did[x]=1;while(vis[ans]&amp;&amp;ans&lt;=b) ans++;&#125;//操作1：加入一个数字，把这个数标记在集合中(did)以及之前或现在加入过(vis)，while求出范围内没有加入过的最小值</span><br><span class="line">    inline void Step2(int x)&#123;if(d==1)&#123;tag=1;return ;&#125;did[x]=0;q.push(x);while(h&lt;=t&amp;&amp;g[t]&gt;x) t--;g[++t]=x;&#125;//操作2：删除一个数，如果d=1那么忽略，否则将这个数取消在集合中这个标记(did)并且加入到&quot;删除过的&quot;队列中，再插入到删除的单调度队列</span><br><span class="line">    inline void Step3()&#123;if(dq.empty())&#123;tag=1;return ;&#125;did[q.front()]=1;q.pop();&#125;//操作3：加入最早删除的值，d=1、之前没有删除时忽略，否则把该数字标记在集合中，并且在队列中pop掉这个数</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    IO::read(T);//输入数据组数</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        IO::init_case(m,a,b,d,p);//调用IO读入</span><br><span class="line">        for(int i=0;i&lt;=a;i++) vis[i]=1,did[i]=1;//初始化，一开始[0,a]区间内所有的数都在集合中</span><br><span class="line">        for(int i=a+1;i&lt;=b;i++) vis[i]=0,did[i]=0;//初始化，一开始(a,b]区间内所有的数都不在集合中</span><br><span class="line">        ans=a+1;h=1;t=0;tag=0;ans_sum=0;//一开始ans=a+1（因为[0,a]区间内所有的数已经在集合中）</span><br><span class="line">        while(!q.empty()) q.pop();//清空队列</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            tag=0;//tag表示该操作是否忽略（0表示不忽略，1表示忽略）</span><br><span class="line">            if(p[i]==-1) Solve::Step3();//如果操作为-1，那么进行操作3</span><br><span class="line">            else if(vis[p[i]]==0) Solve::Step1(p[i]);//如果之前没有加入过该数，那么进行操作1</span><br><span class="line">            else if(did[p[i]]) Solve::Step2(p[i]);//如果现在还是有这个数，那么进行操作2</span><br><span class="line">            else Solve::Step3();//否则进行操作3</span><br><span class="line">            if(tag==1) continue ;//如果忽略，那就忽略</span><br><span class="line">            while(h&lt;=t&amp;&amp;did[g[h]]) h++;//如果在集合中，那就下一个</span><br><span class="line">            if(h&gt;t) IO::update_ans(ans_sum,ans,i);//如果队列里没有了，那么就是ans（加入操作中的最小值）</span><br><span class="line">            else IO::update_ans(ans_sum,min(ans,g[h]),i);//否则就是加入操作最小值与删除操作最小值的最小值</span><br><span class="line">        &#125;</span><br><span class="line">        write(ans_sum);putchar(&#x27;\n&#x27;);//输出最终结国</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绍兴游记Day1 b 题解</title>
      <link href="/2019/07/05/%E7%BB%8D%E5%85%B4%E6%B8%B8%E8%AE%B0day1-b-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/07/05/%E7%BB%8D%E5%85%B4%E6%B8%B8%E8%AE%B0day1-b-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="【问题描述】"><a href="#【问题描述】" class="headerlink" title="【问题描述】"></a>【问题描述】</h2><p>ξ成为了赛车手，但是她发现她没有实战经验。每参加一场赛车比赛她会获得$a_i$的经验，假设参加完这场比赛后她的总经验是$E$，那么她会获得$E ∗ b_i$的奖金。 ξ要参加的比赛场数是偶数，在参加完恰好一半的比赛后她会参加一个夏令营去练习飙车，这次夏令营会给她$X$点经验但是没有奖金。 ξ想知道如何合理安排参加比赛的顺序可以使得获得的奖金最多？你需要求出奖金的最大值。</p><h2 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h2><p>从文件$ b.in $中读入数据。 第一行两个正整数$n, X$。 第二行$n$个正整数$a_i$。 第三行$n$个正整数$b_i$。</p><h2 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h2><p>输出到文件$ b.out $中。 一行一个整数表示能够获得的最大奖金。</p><h2 id="【样例输入】"><a href="#【样例输入】" class="headerlink" title="【样例输入】"></a>【样例输入】</h2><p>2 10 1 1 1 5</p><h2 id="【样例输出】"><a href="#【样例输出】" class="headerlink" title="【样例输出】"></a>【样例输出】</h2><p>61</p><h2 id="【数据规模】"><a href="#【数据规模】" class="headerlink" title="【数据规模】"></a>【数据规模】</h2><p>对于$20$%的数据，$n ≤ 10$。 对于$40$%的数据，$n ≤ 20$。 另有$10$%的数据，$b_i &#x3D; 1$。 另有$10$%的数据，$a_i &#x3D; 1$。 对于$100$%的数据，$n ≤ 50, 1 ≤ a_i ≤ 10^5, 1 ≤ b_i ≤ 10, 0 ≤ X ≤ 10^5, n$是偶数。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>可以先考虑把所有比赛按照奖金贡献进行排序，最关键的就是如何排序、如何比较两场比赛的奖金贡献大小。 交换前： <img src="https://s2.ax1x.com/2019/07/05/Zd9OaT.png"> 交换后： <img src="https://s2.ax1x.com/2019/07/05/Zd9LZV.png"> 所以，我们可以事先求出$\frac{a_i}{b_i}$然后再按照$\frac{a_i}{b_i}$从大到小排序。</p><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><blockquote><p>因为$b$小$a$大，所以状态中只能记录有关$b$的那一部分。直接$DP$很难做到这样的效果，如果要只和$b$有关就必须支付更多的复杂度计算一些冗余状态以达到不重不漏的目的。 不妨直接大胆枚举后一半的$b$之和，然后在计算出的结果中只挑选b之和等于所枚举的答案的那一部分。</p></blockquote><p>设$f[i][j][k]$前$i$个比赛$j$个在前面$i-j$个在后面，在前面的$b$之和为$k$时的最大收益。 $f[i+1][j+1][k+a[i].b]&#x3D;max(f[i][j][k]+k*a[i].a) $ 选择在前面，比赛数量$i+1$，选择在前面$j+1$，前面的$b$之和$k+a[i].b$，转移：从该比赛再加上之前的比赛的$b$之和乘上$a[i].a$ $f[i+1][j][k]&#x3D;max(f[i][j][k]+(sum[i-1]-k)*a[i].a+p*a[i].a) $ 选择在后面，比赛数量$i+1$，选择在后面$j$不变，前面的$b$之和$k$不变，转移：从该比赛再加上之前的比赛的$b$之和（后面的）乘上$a[i].a$ 还有中途的$X$记得要加上：$ans&#x3D;max(ans,f[n+1][n&#x2F;2][p]+p*X)$ 最后还要把$n$个比赛的基本奖金加上：$for(int i&#x3D;1;i&lt;&#x3D;n;i++) ans+&#x3D;a[i].a*a[i].b$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>#include&lt;bits&#x2F;stdc++.h&gt;<br>#define inf 2e9<br>using namespace std;<br>int n,X,E,ans,vis[55],f[55][55][550],sum[55];<br>inline int read(){<br>char ch&#x3D;getchar();int res&#x3D;0,f&#x3D;1;<br>while(ch&lt;’0’ch&gt;’9’){if(ch&#x3D;&#x3D;’-‘)f&#x3D;-1;ch&#x3D;getchar();}<br>while(ch&gt;&#x3D;’0’&amp;&amp;ch&lt;&#x3D;’9’) res&#x3D;res*10+ch-‘0’,ch&#x3D;getchar();<br>return res*f;<br>}<br>struct node{<br>int a,b;<br>double c;<br>}a[55];<br>bool cmp(node qx,node qy){<br>return qx.c&gt;qy.c;<br>}<br>int main(){<br>&#x2F;&#x2F;freopen(“b.in”,”r”,stdin);freopen(“b.out”,”w”,stdout);<br>n&#x3D;read();X&#x3D;read();<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i].a&#x3D;read();<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i].b&#x3D;read();<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i].c&#x3D;(double)a[i].a&#x2F;(double)a[i].b;&#x2F;&#x2F;计算出sort比较系数<br>sort(a+1,a+n+1,cmp);&#x2F;&#x2F;排序<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++) sum[i]&#x3D;sum[i-1]+a[i].b;<br>for(int p&#x3D;n&#x2F;2;p&lt;&#x3D;10*(n&#x2F;2);p++){&#x2F;&#x2F;枚举前面的比赛的b之和<br>for(int i&#x3D;2;i&lt;&#x3D;n+2;i++)&#x2F;&#x2F;第一场比赛不能清（用来dp初始），因为下面下标会加一，所以多清空一个<br>for(int j&#x3D;0;j&lt;&#x3D;i-1;j++)&#x2F;&#x2F;前面的比赛数量<br>for(int k&#x3D;j;k&lt;&#x3D;j*10;k++) f[i][j][k]&#x3D;-inf;&#x2F;&#x2F;前面的b之和，清空<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++){<br>for(int j&#x3D;0;j&lt;&#x3D;i-1;j++){<br>for(int k&#x3D;j;k&lt;&#x3D;j*10;k++){<br>if(f[i][j][k]&gt;&#x3D;0){&#x2F;&#x2F;初始状态<br>f[i+1][j+1][k+a[i].b]&#x3D;max(f[i][j][k]+k*a[i].a,f[i+1][j+1][k+a[i].b]);&#x2F;&#x2F;放在前面<br>f[i+1][j][k]&#x3D;max(f[i+1][j][k],f[i][j][k]+(sum[i-1]-k)*a[i].a+p*a[i].a);&#x2F;&#x2F;放在后面<br>}<br>}<br>}<br>}<br>ans&#x3D;max(ans,f[n+1][n&#x2F;2][p]+p*X);&#x2F;&#x2F;不要忘记二分之一的n时的经验X<br>}<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++) ans+&#x3D;a[i].a*a[i].b;&#x2F;&#x2F;不要忘记基本的奖学金<br>printf(“%d\n”,ans);return 0;<br>}</p><p>完结撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绍兴游记2019.7.4-2019.7.14</title>
      <link href="/2019/07/05/%E7%BB%8D%E5%85%B4%E6%B8%B8%E8%AE%B02019-7-4-2019-7-14/"/>
      <url>/2019/07/05/%E7%BB%8D%E5%85%B4%E6%B8%B8%E8%AE%B02019-7-4-2019-7-14/</url>
      
        <content type="html"><![CDATA[<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>来到绍兴花了$4$小时，吐槽司机…… 晚餐在浙江越秀外国语学院(镜湖校区)内的酒店里吃的，$30$元的快餐感觉还不如$3$元的方便面。 <img src="https://s2.ax1x.com/2019/07/05/Za7iQg.png"> 晚上认真学习了emmmm…..（心疼我的3.0GB流量）顺便吐槽一下酒店的$WIFI$，没连上就算了，好不容易连上了，最高网速$20KB&#x2F;s$还不如不连呢。 晚上12:00准时睡觉</p><h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>凌晨5:40起床，还是在酒店里吃早饭，还是要吐槽一下，各种蔬菜有很多，连稀饭都没有，7:20左右出发去绍兴一中，才知道今天花$5$小时打$NOI$（国赛），本PJ1&#x3D;都没有的蒟蒻瑟瑟发抖。打到10:00左右就弃疗了，开始乱逛绍兴电脑的各个文件，惊奇发现：</p><ol><li>电脑竟然没有还原卡，桌面很乱</li><li>竟然还有$360$杀毒软件</li><li>竟然还有各种学习用品</li></ol><p>中午在绍兴一中食堂吃饭，只开了一个窗口，总共只有$6$个菜，牛奶有种过期（应该是我喝不来）的感觉，饭有点少，貌似也不能加饭，中评吧…..（貌似还没有本中学好） 吃完饭后回到机房，发现绍兴一中的人们学习热情很高啊…回来看了看分数，emmmm，NOI比赛0+20+30&#x3D;50，被虐死了…NOIP比赛50+100&#x3D;150（咦？怎么才两道题） 下午订正题目，等待讲评。 14:30-14:50被拉去听讲评，一句也没听懂… 晚上在绍兴一中食堂吃饭，盛饭阿姨不想找零直接塞给我一瓶牛奶（对对对就是上文说的牛奶），吃完饭后买了碗泡面，回酒店吃了。</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>凌晨6:00起床，吃完早饭后又到了绍兴一中，今天的题目好难啊（我太菜了），暴零滚粗。某$julao$在机房里打喷嚏，声音可真emmmm响(lh还录了音)。 中午的饭一如既往的“好吃”，下午13:30去听讲评。 讲评的人首先说了一句：第三题是最水的，果然Luogu上T3是黑题，T1也是黑题，T2还是黑题。(emmmm:</p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>今天7:00才起床，绍兴一中暂停集训一天，良心的老师们早就给我们准备了一套题目，花了3h打比赛，打完以后忽然听到某$julao$喊道：怎么才三小时… 打得还可以，但T2一点头绪也没有，T3邻接表忘记开双倍空间了，结果：100+0+40&#x3D;140 Rank3，还好还是涨rating的。 早饭还是在酒店吃，中饭、晚饭自己点外卖，吃泡面… 下午、晚上整理题目、认真学习。</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>今天绍兴一中不考试，早上听了$Ajatar$讲模拟、搜索，下午做习题。几乎每一道题都是紫题、黑题，基本上都做不来（除了几道rand竟然过了）。</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>早上的模拟赛10+0+5&#x3D;15，50&#x2F;78，Luogu上原题全部都是黑题（感觉15分很应该）Emmmmm…下午订正题目，一看题解，算了，还是不看了…. 说</p><blockquote><p>这题就这么简单，主要是细节处理上比较麻烦。</p></blockquote><p>结果都是黑题…</p><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天讲了一天的课，头昏眼花。讲了线段树进阶、可持久化、Heap、Treap等等。</p><h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><p>把Day6讲的作业做了</p><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><p>今天模拟赛，被虐惨了，10+0+0&#x3D;10。泪奔~~o(&gt;_&lt;)o ~~</p><h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p>今天还是模拟赛，还是被虐惨了，隔壁NOI组来打，结果窝才0+0+15&#x3D;15，赛后才发现自己把T1想复杂了(╥╯^╰╥)</p><p>（未完待续）</p><p>[mdx_progress]90[&#x2F;mdx_progress]</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2019模拟赛（十）06.02</title>
      <link href="/2019/06/02/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E5%8D%81%EF%BC%8906-02/"/>
      <url>/2019/06/02/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E5%8D%81%EF%BC%8906-02/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><h2 id="NOIP2019模拟赛（十）06-02"><a href="#NOIP2019模拟赛（十）06-02" class="headerlink" title="NOIP2019模拟赛（十）06.02"></a><a href="http://211.140.156.254:2333/contest/150">NOIP2019模拟赛（十）06.02</a></h2><h2 id="A-transfer"><a href="#A-transfer" class="headerlink" title="A. transfer"></a>A. transfer</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$n$个小孩，他们会进行$t$轮游戏。一开始，鲜花在第一个孩子手里，每轮游戏持有鲜花的小孩可以把鲜花传递给除了自己以外的任意一个小孩。那么，一共有多少种传递方法，可以让鲜花在游戏结束时回到第一个小孩上呢？ 对于$100$%的数据，$n,t \leq 10^{18}$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每一轮，每个小孩都可以传递给另外一个小孩，那么就有$n-1$种传递方法。 有$t$轮，所以总共有$(n-1)^t$种传递方法。 每种传递方法的概率都是相同的，所以传递给第一个孩子的可能性为$\frac{(n-1)^t}{n}$。 注意，$n,t$的范围都很大，所以需要快速幂$+$乘法逆元。 对于$NOIPPJ$等级的我，只需要明白：费马小定理：当$ p $为素数时，$ a^{p-1}&#x3D;1 (mod p) $。那么$ a*a^{p-2}&#x3D;1 (mod p) $。即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#pragma GCC optimize(2)</span><br><span class="line">#define int long long</span><br><span class="line">#define mod 1000000007</span><br><span class="line">using namespace std;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,t;</span><br><span class="line">int fpow(int a,int b)&#123;//快速幂</span><br><span class="line">    int res=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b%2==1) res=(res*a)%mod;</span><br><span class="line">        a=(a*a)%mod,b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();t=read();n%=mod;</span><br><span class="line">    if(t==1)&#123;</span><br><span class="line">        puts(&quot;0&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=fpow(n-1,t-1);</span><br><span class="line">    if(t%2==1) ans=((ans-1)*(n-1))%mod;//分奇偶讨论</span><br><span class="line">    else ans=((ans+1)*(n-1))%mod;</span><br><span class="line">    ans=(ans+mod)%mod;</span><br><span class="line">    ans=ans*fpow(n,mod-2)%mod;//乘法逆元</span><br><span class="line">    write(ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-minecraft"><a href="#B-minecraft" class="headerlink" title="B. minecraft"></a>B. minecraft</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>不要问我为什么这么懒就放一个pdf</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先$O(n^2)$求出每个点到其他点的距离：$sqrt({(x_1-x_2)}^2+{(y_1-y_2)}^2)-(z_1+z_2)$ 然后跑一遍最短路就好了。 但是二分答案来check也行。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define int long long</span><br><span class="line">#define sqr(x) ((x)*(x))</span><br><span class="line">using namespace std;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,s,t,vis[5010];</span><br><span class="line">double f[5010][5010],Max,ans;</span><br><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">string tmp;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;a[5010];</span><br><span class="line">double dist(int i,int j)&#123;</span><br><span class="line">    return ((double)sqrt((double)((double)sqr(a[i].x-a[j].x)+(double)sqr(a[i].y-a[j].y)))-(double)(a[i].z+a[j].z));</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">bool check(double x)&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    q.push(s);vis[s]=1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(vis[i]==0&amp;&amp;f[u][i]&lt;=x)&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                vis[i]=1;</span><br><span class="line">                if(i==t) return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(int x,y,z,i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;tmp;a[i].x=read();a[i].y=read();a[i].z=read();</span><br><span class="line">        mp[tmp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;tmp;s=mp[tmp];</span><br><span class="line">    cin&gt;&gt;tmp;t=mp[tmp];</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            f[i][j]=f[j][i]=((dist(i,j)&lt;0.0)?0.0:dist(i,j));</span><br><span class="line">            Max=max(Max,f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    double l=0.0,r=Max,mid;</span><br><span class="line">    while(r-l&gt;=eps)&#123;</span><br><span class="line">        mid=(l+r)/2.0;</span><br><span class="line">        if(check(mid)) ans=mid,r=mid-eps;</span><br><span class="line">        else l=mid+eps;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.6lf\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-rewrite"><a href="#C-rewrite" class="headerlink" title="C. rewrite"></a>C. rewrite</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于一片森林，有两个操作： 1. 输入$x,y$把$ x,y $两点连通，并且把他们的权值修改为$\frac{⌊Vx+Vy⌋}{2}$，若$x,y$已经连通，则忽略此操作。 2.查询$ x,y $两点之间的唯一路径上有多少种不同的点权，若$x,y $此时还不连通，输出$-1$。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>开一个$ 60 $位的二进制，某一位为$ 1 $就表示有这种颜色，然后用线段树维护区间信息就好了，每次合并或者查询就是一个二进制“或”的操作。 当然，用$LCT$与树剖都可以。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 100010*2</span><br><span class="line">using namespace std;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else write(x/10),putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,op,u,v;</span><br><span class="line">int fa[MAXN];</span><br><span class="line">int getfa(int x)&#123;</span><br><span class="line">    return x==fa[x]?x:fa[x]=getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">class LinkCutTree&#123;</span><br><span class="line">    public:</span><br><span class="line">        struct node&#123;</span><br><span class="line">            int f,c[2],v,xs,tag,xx;</span><br><span class="line">        &#125;t[300010];</span><br><span class="line">        bool Isroot(int x)&#123;</span><br><span class="line">            int y=t[x].f;</span><br><span class="line">            return !(t[y].c[0]==xt[y].c[1]==x);</span><br><span class="line">        &#125;</span><br><span class="line">        void Upd(int x)&#123;</span><br><span class="line">            t[x].xs=(1ll&lt;&lt;t[x].v)t[t[x].c[0]].xst[t[x].c[1]].xs;</span><br><span class="line">        &#125;</span><br><span class="line">        void Psd(int x)&#123;</span><br><span class="line">            if(t[x].tag)&#123;</span><br><span class="line">                swap(t[x].c[0],t[x].c[1]);</span><br><span class="line">                if(t[x].c[0])t[t[x].c[0]].tag^=1;</span><br><span class="line">                if(t[x].c[1])t[t[x].c[1]].tag^=1;</span><br><span class="line">                t[x].tag=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        void Rotate(int x)&#123;</span><br><span class="line">            int y=t[x].f,z=t[y].f;</span><br><span class="line">            Psd(y);</span><br><span class="line">            Psd(x);</span><br><span class="line">            int c=t[y].c[1]==x;</span><br><span class="line">            if(!Isroot(y))&#123;</span><br><span class="line">                int gc=t[z].c[1]==y;</span><br><span class="line">                t[z].c[gc]=x;</span><br><span class="line">            &#125;</span><br><span class="line">            t[x].f=z;</span><br><span class="line">            t[y].c[c]=t[x].c[c^1];</span><br><span class="line">            t[t[x].c[c^1]].f=y;</span><br><span class="line">            t[x].c[c^1]=y;</span><br><span class="line">            t[y].f=x;</span><br><span class="line">            Upd(y);</span><br><span class="line">            Upd(x);</span><br><span class="line">        &#125;</span><br><span class="line">        void Splay(int x)&#123;</span><br><span class="line">            Psd(x);</span><br><span class="line">            while(!Isroot(x))&#123;</span><br><span class="line">                int y=t[x].f,z=t[y].f;</span><br><span class="line">                if(Isroot(y))Rotate(x);</span><br><span class="line">                else&#123;</span><br><span class="line">                    Psd(z);</span><br><span class="line">                    Psd(y);</span><br><span class="line">                    int c=t[y].c[1]==x,gc=t[z].c[1]==y;</span><br><span class="line">                    if(c==gc)Rotate(y);</span><br><span class="line">                    else Rotate(x);</span><br><span class="line">                    Rotate(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        void Access(int x,int lst)&#123;</span><br><span class="line">            if(!x)return;</span><br><span class="line">            Splay(x);</span><br><span class="line">            t[x].c[1]=lst;</span><br><span class="line">            Upd(x);</span><br><span class="line">            Access(t[x].f,x);</span><br><span class="line">        &#125;</span><br><span class="line">        void Makeroot(int x)&#123;</span><br><span class="line">            Access(x,0);</span><br><span class="line">            Splay(x);</span><br><span class="line">            t[x].tag^=1;</span><br><span class="line">        &#125;</span><br><span class="line">        void Split(int x,int y)&#123;</span><br><span class="line">            Makeroot(x);</span><br><span class="line">            Access(y,0);</span><br><span class="line">            Splay(y);</span><br><span class="line">        &#125;</span><br><span class="line">        int Findroot(int x)&#123;</span><br><span class="line">            Access(x,0);</span><br><span class="line">            Splay(x);</span><br><span class="line">            Psd(x);</span><br><span class="line">            while(t[x].c[0])&#123;</span><br><span class="line">                x=t[x].c[0];</span><br><span class="line">                Psd(x);</span><br><span class="line">            &#125;</span><br><span class="line">            Splay(x);</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        int Link(int x,int y)&#123;</span><br><span class="line">            Makeroot(x);</span><br><span class="line">            if(Findroot(y)!=x)&#123;</span><br><span class="line">                t[x].f=y;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        void Cut(int x,int y)&#123;</span><br><span class="line">            Makeroot(x);</span><br><span class="line">            Psd(x);</span><br><span class="line">            if(Findroot(y)==x&amp;&amp;t[y].f==x&amp;&amp;!t[y].c[0])&#123;</span><br><span class="line">                t[x].c[1]=t[y].f=0;</span><br><span class="line">                Upd(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int Query(int x,int y)&#123;</span><br><span class="line">            if(Findroot(x)!=Findroot(y))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            Split(x,y);</span><br><span class="line">            int tmp=t[y].xs,sum=0;</span><br><span class="line">            while(tmp)&#123;</span><br><span class="line">                tmp-=(tmp&amp;-tmp),++sum;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">        void Change(int x,int y)&#123;</span><br><span class="line">            Splay(x);</span><br><span class="line">            t[x].v=y;</span><br><span class="line">            Upd(x);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;tr;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) tr.t[i].v=read(),fa[i]=i,tr.Upd(i);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read();u=read();v=read();</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            int tmp=tr.Link(u,v);</span><br><span class="line">            if(tmp==1)&#123;</span><br><span class="line">                int Cost=(tr.t[u].v+tr.t[v].v);</span><br><span class="line">                Cost&gt;&gt;=1;</span><br><span class="line">                tr.Change(u,Cost);</span><br><span class="line">                tr.Change(v,Cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(op==2)&#123;</span><br><span class="line">            int tmp=tr.Query(u,v);</span><br><span class="line">            write(tmp),putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> LCT </tag>
            
            <tag> LCA </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 乘法逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3232 [HNOI2013]游走 题解</title>
      <link href="/2019/05/19/luogu-p3232-hnoi2013%E6%B8%B8%E8%B5%B0-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/05/19/luogu-p3232-hnoi2013%E6%B8%B8%E8%B5%B0-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在一个无向图中，小$Z$以$1$为起点，每次以<strong>相等的概率</strong>选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小$Z$走到$N$（即终点），结束了这次游走，总得分为游走时经过的每一条边的编号之和。现在，请你对这$M$条边进行编号，使得小$Z$获得的总分的期望值最小。 输入保证: 1. $30$%的数据满足$N&lt;&#x3D;10$ 2. $100$%的数据满足$2&lt;&#x3D;N&lt;&#x3D;500$且是一个无向简单连通图。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先要明白<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/619561?fr=aladdin">高斯消元</a></p><blockquote><p>数学上，高斯消元法（或译：高斯消去法），是线性代数规划中的一个算法，可用来为线性方程组求解。但其算法十分复杂，不常用于加减消元法，求出矩阵的秩，以及求出可逆方阵的逆矩阵。不过，如果有过百万条等式时，这个算法会十分省时。一些极大的方程组通常会用迭代法以及花式消元来解决。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。高斯消元法可以用在电脑中来解决数千条等式及未知数。亦有一些方法特地用来解决一些有特别排列的系数的方程组。 ——转自百度百科</p></blockquote><p>可以去过一过<a href="https://www.luogu.org/problemnew/show/P3389">Luogu P3389 高斯消元的模板题</a> 简单讲一下高斯消元。 如果有一个方程组，如： <img src="https://images2017.cnblogs.com/blog/1114606/201709/1114606-20170922113249993-714245417.png"> 将上面的方程转为下面的增广矩阵 <img src="https://images2017.cnblogs.com/blog/1114606/201710/1114606-20171008205355309-432505599.png"> 接下来进行高斯消元。 首先找到一个第一列的数不为0的行（一般找第一列的数最大的行）（如果都为0就跳过当前步） 然后用它的第一列的数将下面行当前列的值化为0，变换过的初等矩阵与原矩阵等价，化为方程后依然成立 本矩阵第一列的数最大的为第三行就把第三行与第一行交换 <img src="https://images2017.cnblogs.com/blog/1114606/201710/1114606-20171008212338528-438396057.png"> 然后下面行的当前列消去，如图 <img src="https://images2017.cnblogs.com/blog/1114606/201710/1114606-20171008212836246-1791091272.png"> 除了最后一列外，每一列都如此，最后得到上三角矩阵如图 <img src="https://images2017.cnblogs.com/blog/1114606/201710/1114606-20171008213148574-1107129056.png"> 这样我们就可以轻松求出$x1,x2,x3$了。 回归到这道题 我们设$deg_i$表示第$i$个点的度数，$f_i$表示第$i$个点期望经过次数： <img src="https://s2.ax1x.com/2019/05/19/EjZ4Xj.png"> 由于当小$Z$到达$n$点时就停止游走了，因此不能考虑$n$点。接下来对$n−1$个$f_i$进行高斯消元求解。 设$g_i$表示第$i$条边期望经过次数： $g_{i}&#x3D;\frac{f_{u}}{d_{u}}+\frac{f_{v}}{d_{v}} \quad E_{i}&#x3D;(u, v), u \neq n, v \neq n$ 最后排序，贪心，因为要求期望值最小，那么就把最大的$g_i$编号标至最小，以此类推。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define MAXN 510</span><br><span class="line">#define eps 1e-8</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n;</span><br><span class="line">double a[MAXN][MAXN];</span><br><span class="line">void Gauss()&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int Cho=i;</span><br><span class="line">        for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">            if(fabs(a[j][i]-a[Cho][i])&lt;=eps) Cho=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;=n;j++)&#123;</span><br><span class="line">            swap(a[i][j],a[Cho][j]);//交换</span><br><span class="line">        &#125;</span><br><span class="line">        if(fabs(a[i][i])&lt;=eps)&#123;</span><br><span class="line">            puts(&quot;No Solution\n&quot;);//系数为0，无解:0*x=a</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++) a[i][j]/=a[i][i];//系数化为1</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(i!=j) for(int k=i+1;k&lt;=n;k++) a[j][k]-=a[j][i]*a[i][k];//计算</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;=n;j++) a[i][j]=(double)read();</span><br><span class="line">    Gauss();</span><br><span class="line">    for(int i=0;i&lt;n;i++) printf(&quot;%.2lf\n&quot;,a[i][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="游走"><a href="#游走" class="headerlink" title="游走"></a>游走</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define MAXN 510</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define MAXM 5000010</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">double a[MAXN][MAXN];</span><br><span class="line">void Gauss(int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int Cho=i;</span><br><span class="line">        for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">            if(fabs(a[j][i]-a[Cho][i])&lt;=eps) Cho=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;=n;j++)&#123;</span><br><span class="line">            swap(a[i][j],a[Cho][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(fabs(a[i][i])&lt;=eps)&#123;</span><br><span class="line">            puts(&quot;No Solution\n&quot;);</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i+1;j&lt;=n;j++) a[i][j]/=a[i][i];</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            if(i!=j) for(int k=i+1;k&lt;=n;k++) a[j][k]-=a[j][i]*a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int fir[MAXM],nxt[MAXM],w[MAXM],son[MAXM],tot;</span><br><span class="line">int deg[MAXN],u[MAXM],v[MAXM];</span><br><span class="line">double f[MAXM],ans;</span><br><span class="line">struct node&#123;</span><br><span class="line">    double g;</span><br><span class="line">    int id;</span><br><span class="line">&#125;K[MAXM];</span><br><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    son[tot]=y;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(node qx,node qy)&#123;</span><br><span class="line">    return qx.g&gt;qy.g;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        u[i]=read(),v[i]=read();</span><br><span class="line">        add(u[i],v[i],0);</span><br><span class="line">        add(v[i],u[i],0);</span><br><span class="line">        deg[u[i]]++;deg[v[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        a[i-1][i-1]=1.0;</span><br><span class="line">        for(int to,j=fir[i];j;j=nxt[j])&#123;</span><br><span class="line">            to=son[j];</span><br><span class="line">            if(to!=n) a[i-1][to-1]=-1.0/(double)deg[to];//制作高斯消元矩阵(增广矩阵)</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==1) a[i-1][n-1]=1.0;</span><br><span class="line">    &#125;</span><br><span class="line">    Gauss(n-1);//高斯消元</span><br><span class="line">    for(int i=1;i&lt;=n;i++) f[i]=a[i-1][n-1];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        if(u[i]!=n) K[i].g+=(f[u[i]]/(double)deg[u[i]]);//求g[i]</span><br><span class="line">        if(v[i]!=n) K[i].g+=(f[v[i]]/(double)deg[v[i]]);</span><br><span class="line">        K[i].id=m;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(K+1,K+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) ans+=i*K[i].g;//贪心</span><br><span class="line">    printf(&quot;%.3lf\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文部分内容引自<a href="https://baike.baidu.com/">百度百科</a>、<a href="https://www.cnblogs.com/bennettz/">bennettz</a>、<a href="https://orzsiyuan.com/">Siyuan</a>。</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10188. 「一本通 5.6 练习 1」玩具装箱</title>
      <link href="/2019/05/08/10188-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-6-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/"/>
      <url>/2019/05/08/10188-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-6-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a><a href="https://loj.ac/problem/10188">Link</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你可以将一段连续的玩具扔到同一个容器中，如果要将 $i$ 号玩具到 $j$ 号玩具 $(i\le j)$ 放到同一个容器中，则容器长度不小于 $x&#x3D;j-i+ \displaystyle\sum_{k&#x3D;i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(X-L)^2$，其中 $L$ 是一个常量。 求最小花费。 对于全部数据，$1\le N\le 5\times 10^4,1\le L,C_i\le 10^7$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，考虑$dp$。 设$f[i]$表示前$i$个玩具的最小花费，那么最终的答案就是$f[n]$。 那么很容易就可以得知：$f[i]&#x3D;min(f[j]+(i-j+\sum_{k&#x3D;i}^{j}C_k-L-1)^2)(1\leq j &lt;i,1\leq i\leq n)$ 考虑优化。</p><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>设$sum[i]$表示$C$数组的前缀和，那么转移方程可化为：$f[i]&#x3D;min(f[j]+(i-j-sum[j]+sum[i]-L-1)^2)(1&lt;&#x3D;i&lt;&#x3D;n,1&lt;&#x3D;j&lt;i)$ 时间复杂度：$O(N^3)–&gt;O(N^2)$ 预计得分：20pt</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>考虑斜率优化。 原转移方程可化为：$f[i]&#x3D;f[j]+(i+sum[i]-L-1-sum[j]-j)^2$ 设$A[i]&#x3D;sum[i]+i$,$B[i]&#x3D;sum[i]+i-L-1$ 则$f[i]&#x3D;f[j]+(A[i]-B[j])^2$， $f[i]&#x3D;f[j]+A[i]^2+B[j]^2-2\times A[i]\times B[j]$， $2\times A[i]\times B[j]+f[i]-A[i]^2&#x3D;f[j]+B[j]^2$。 设$x&#x3D;B[j],y&#x3D;f[j]+B[j]^2$， 那么$y&#x3D;x\times (2\times A[i])+(f[i]-A[i]^2),slope&#x3D;2\times A[i]$。 $f[i]&#x3D;y+A[i]^2-2\times A[i]\times x$。 那么就斜率优化鸭。 <img src="https://i.loli.net/2019/05/08/5cd2cbb889806.jpg"> <img src="https://i.loli.net/2019/05/08/5cd2cbb8b6c7d.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define sqrs(x) ((x)*(x))</span><br><span class="line">#define A(i) ((sum[i])+(i))</span><br><span class="line">#define B(i) ((sum[i])+(i)+(L)+(1))</span><br><span class="line">#define X(j) (B(j))</span><br><span class="line">#define Y(j) ((f[j])+sqrs(B(j)))</span><br><span class="line">#define slope(i,j) (double)((double)(Y(i)-Y(j))/(double)(X(i)-X(j)))</span><br><span class="line">#define Slope(i) (2*(A(i)))</span><br><span class="line">#define solve(i,j) (f[j]+sqrs(i-j-sum[j]+sum[i]-L-1))</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int ret=0,f=1;char ch=getchar();</span><br><span class="line">    while (ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;) &#123;if (ch==&#x27;-&#x27;) f=-f;ch=getchar();&#125;</span><br><span class="line">    while (ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int zx)&#123;</span><br><span class="line">    if(zx&lt;0) putchar(&#x27;-&#x27;),zx=-zx;</span><br><span class="line">    if(zx&lt;10) putchar(zx+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(zx/10);</span><br><span class="line">        putchar(zx%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,L,sum[50010],f[50010],q[50010],h,t;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();L=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+read();</span><br><span class="line">    memset(f,63,sizeof(f));</span><br><span class="line">    f[0]=0;h=t=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&lt;Slope(i)) h++;</span><br><span class="line">        f[i]=f[q[h]]+sqrs(A(i)-B(q[h]));</span><br><span class="line">        while(h&lt;t&amp;&amp;slope(q[t-1],q[t])&gt;slope(i,q[t-1])) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    write(f[n]);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B 酱的无向图 题解</title>
      <link href="/2019/04/21/b-%E9%85%B1%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/04/21/b-%E9%85%B1%E7%9A%84%E6%97%A0%E5%90%91%E5%9B%BE-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[mdx_warning]本题目有版权，禁止复制[&#x2F;mdx_warning]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>B 酱有$n$个节点的<strong>无</strong>向图，初始时图中没有边。他依次向图中加入了$m$条<strong>无</strong>向边，并询问你加入每条边后图中桥的个数是多少。被删除后能使图中连通块个数增加的边就称为桥。注意图中可能会出现重边及负环。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行为三个正整数$n,m, p， p $的含义将在输出格式中介绍。 接下来$ m $行，每行两个正整数$ u, v$，表示新加入的一条边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>为减少输出量，设$ ans_i $表示加入第$ i $条边后图中桥的个数，请输出$\left(\prod_{i&#x3D;1}^{m}\left(a n s_{i}+1\right)\right) \quad \bmod p$，其中$\Pi$表示连乘。</p><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><p>4 4 233 1 2 2 3 3 4 1 4</p><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><p>24</p><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><p>6 7 233 6 5 1 2 3 2 1 2 4 6 4 5 1 1</p><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><p>220</p><h2 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h2><p>对于100%的数据$1\leq n,m\leq 5 \times 10^5$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每一条边，如果加入后无环，那么将其塞入树中，并标出每个点的深度与父亲。 如果是一条非树边，那么就暴力求出他们的$LCA$（直接选择深度大的往上跳），并且把路径上所有点用并查集缩起来，每个时刻上树上还没有被缩起来的边就是桥。时间复杂度为$O(n \alpha(n))$ <img src="https://files-cdn.cnblogs.com/files/yzx1798106406/gif5%E6%96%B0%E6%96%87%E4%BB%B6.gif"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define MAXN 5000010</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,mod,ans=1,sum,las,num;</span><br><span class="line">int fa[MAXN],u[MAXN],v[MAXN],g[MAXN],f[MAXN],vis[MAXN],def[MAXN],cnt;</span><br><span class="line">int getfa(int x)&#123;</span><br><span class="line">    return x==f[x]?x:f[x]=getfa(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">int fir[MAXN],nxt[MAXN],son[MAXN],tot,w[MAXN];</span><br><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;//dfs求每一个点的深度与父亲</span><br><span class="line">    def[x]=def[fa[x]]+1;</span><br><span class="line">    f[x]=x;</span><br><span class="line">    for(int i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        int to=son[i];</span><br><span class="line">        if(to==x) continue </span><br><span class="line">        if(to==fa[x]) continue ;</span><br><span class="line">        fa[to]=x;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();mod=read();las=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    memset(fa,0,sizeof(fa));</span><br><span class="line">    cnt=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        u[i]=read();v[i]=read();</span><br><span class="line">        if(getfa(u[i])==getfa(v[i]))&#123;</span><br><span class="line">            vis[i]=0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            vis[i]=1;</span><br><span class="line">            add(u[i],v[i],0);cnt++;</span><br><span class="line">            add(v[i],u[i],0);cnt++;</span><br><span class="line">            f[f[u[i]]]=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(def[i]==0)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        if(vis[i]==1) sum++;//树边</span><br><span class="line">        else&#123;//非树边</span><br><span class="line">            for(int x=getfa(u[i]),y=getfa(v[i]);x!=y;--sum,x=f[x]=getfa(fa[x]))&#123;//求LCA，并且用并查集缩起来</span><br><span class="line">                if(def[x]&lt;def[y]) swap(x,y);//深度大的点向上跳</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans*=sum+1;ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10152. 「一本通 5.1 练习 3」矩阵取数游戏</title>
      <link href="/2019/04/03/10152-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/04/03/10152-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>帅帅经常和同学玩一个矩阵取数游戏： 对于给定的 $n\times m$ 的矩阵，矩阵中每个元素 $a_{ij}$ 均为非负整数。游戏规则如下： 1. 每次取数时必须从每行各取走一个元素，共 $n$ 个，$m$ 次取完所有元素。 2. 每次取走的各个元素只能是该元素所在行行首或行尾。 3. 每次取数都有一个的分值，为每行取数得分之和，每行取数得分$&#x3D;$被取走元素值$\times 2^i$，其中 $i$ 表示第 $i$ 次取数，从 $1$ 开始计数。 4. 游戏结束时，总得分为 $m$ 次取数得分之和。 帅帅想让你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$f[i][j]$表示当前$dp$行的区间为$i\sim j$的最大值。 很显然可以得出$dp$转移方程：$dp[i][j]&#x3D;max${$dp[i+1][j]+2^{m-(j-i)}\times v[i],dp[i][j-1]+2^{m-(j-i)}\times v[j]$} 然后一看这道题的数据范围需要用高精度 但本人很懒，就用__int128来替代了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int __int128</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXN 1010</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,m,a[MAXN][MAXN],f[MAXN][MAXN],pw[1010],ss,ans;</span><br><span class="line">int dp(int x,int y)&#123;</span><br><span class="line">    if(f[x][y]!=-1) return f[x][y];</span><br><span class="line">    if(y-x&gt;=1) f[x][y]=max(dp(x+1,y)+pw[m-(y-x)]*a[ss][x],dp(x,y-1)+pw[(m-(y-x))]*a[ss][y]);</span><br><span class="line">    else f[x][y]=a[ss][x]*pw[(m-(y-x))];</span><br><span class="line">    return f[x][y];</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    pw[0]=1;</span><br><span class="line">    for(int i=1;i&lt;1000;i++) pw[i]=pw[i-1]*2;</span><br><span class="line">    n=read();m=read();for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a[i][j]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ss=i;</span><br><span class="line">        memset(f,-1,sizeof(f));</span><br><span class="line">        ans+=dp(1,m);</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EK (Edmond-Karp) 算法 学习笔记</title>
      <link href="/2019/04/03/ek-edmond-karp-%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/04/03/ek-edmond-karp-%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是EK算法"><a href="#什么是EK算法" class="headerlink" title="什么是EK算法"></a>什么是EK算法</h2><p>EK (Edmond-Karp) 算法，说白了就是求最大流&#x2F;费用流之类的问题的算法。</p><h2 id="什么是最大流"><a href="#什么是最大流" class="headerlink" title="什么是最大流"></a>什么是最大流</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>带权的有向图$G&#x3D;(V,E)$，满足以下条件，则称为网络流图$(flow network)$：</p><ol><li>仅有一个入度为$0$的顶点$s$，称$s$为源点。</li><li>仅有一个出度为$0$的顶点$t$，称$t$为汇点。</li><li>每条边的权值都为非负数，称为该边的容量，记作$c(i,j)$。</li><li>通过容量网络$G$中每条弧$&lt; u,v&gt;$上的实际流量(简称流量),记为$f(u,v)$，称为弧的流量。</li></ol><p>简单来说就是水流从一个源点$s$通过很多路径，经过很多点，到达汇点$t$，问你最多能有多少水能够到达$t$点。 从$s$到$t$经过若干个点，若干条边，每一条边的水流都不能超过边权值（可以小于等于但不能大于） （由于是来学EK算法的，最大流什么的详细解读就不说了）</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P3376">Luogu P3376 【模板】网络最大流</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一个网络图，以及其源点和汇点，求出其网络最大流。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这是最大流的模板题，请往下阅读。</p><h2 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h2><h3 id="增广路定义"><a href="#增广路定义" class="headerlink" title="增广路定义"></a>增广路定义</h3><p>增广路是指从源点$s$到汇点$t$的一条路，流过这条路，可以使得当前的流可以增加。</p><h3 id="如何求增广路"><a href="#如何求增广路" class="headerlink" title="如何求增广路"></a>如何求增广路</h3><p>其实就是从源点$s$开始$bfs$即可，到达汇点$t$时，然后找到这个路径的权值的最小的边，然后把路径上的每一条边减去这个最小值即可。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><h4 id="寻找增广路"><a href="#寻找增广路" class="headerlink" title="寻找增广路"></a>寻找增广路</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt; q;//队列</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    while(!q.empty()) q.pop();//清空</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    vis[s]=1;//源点标记</span><br><span class="line">    q.push(s);//入队</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(int i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            int to=son[i];</span><br><span class="line">            if(vis[to]==0&amp;&amp;w[i]!=0)&#123;</span><br><span class="line">                pre[to].v=u;</span><br><span class="line">                pre[to].edge=i;//记路径</span><br><span class="line">                if(to==t) return 1;//到达t点</span><br><span class="line">                vis[to]=1;</span><br><span class="line">                q.push(to);//拓展</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n,m,s,t,vis[MAXN];</span><br><span class="line">int fir[MAXN],nxt[MAXN],w[MAXN],son[MAXN],tot=1,ans;//领接表</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,edge;//用来记路径</span><br><span class="line">&#125;pre[101010];</span><br></pre></td></tr></table></figure><h4 id="EK算法核心（你别急，我还没说完）"><a href="#EK算法核心（你别急，我还没说完）" class="headerlink" title="EK算法核心（你别急，我还没说完）"></a>EK算法核心（你别急，我还没说完）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int EK()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        int Min=2e9;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            Min=min(Min,w[pre[i].edge]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            w[pre[i].edge]-=Min;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=Min;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很明显是错误的。。。</p><h2 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h2><h3 id="为什么要建反边"><a href="#为什么要建反边" class="headerlink" title="为什么要建反边"></a>为什么要建反边</h3><p>为什么不建反边(逃： 非常显然，如果第一次流错了使其无法得到最大流怎么办？ 就比如这张图：</p><p><img src="https://s2.ax1x.com/2019/04/03/AgZwT0.png"></p><p>然而$bfs$沙雕的选了上面一条路怎么办。。。 所以这时候就需要反向边出场了 一开始用反向边建一个比边权为$0$的边。就像这样↓</p><p><img src="https://s2.ax1x.com/2019/04/03/AgZypF.png"></p><p>然后每次$bfs$以后给相应的反边<strong>加上</strong>流量，正边<strong>减去</strong>流量。</p><p><img src="https://s2.ax1x.com/2019/04/03/AgeMjJ.png"></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int EK()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        int Min=2e9;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            Min=min(Min,w[pre[i].edge]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            w[pre[i].edge]-=Min;//减去流量</span><br><span class="line">            w[pre[i].edge^1]+=Min;//加上流量</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=Min;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回归例题"><a href="#回归例题" class="headerlink" title="回归例题"></a>回归例题</h2><p>所以这道最大流的模板题代码：</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXN 200010</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,m,s,t,vis[MAXN];</span><br><span class="line">int fir[MAXN],nxt[MAXN],w[MAXN],son[MAXN],tot=1,ans;</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,edge;</span><br><span class="line">&#125;pre[101010];</span><br><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    vis[s]=1;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(int i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            int to=son[i];</span><br><span class="line">            if(vis[to]==0&amp;&amp;w[i]!=0)&#123;</span><br><span class="line">                pre[to].v=u;</span><br><span class="line">                pre[to].edge=i;</span><br><span class="line">                if(to==t) return 1;</span><br><span class="line">                vis[to]=1;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int EK()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        int Min=2e9;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            Min=min(Min,w[pre[i].edge]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            w[pre[i].edge]-=Min;</span><br><span class="line">            w[pre[i].edge^1]+=Min;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=Min;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();s=read();t=read();</span><br><span class="line">    for(int x,y,z,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        x=read();y=read();z=read();</span><br><span class="line">        add(x,y,z);</span><br><span class="line">        add(y,x,0);</span><br><span class="line">    &#125;</span><br><span class="line">    write(EK());putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EK算法拓展"><a href="#EK算法拓展" class="headerlink" title="EK算法拓展"></a>EK算法拓展</h2><h3 id="费用流问题"><a href="#费用流问题" class="headerlink" title="费用流问题"></a>费用流问题</h3><p><a href="https://www.luogu.org/problemnew/show/P3381">Luogu P3381 【模板】最小费用最大流</a></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long </span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXN 200010</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,m,s,t,vis[MAXN],dis[MAXN],anss;</span><br><span class="line">int fir[MAXN],nxt[MAXN],w[MAXN],son[MAXN],tot=1,ans,cost[MAXN];</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,edge;</span><br><span class="line">&#125;pre[101010];</span><br><span class="line">void add(int x,int y,int z,int c)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">    cost[tot]=c;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">bool spfa()&#123;</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(dis,63,sizeof(dis));</span><br><span class="line">    dis[s]=0;dis[t]=2e9;</span><br><span class="line">    vis[s]=1;q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();vis[u]=0;</span><br><span class="line">        for(int i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            int to=son[i];</span><br><span class="line">            if(w[i]&gt;0&amp;&amp;dis[to]&gt;dis[u]+cost[i])&#123;</span><br><span class="line">                dis[to]=dis[u]+cost[i];</span><br><span class="line">                pre[to].edge=i;</span><br><span class="line">                pre[to].v=u;</span><br><span class="line">                if(vis[to]==0)&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dis[t]&lt;2e9) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int EK()&#123;</span><br><span class="line">    ans=0;anss=0;</span><br><span class="line">    while(spfa())&#123;</span><br><span class="line">        int Min=2e9;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            Min=min(Min,w[pre[i].edge]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=t;i!=s;i=pre[i].v)&#123;</span><br><span class="line">            w[pre[i].edge]-=Min;</span><br><span class="line">            w[pre[i].edge^1]+=Min;</span><br><span class="line">        &#125;</span><br><span class="line">        anss+=Min;</span><br><span class="line">        ans+=Min*dis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();s=read();t=read();</span><br><span class="line">    for(int x,y,z,c,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        x=read();y=read();z=read();c=read();</span><br><span class="line">        add(x,y,z,c);</span><br><span class="line">        add(y,x,0,-c);</span><br><span class="line">    &#125;</span><br><span class="line">    EK();</span><br><span class="line">    write(anss);putchar(&#x27; &#x27;);</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EK </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2019模拟赛（五）03.31 解题报告</title>
      <link href="/2019/03/31/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%94%EF%BC%8903-31-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2019/03/31/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%94%EF%BC%8903-31-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><h3 id="NOIP2019模拟赛（五）03-31"><a href="#NOIP2019模拟赛（五）03-31" class="headerlink" title="NOIP2019模拟赛（五）03.31"></a><a href="http://211.140.156.254:2333/contest/160">NOIP2019模拟赛（五）03.31</a></h3><h2 id="A-「NOIP模拟赛」电阻"><a href="#A-「NOIP模拟赛」电阻" class="headerlink" title="A. 「NOIP模拟赛」电阻"></a>A. 「NOIP模拟赛」电阻</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>询问要得出一个电阻值为$\frac{a}{b}$的元件至少需要多少个电阻值为$1$的电阻。 元件由$3$种方式组成：</p><ol><li>一个电阻</li><li>一个元件与一个电阻串联</li><li>一个元件与一个电阻并联</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="并联电阻阻值计算"><a href="#并联电阻阻值计算" class="headerlink" title="并联电阻阻值计算"></a>并联电阻阻值计算</h4><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=551244cdb312c8fca0fefe9f9d6af920/503d269759ee3d6d7262b12649166d224e4adeb2.jpg"> 总电阻值为:$总R_总&#x3D;\frac{1}{\frac{1}{R_1]}+\frac{1}{R_2]}+…+\frac{1}{R_n]}}$ 特别的，两个电阻并联总值为：$R&#x3D;\frac{R_1R_2}{R_1+R_2}$</p><h4 id="串联电阻阻值计算"><a href="#串联电阻阻值计算" class="headerlink" title="串联电阻阻值计算"></a>串联电阻阻值计算</h4><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D20%2C0%2C860%2C568%3Bc0%3Dbaike92%2C5%2C5%2C92%2C30/sign=7f3d2f3594510fb36c562dd7e401f8b9/aa64034f78f0f73636332d8d0055b319eac41368.jpg"> （不要问我为什么我把电阻搞成了灯泡，凑合着看吧） 总电阻值为：$总R_总&#x3D;R_1+R_2+…+R_n$</p><h4 id="回归到这道题目"><a href="#回归到这道题目" class="headerlink" title="回归到这道题目"></a>回归到这道题目</h4><p>考虑一组较为简单的样例，$R&#x3D;\frac{11}{7}\Omega$ 由于$\frac{11}{7}&gt;1$，所以这肯定是两个<strong>元件</strong>串联而成的，其中一个<strong>元件</strong>的阻值为$1$，另外一个<strong>元件</strong>的阻值为$\frac{4}{7}$。 其中的一个<strong>元件</strong>阻值为$1$，思考：那么如果是更大的数呢？其实也差不多，就是若干个电阻值为$1$的电阻<strong>串联</strong>起来的，因为分成的这部分的电阻值其实为<strong>整数</strong>。 另外的一个<strong>元件</strong>阻值为$\frac{4}{7}$，因为$\frac{4}{7}&lt;1$，所以它是由两个<strong>元件</strong>并联而成的，我们可以对它取倒数（根据并联公式），得到$\frac{7}{4}&#x3D;1+\frac{3}{4}$，继续拆分$\frac{3}{4}$，可得$\frac{3}{4}&lt;1$，那么再倒数，得到$\frac{4}{3}&#x3D;1+\frac{1}{3}$，然后继续拆分$\frac{1}{3}$，可得$\frac{1}{3}&lt;1$，再倒数可得$3$，因为这已经不是分数，而是整数了，那么就不需要继续拆分了。 然后会很惊奇的发现，这个过程很像$gcd$。($gcd$:我躺着也中枪) 发现：并联其实就是取倒数。。。 那么就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int a,b,ans=0;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  freopen(&quot;A.in&quot;,&quot;r&quot;,stdin);freopen(&quot;A.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    a=read();b=read();</span><br><span class="line">    while(a!=0&amp;&amp;b!=0)&#123;</span><br><span class="line">        if(a&lt;b) swap(a,b);</span><br><span class="line">        ans+=a/b;</span><br><span class="line">        a%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//并联:1/(1/R[1]+1/R[2]+...+1/R[n])</span><br><span class="line">//串联:R[1]+R[2]+...+R[n]</span><br><span class="line">//并联2:(R[1]*R[2])/(R[1]+R[2])</span><br></pre></td></tr></table></figure><h2 id="B-「NOIP模拟赛」找零"><a href="#B-「NOIP模拟赛」找零" class="headerlink" title="B. 「NOIP模拟赛」找零"></a>B. 「NOIP模拟赛」找零</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>由$n$种硬币，每种面值的硬币有无数个。 希望用最少的硬币组合出$1\sim x$的任意值。 问最少需要多少硬币？</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>考虑已经能组合出$1\sim x$的数值 那么下一个硬币取$x$以内最大的数$k$ 使能组合出$1\sim x+k$ 那么就用$upper\text{_}bound$就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,a[1000010],x,now,ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  freopen(&quot;%name%.in&quot;,&quot;r&quot;,stdin);freopen(&quot;%name%.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    x=read();n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    if(a[1]!=1)&#123;</span><br><span class="line">        puts(&quot;-1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(now&lt;x)&#123;</span><br><span class="line">        int tmp=upper_bound(a+1,a+n+1,now+1)-a-1;</span><br><span class="line">        ans++;</span><br><span class="line">        now+=a[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-「NOIP模拟赛」2048"><a href="#C-「NOIP模拟赛」2048" class="headerlink" title="C. 「NOIP模拟赛」2048"></a>C. 「NOIP模拟赛」2048</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为$n$的数列，在这个数列中选取一个子序列使得这个子序列中的数能合出$2048$ 对于合并操作，可以选择这个序列中的任意两个数进行合并，当然这两个数必须是相同的(即$2$个$x$合并后成为一个$2x$) 对于每个序列，只要进行若干次合并操作后，这个序列中至少有一个$2048$(可以有其他数剩余)，就称这个序列是合法的 我们可以认为只要选取的数在原数列中的位置不同，这些序列就是不同的 对于给定的数列，小朋友们需要算出有多少子序列是合法的，并把这个数 对$998244353$取模</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>因为合并时两个数必须是相同的，且合并出$2048&#x3D;2^{11}$ 那么可想而知，合并的几个数必须是$2$的幂。 所以就把所有$2$的幂弄在一起，搞个$dp$求一下有多少种可能之和不小于$2048$。 然后其他不是$2$的幂的数字可以剩余，所以可有可无，那么就统计一下求一下$2^{count}$（因为有无共两种情况，乘法原理） 最后把两部分的$ans$乘起来就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define mod 998244353</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,a[100010],f[2050],ans=0,Pow[2050],MaxSum;</span><br><span class="line">int fpow(int a,int b)&#123;</span><br><span class="line">    if(b==0) return 1ll;</span><br><span class="line">    if(b==1) return a;</span><br><span class="line">    int res=fpow(a,b/(2*1ll));</span><br><span class="line">    if(b&amp;(1ll)) return res*res%mod*a%mod;</span><br><span class="line">    else return res*res%mod; </span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  freopen(&quot;C.in&quot;,&quot;r&quot;,stdin);freopen(&quot;C.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line"></span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    memset(f,0,sizeof(f));</span><br><span class="line">    Pow[1]=1;</span><br><span class="line">    Pow[2]=1;</span><br><span class="line">    Pow[4]=1;</span><br><span class="line">    Pow[8]=1;</span><br><span class="line">    Pow[16]=1;</span><br><span class="line">    Pow[32]=1;</span><br><span class="line">    Pow[64]=1;</span><br><span class="line">    Pow[128]=1;</span><br><span class="line">    Pow[256]=1;</span><br><span class="line">    Pow[512]=1;</span><br><span class="line">    Pow[1024]=1;</span><br><span class="line">    Pow[2048]=1;</span><br><span class="line">    f[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(Pow[a[i]]==1)&#123;</span><br><span class="line">            for(int j=MaxSum;j&gt;=0;j--) f[min(j+a[i],1ll*2048)]+=f[j],f[min(j+a[i],1ll*2048)]%=mod;</span><br><span class="line">//          cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">            MaxSum=min(1ll*2048,MaxSum+a[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write((fpow(2,ans)*f[2048])%mod);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> gcd </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Gym 101002 H. Jewel Thief 题解</title>
      <link href="/2019/03/24/codeforces-gym-101002-h-jewel-thief-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/03/24/codeforces-gym-101002-h-jewel-thief-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>类似于一个背包，空间为$M$，有$N$个物品，第$i$个物品体积为$w_i$，价值为$c_i$，求价值之和的最大值。 其中，$1 \leq n \leq 100000$,$1\leq m \leq 300000$,$1\leq w_i \leq 3$,$1\leq c_i \leq {10}^9$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先注意到$n,m$非常大，所以普通的背包是肯定不行的，那么考虑从小数据（每个物品的体积）入手。 发现：体积只有$1,2,3$三种可能，那么就分类讨论就好了。 首先，把所有物品按照体积分为$3$类。 然后每一类的物品按照价值排序（从大到小）（因为同种体积，价值越大越好）。 设$f[i]$表示空间为$i$的<strong>目前</strong>价值之和的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,m,f[300010],ans=0;</span><br><span class="line">vector&lt;int&gt; g[5];</span><br><span class="line">int dp_g[5][300010];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int w,c;</span><br><span class="line">&#125;a[300010];</span><br><span class="line">bool cmp(node qx,node qy)&#123;</span><br><span class="line">    return (double)((double)qx.c/(double)qx.w)&gt;(double)((double)qy.c/(double)qy.w);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">//  freopen(&quot;B.in&quot;,&quot;r&quot;,stdin);freopen(&quot;B.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i].w=read();a[i].c=read();</span><br><span class="line">        g[a[i].w].push_back(a[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=3;i++) sort(g[i].begin(),g[i].end());</span><br><span class="line">    for(int i=1;i&lt;=3;i++) dp_g[i][0]=g[i].size();</span><br><span class="line">    for(int i=0;i&lt;=m;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=3;j++)&#123;</span><br><span class="line">            if(dp_g[j][i]!=0)&#123;</span><br><span class="line">                if(f[i]+g[j][dp_g[j][i]-1]==f[i+j])&#123;</span><br><span class="line">                    if(dp_g[1][i]&lt;=dp_g[1][i+j])&#123;</span><br><span class="line">                        dp_g[1][i+j]=dp_g[1][i];</span><br><span class="line">                        dp_g[2][i+j]=dp_g[2][i];</span><br><span class="line">                        dp_g[3][i+j]=dp_g[3][i];</span><br><span class="line">                        dp_g[j][i+j]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(dp_g[1][i]-1==dp_g[1][i+j]&amp;&amp;dp_g[2][i]&lt;dp_g[2][i+j])&#123;</span><br><span class="line">                        dp_g[1][i+j]=dp_g[1][i];</span><br><span class="line">                        dp_g[2][i+j]=dp_g[2][i];</span><br><span class="line">                        dp_g[3][i+j]=dp_g[3][i];</span><br><span class="line">                        dp_g[j][i+j]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(f[i]+g[j][dp_g[j][i]-1]&gt;f[i+j])&#123;</span><br><span class="line">                    f[i+j]=f[i]+g[j][dp_g[j][i]-1];</span><br><span class="line">                    dp_g[1][i+j]=dp_g[1][i];</span><br><span class="line">                    dp_g[2][i+j]=dp_g[2][i];</span><br><span class="line">                    dp_g[3][i+j]=dp_g[3][i];</span><br><span class="line">                    dp_g[j][i+j]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=max(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10238. 「一本通 6.6 练习 9」网格</title>
      <link href="/2019/03/20/10238-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-6-%E7%BB%83%E4%B9%A0-9%E3%80%8D%E7%BD%91%E6%A0%BC/"/>
      <url>/2019/03/20/10238-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-6-%E7%BB%83%E4%B9%A0-9%E3%80%8D%E7%BD%91%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>某城市的街道呈网格状，左下角坐标为 $A(0, 0)$，右上角坐标为 $B(n, m)$，其中 $n \ge m$。现在从 $A(0, 0)$ 点出发，只能沿着街道向正右方或者正上方行走，且不能经过图示中直线左上方的点，即任何途径的点 $(x, y)$ 都要满足 $x\ge y$，请问在这些前提下，到达 $B(n, m)$ 有多少种走法。 <img src="https://loj-img.upyun.menci.memset0.cn/2019/02/24/5c72456426153.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很容易就可以想到答案是$C(n+m,m)-C(n+m,m-1)$ 当然，你打C++高精也可以。。。 python更省力啊。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n,m=map(int,input().split())//读入一行内两个整数</span><br><span class="line">a=[1]//定义list</span><br><span class="line">for i in range(1,m+n+1,1): a.append(int(a[i-1]*int(i)))//预处理阶乘</span><br><span class="line">print(a[n+m]//(a[n]*a[m])-a[n+m]//(a[n+1]*a[m-1]))//求组合数</span><br><span class="line"># (C(m+n,m)-C(m+n,m-1))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOIP模拟赛」欧拉口算 题解</title>
      <link href="/2019/03/17/%E3%80%8Cnoip%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E6%AC%A7%E6%8B%89%E5%8F%A3%E7%AE%97-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/03/17/%E3%80%8Cnoip%E6%A8%A1%E6%8B%9F%E8%B5%9B%E3%80%8D%E6%AC%A7%E6%8B%89%E5%8F%A3%E7%AE%97-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>令 $C(n)$ 表示 把 $n$ 拆分成 $a\times b&#x3D;n(a\leq b)$ 且 $a,b$ 的因子个数相同的方案数 给定一个整数$n$，$(1 \leq n \leq 100)$。 求出$C(n!)$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先把$n!$拆成若干个质数的乘积。 即：$n!&#x3D;{p_1}^{c_1} \times {p_2}^{c_2} \times \dots \times {p_{tot}}^{c_{tot}}$。 然后设$dp[i][j]$表示在$n!&#x3D;a\times b$中$a$的<strong>目前</strong>约数个数为$i$,$b$的<strong>目前</strong>约数个数为$j$的方案数。 很显然，$dp[i\times (k+1)][j\times (c_p-k+1)]+&#x3D;dp[i][j](0\leq k \leq c_p,1\leq p\leq tot)$。 答案就是$\sum{}{}dp[i][i]$。 当然，这样肯定会TLE。所以运用一下$\text{meet in the middle}$算法的思想。 分别求出$dp1,dp2$，分别表示2、3、5、7这四个素数下的方案与11、13…97素数下的方案。 这样的答案就是$\sum{}{}dp1[i][j]*dp2[i1][j1]$且满足$i&#x2F;i1&#x3D;j1&#x2F;j$。 但是$dp$数组下标太大了，不会$hash$，所以就是用$map$了。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,tot,mi,ans=0,sum=1,Ans[5010],ttt;</span><br><span class="line">int f[5010],top,g[5010],Gu[5010];</span><br><span class="line">int Get(int x)&#123;</span><br><span class="line">//  cout&lt;&lt;&quot;Get &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    for(int i=2;i&lt;=x;i++)&#123;</span><br><span class="line">        if(x%i==0)&#123;</span><br><span class="line">            while(x%i==0) x/=i,f[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">//      cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        if(x==1) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;pair&lt;int,int&gt;,int&gt; dp1,dp2;//lef,rig,dp_val</span><br><span class="line">pair&lt;int,int&gt; mp(int x,int y)&#123;</span><br><span class="line">    pair&lt;int,int&gt; pp;pp.first=x;pp.second=y;return pp;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">map&lt;pair&lt;int,int&gt;,int&gt; getmap(int l,int r)&#123;</span><br><span class="line">    map&lt;pair&lt;int,int&gt;,int&gt; m1,m2;</span><br><span class="line">    m1.clear();m2.clear();</span><br><span class="line">    m1[mp(1,1)]=1;</span><br><span class="line">    for(int i=r;i&gt;=l;i--)&#123;</span><br><span class="line">        if(f[i]!=0)&#123;</span><br><span class="line">            m2.clear();</span><br><span class="line">            for(map&lt;pair&lt;int,int&gt;,int&gt;::iterator j=m1.begin();j!=m1.end();j++)&#123;</span><br><span class="line">                for(int k=0;k&lt;=f[i];k++)&#123;</span><br><span class="line">                    int x=(*j).first.first*(k+1),y=(*j).first.second*(f[i]-k+1);</span><br><span class="line">                    int g=gcd(x,y);x/=g;y/=g;</span><br><span class="line">                    m2[mp(x,y)]+=(*j).second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m1.swap(m2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return m1;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    if(n==1)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=2;i&lt;=n;i++) Get(i);</span><br><span class="line">    dp1=getmap(7,97);</span><br><span class="line">    dp2=getmap(0,6);</span><br><span class="line">    for(map&lt;pair&lt;int,int&gt;,int&gt;::iterator i=dp1.begin();i!=dp1.end();i++)&#123;//x1/x2=y2/y1</span><br><span class="line">        if(dp2.count((*i).first)==1) ans+=dp2[(*i).first]*dp1[(*i).first];</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans/2);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10166. 「一本通 5.3 练习 1」数字游戏</title>
      <link href="/2019/03/13/10166-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-3-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/03/13/10166-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-3-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定多组数据，每组数据给定三个数：$a,b,n$表示求在区间$[a,b]$内各位数之和模$n&#x3D;0$的数的个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道数位$DP$的模板题。 设$f[i][S]$表示处理到第$i$位，$S$为和。 $f[i][S]&#x3D;f[i-1][(S+i)%N](0&lt;&#x3D;k&lt;&#x3D;Dim[i] or 9)$ 其中$k$的取值范围根据上一位的状态来定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int a,b,N,Dim[25],f[555][110];</span><br><span class="line">int dfs(int x,int sum,int bj)&#123;//分别表示第几位，和为多少，上一位是否已经大于</span><br><span class="line">    if(x==0)&#123;</span><br><span class="line">        if(sum%N==0) return 1;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(bj==0&amp;&amp;f[x][sum]!=-1) return f[x][sum];//记忆化优化</span><br><span class="line">    int res=0,ret=0;</span><br><span class="line">    if(bj==1) res=Dim[x];</span><br><span class="line">    else res=9;//k的范围</span><br><span class="line">    for(int i=0;i&lt;=res;i++)</span><br><span class="line">        ret+=dfs(x-1,(sum+i)%N,bj&amp;&amp;i==res);//DP转移</span><br><span class="line">    if(bj==1) return ret;</span><br><span class="line">    else return f[x][sum]=ret;</span><br><span class="line">&#125;</span><br><span class="line">int Get(int x)&#123;</span><br><span class="line">    Dim[0]=0;</span><br><span class="line">    while(x)&#123;</span><br><span class="line">        Dim[++Dim[0]]=x%10;</span><br><span class="line">        x/=10;</span><br><span class="line">    &#125;//把该数字拆开</span><br><span class="line">    return dfs(Dim[0],0,1);//数位dp记忆化</span><br><span class="line">&#125;</span><br><span class="line">void reset()&#123;</span><br><span class="line">    for(int i=0;i&lt;=200;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=110;j++) f[i][j]=-1;//因为每一次的询问的n不同，所以清空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;a)&#123;</span><br><span class="line">        reset();</span><br><span class="line">        b=read();N=read();</span><br><span class="line">        write(Get(b)-Get(a-1));putchar(&#x27;\n&#x27;);//数位dp的基本框架</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2019模拟赛（二）03.10</title>
      <link href="/2019/03/13/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%8903-10/"/>
      <url>/2019/03/13/noip2019%E6%A8%A1%E6%8B%9F%E8%B5%9B%EF%BC%88%E4%BA%8C%EF%BC%8903-10/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定两个数$a$,$b$求出$b$个$a$相乘的结果。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>保证$a \leq 99.9999 ,b \leq 25$且$a$的有效数字不超过$6$位。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="对于20-的数据"><a href="#对于20-的数据" class="headerlink" title="对于20%的数据"></a>对于20%的数据</h3><p>你开$long\quad double$就好了呀。</p><h3 id="对于100-的数据"><a href="#对于100-的数据" class="headerlink" title="对于100%的数据"></a>对于100%的数据</h3><p>你写高精度就好了呀。 说得很轻巧，但是打比赛的时候花了30分钟。。。 差不多分两个步骤： 1. 把$a$的小数转化为整数，并且求出$a^b$ 2. 然后再点一个小数点就好了 坑：0.52要输出成.52。 其他没啥了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">char A[50010];int b,len,Dot=-1;</span><br><span class="line">int a[5000010];</span><br><span class="line">int t[5000010];</span><br><span class="line">int c[5000010],Len;</span><br><span class="line">int top=0;</span><br><span class="line">void Mul()&#123;//高精度乘法</span><br><span class="line">    int lena=top,lent=Len;</span><br><span class="line">    for(int i=0;i&lt;lent/2;i++) swap(t[i],t[lent-i-1]);</span><br><span class="line">    int u=0;memset(c,0,sizeof(c));</span><br><span class="line">    for(int i=0;i&lt;lena;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;lent;j++)&#123;</span><br><span class="line">            c[i+j]+=a[i]*t[j]+u;</span><br><span class="line">            u=c[i+j]/10;</span><br><span class="line">            c[i+j]%=10;</span><br><span class="line">        &#125;</span><br><span class="line">        c[i+lent]=u;u=0;</span><br><span class="line">    &#125;</span><br><span class="line">    Len=lena+lent;</span><br><span class="line">    while(c[Len]==0) Len--;++Len;</span><br><span class="line">    memset(t,0,sizeof(t));</span><br><span class="line">    for(int i=0;i&lt;Len;i++) t[i]=c[i];</span><br><span class="line">    for(int i=0;i&lt;Len/2;i++) swap(t[i],t[Len-i-1]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;A;b=read();len=strlen(A);</span><br><span class="line">    for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">        if(A[i]==&#x27;.&#x27;)&#123;</span><br><span class="line">            Dot=i;//寻找小数点</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        t[top]=a[top]=A[i]-&#x27;0&#x27;;</span><br><span class="line">        ++top;</span><br><span class="line">    &#125;</span><br><span class="line">    if(Dot!=-1)</span><br><span class="line">    Dot=len-Dot-1;else Dot=0;//计算出小数点离个位多少位</span><br><span class="line">    for(int i=0;i&lt;top/2;i++) swap(a[i],a[top-i-1]);</span><br><span class="line">    Len=top;</span><br><span class="line">    for(int i=1;i&lt;b;i++)&#123;</span><br><span class="line">        Mul();</span><br><span class="line">    &#125;</span><br><span class="line">    Dot=Dot*b;//计算出小数点应该点在哪里</span><br><span class="line">    if(Dot&gt;=Len)&#123;//需要输出成.000xxx的形式</span><br><span class="line">        cout&lt;&lt;&quot;.&quot;;</span><br><span class="line">        for(int i=Len;i&lt;Dot;i++) cout&lt;&lt;&#x27;0&#x27;;</span><br><span class="line">        for(int i=0;i&lt;Len;i++) cout&lt;&lt;t[i];cout&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(int i=0;i&lt;Len;i++)&#123;</span><br><span class="line">            if(i==Len-Dot)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;.&quot;;//小数点</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有两个人很无聊地在玩猜数游戏。某个人想出来一个$n$个正整数的集合，然后选择一个数，让另外一个人猜他选的数的最小质因子。 问：在最优的方案中，最坏情况下需要询问几次，以及最小的询问期望次数？ 注：询问期望次数是所有数需要的询问次数的平均值，最坏情况的询问次数为所有数的询问次数的最大值。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>很显然这道题和小学奥数题很像。就比如说问有$1$~$n$的数，怎样询问能最少？ 显然是$log2$次。 就像这样：↓↓↓ <img src="https://s2.ax1x.com/2019/03/13/AkJKtP.png"> 那么对于第二个询问呢？和Luogu的合并果子很像。 <a href="https://www.luogu.org/problemnew/show/P1090">Luogu 合并果子</a> 其实就是利用哈夫曼树的原理，每次寻找最小的两个像上面一样$log2$地合并起来就好了。 可以使用$priority$_$queue$的小根堆。 注意：这道题会卡时，所以需要预处理出素数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,a[100010],m=0,t[100010],p[100010];</span><br><span class="line">int vis[100010],tot;</span><br><span class="line">priority_queue&lt;int ,vector&lt;int&gt;, greater&lt;int&gt; &gt; Hf;</span><br><span class="line">int GetLog(int x)&#123;</span><br><span class="line">    int pp=1;</span><br><span class="line">    while(x!=1)&#123;</span><br><span class="line">        pp++;x/=2;</span><br><span class="line">    &#125;</span><br><span class="line">    return pp;</span><br><span class="line">&#125;</span><br><span class="line">void GetPrime()&#123;//预处理素数</span><br><span class="line">    for(int i=2;i&lt;=100000;i++)&#123;</span><br><span class="line">        if(vis[i]==0)&#123;</span><br><span class="line">            p[++tot]=i;</span><br><span class="line">            for(int j=i;j&lt;=100000;j+=i) vis[j]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    GetPrime();</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int fst=sqrt(a[i])+1;</span><br><span class="line">        for(int j=1;j&lt;=tot&amp;&amp;p[j]&lt;=fst;j++)&#123;</span><br><span class="line">            if(a[i]%p[j]==0)&#123;</span><br><span class="line">                a[i]=p[j];//找到该数的最小质因子</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(a[i]!=a[i-1]) m++;//去重</span><br><span class="line">        t[m]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans;</span><br><span class="line">    if(m&lt;=2) puts(&quot;0&quot;);</span><br><span class="line">    else &#123;</span><br><span class="line">        ans=log2((m-1)&lt;&lt;1);</span><br><span class="line">        write(ans),putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) Hf.push(t[i]);</span><br><span class="line">    ans=0;</span><br><span class="line">    for(int i=1;i&lt;m;i++)&#123;</span><br><span class="line">        int x=Hf.top();Hf.pop();</span><br><span class="line">        int y=Hf.top();Hf.pop();</span><br><span class="line">        ans+=x+y;//哈夫曼树思想</span><br><span class="line">        Hf.push(x+y);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%.5lf\n&quot;,(double)ans/(double)n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p><a href="https://www.luogu.org/problemnew/show/P3616">这和Luogu某题很像</a></p><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>有$n$块石头，有$m$个询问。首先给出这$n$块石头的高度。然后对于每一次的询问有两种： 1. 读入一个整数$x$，询问大于或等于的连续的石头的部分的个数。 2. 读入两个整数$x,y$，表示将第$x$块石头的高度修改为$y$。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>5 4 8 6 3 5 4 1 5 2 4 1 1 5 1 3</p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>2 1 2</p><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>第一次询问时，洪水高度为$5$ ，露出水面的岩石的编号为${1,2,4}$连续的部分为${1,2}$和${4}$，答案是$2$ 第二次询问时，洪水高度为$5$，露出水面的岩石的编号为${1,2}$连续的部分为${1,2}$，答案是$1$ 第三次询问时，洪水高度为$3$，露出水面的岩石的编号为${1,2,3,5}$连续的部分为${1,2,3}$和${5}$，答案是$2$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h3 id="对于50-的数据"><a href="#对于50-的数据" class="headerlink" title="对于50%的数据"></a>对于50%的数据</h3><p>我们可以采用暴力<del>（废话）</del> 所以我们就对于每个查询询问暴力。 结果真的只有50分。。。<del>（出题人也太狠了吧）</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 100010*4</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[200010],c[200010];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    for(int op,x,y,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read();</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            x=read();int ans=0;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                if(a[j]&gt;=x) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                if(a[j]&gt;=x&amp;&amp;a[j-1]&gt;=x) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            x=read();y=read();</span><br><span class="line">            a[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于100-的数据-1"><a href="#对于100-的数据-1" class="headerlink" title="对于100%的数据"></a>对于100%的数据</h3><p>通过观察，我们可以发现，对于每一个询问$Q$，其实就是寻找满足：$h[i-1]&lt;Q \leq h[i]$的个数。 那么我们就可以先暴力预处理出如果$h[i-1]&lt;h[i]$那么$(h[i-1]+1,h[i])$这个答案区间就可加$1$。而对于每一个询问，只需要输出答案区间内的$Ans[Q]$即可。对于每一个修改，影响到的只有$h[i-1]$与$h[i+1]$所以，再重新分别判断一次即可。 注意：每一次的修改需要先清空上一次对于该点的修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 2000010</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int c[MAXN],h[MAXN];</span><br><span class="line">int n,m,N;</span><br><span class="line">int tree[4*MAXN],add[4*MAXN],num[MAXN],Max;</span><br><span class="line">inline void build(int l,int r,int root)&#123;//线段树模板走起</span><br><span class="line">    if (l==r)&#123;tree[root]=num[l];return;&#125;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    build(l,mid,root*2);</span><br><span class="line">    build(mid+1,r,root*2+1);</span><br><span class="line">    tree[root]=tree[root*2]+tree[root*2+1];</span><br><span class="line">&#125;</span><br><span class="line">inline void updata(int l,int r,int root,int x,int ans)&#123;</span><br><span class="line">    if(r&lt;xl&gt;x) return;</span><br><span class="line">    if(l==r&amp;&amp;l==x)&#123;tree[root]+=ans;return;&#125;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    updata(l,mid,root*2,x,ans);</span><br><span class="line">    updata(mid+1,r,root*2+1,x,ans);</span><br><span class="line">    tree[root]=tree[root*2]+tree[root*2+1];</span><br><span class="line">&#125;</span><br><span class="line">inline void modify(int root,int maxl,int maxr,int l,int r,int v)&#123;</span><br><span class="line">    if (maxl&gt;=l&amp;&amp;maxr&lt;=r)&#123;add[root]+=v;return;&#125;</span><br><span class="line">    tree[root]+=(min(maxr,r)-max(maxl,l)+1)*v;</span><br><span class="line">    int mid=(maxl+maxr)/2;</span><br><span class="line">    if (l&lt;=mid) modify(root*2,maxl,mid,l,r,v);</span><br><span class="line">    if (mid&lt;r) modify(root*2+1,mid+1,maxr,l,r,v);</span><br><span class="line">&#125;</span><br><span class="line">inline int Search(int maxl,int maxr,int root,int l,int r)&#123;</span><br><span class="line">    if (maxl&gt;rmaxr&lt;l) return 0;</span><br><span class="line">    if (l&lt;=maxl&amp;&amp;maxr&lt;=r) return tree[root]+(maxr-maxl+1)*add[root];</span><br><span class="line">    int mid=(maxl+maxr)/2;</span><br><span class="line">    int res=(min(maxr,r)-max(maxl,l)+1)*add[root];</span><br><span class="line">    if (l&lt;=mid) res+=Search(maxl,mid,root*2,l,r);</span><br><span class="line">    if (mid&lt;r) res+=Search(mid+1,maxr,root*2+1,l,r);</span><br><span class="line">    return res;</span><br><span class="line">&#125;//线段树模板结束</span><br><span class="line">int X,top,x[MAXN],k[MAXN],J[MAXN],Las[MAXN];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,xx,id,h;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line">int f[MAXN],g[MAXN],tot,tot2,mx;</span><br><span class="line">bool cmp(node qx,node qy)&#123;</span><br><span class="line">    return qx.x&lt;qy.x;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i].x=read();</span><br><span class="line">        a[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n+1;i&lt;=m+n;i++)&#123;</span><br><span class="line">        J[i]=read();</span><br><span class="line">        if(J[i]==2) Las[i]=read();</span><br><span class="line">        a[i].x=read();</span><br><span class="line">        a[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+n+m+1,cmp);</span><br><span class="line">    f[a[1].id]=1;</span><br><span class="line">    for(int i=2;i&lt;=n+m;i++)&#123;</span><br><span class="line">        if(a[i].x&gt;a[i-1].x) f[a[i].id]=f[a[i-1].id]+1;</span><br><span class="line">        else f[a[i].id]=f[a[i-1].id];</span><br><span class="line">    &#125;</span><br><span class="line">    Max=f[a[n+m].id];</span><br><span class="line">    build(1,Max,1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        if(f[i-1]&lt;f[i]) modify(1,1,Max,f[i-1]+1,f[i],1);//预处理</span><br><span class="line">    for(int i=n+1;i&lt;=n+m;++i)&#123;</span><br><span class="line">        if(J[i]==2)&#123;</span><br><span class="line">            int j=Las[i];</span><br><span class="line">            if(f[j-1]&lt;f[j]) modify(1,1,Max,f[j-1]+1,f[j],-1);</span><br><span class="line">            if(j!=n&amp;&amp;f[j]&lt;f[j+1]) modify(1,1,Max,f[j]+1,f[j+1],-1);//清空上一次的修改操作</span><br><span class="line">            f[j]=f[i];//进行新的一次操作</span><br><span class="line">            if(f[j-1]&lt;f[j]) modify(1,1,Max,f[j-1]+1,f[j],1);</span><br><span class="line">            if(j!=n&amp;&amp;f[j]&lt;f[j+1]) modify(1,1,Max,f[j]+1,f[j+1],1);</span><br><span class="line">        &#125;else write(Search(1,Max,1,f[i],f[i])),putchar(&#x27;\n&#x27;);//输出该点的值（单点查询）</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> NOIP2019模拟赛 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 合并果子 </tag>
            
            <tag> 哈夫曼树 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10213. 「一本通 6.4 例 5」Strange Way to Express Integers</title>
      <link href="/2019/03/06/10213-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-4-%E4%BE%8B-5%E3%80%8Dstrange-way-to-express-integers/"/>
      <url>/2019/03/06/10213-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-4-%E4%BE%8B-5%E3%80%8Dstrange-way-to-express-integers/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $2n$ 个正整数 $a_1,a_2,\cdots ,a_n$ 和 $m_1,m_2,\cdots ,m_n$，求一个最小的正整数 $x$，满足 $\forall i\in[1,n],x\equiv a_i\ (\bmod m_i\ )$，或者给出无解。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实题意就是求出： $x\equiv a[1] \bmod m[1]$ $x\equiv a[2] \bmod m[2]$ $\dots$ $x\equiv a[n] \bmod m[n]$ 的最小非负整数解$x$。 考虑将以上方程两两合并。比如方程一与方程二合并过程： $x+k[1]\times m[1]&#x3D;a[1]$ $x+k[2]\times m[2]&#x3D;a[2]$ 两式相减可得： $k[1]\times m[1]-k[2]\times m[2]&#x3D;a[1]-a[2]$ 那么又得到一个形式为$ax+by&#x3D;c$的方程。 $a&#x3D;m[1],b&#x3D;m[2],c&#x3D;a[1]-a[2]$ 通过<a href="https://yzx233.xyz/archives/574">拓展欧几里得</a>可以求出该方程的一个解$(x0,y0)$。 并且可以求出它的最小非负整数解，其中$x&#x3D;((c\times x0)\bmod b)\bmod b$ 所以就可以将这两个方程合为一个方程： $x \equiv (a[1]\times a[i])\bmod (m[1]+a[1]\times x)$ 所以，合并到最后只剩下一个方程，形式为$x\equiv a \bmod b$，那么这个方程的最小非负整数解为$x&#x3D;b$。 所以最后只需要输出合并到最后的$m[n]$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long </span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    // ax+by=gcd(a,b) : (x,y)</span><br><span class="line">    int t=0;</span><br><span class="line">    if(b==0) d=a,x=1,y=0;</span><br><span class="line">    else&#123;</span><br><span class="line">        exgcd(b,a%b,d,x,y);</span><br><span class="line">        t=x;x=y;y=t-(a/b)*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,m[100010],a[100010],M=1,t[100010],ans;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; solvefunction(int a,int b,int c)&#123;</span><br><span class="line">    int g=gcd(a,b),a1=a/g,b1=b/g,c1=c/g,x1,y1,d;</span><br><span class="line">    exgcd(a1,b1,d,x1,y1);</span><br><span class="line">    return make_pair(x1,y1);</span><br><span class="line">&#125;</span><br><span class="line">namespace Function&#123;</span><br><span class="line">    void solve()&#123;</span><br><span class="line">        for(int i=2,x,y,d;i&lt;=n;i++)&#123;</span><br><span class="line">            int C=m[i]-m[1],B=a[i],A=a[1],t=gcd(A,B);</span><br><span class="line">            if(C%t!=0)&#123;</span><br><span class="line">                puts(&quot;-1&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            A/=t;B/=t;C/=t;</span><br><span class="line">            exgcd(A,B,d,x,y);</span><br><span class="line">            x=((C*x)%B+B)%B;</span><br><span class="line">            m[1]=m[1]+a[1]*x;</span><br><span class="line">            a[1]=a[1]*B;</span><br><span class="line">        &#125;</span><br><span class="line">        write(m[1]);putchar(&#x27;\n&#x27;);return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) a[i]=read(),m[i]=read();</span><br><span class="line">        Function::solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10181. 「一本通 5.5 练习 2」绿色通道</title>
      <link href="/2019/03/06/10181-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93/"/>
      <url>/2019/03/06/10181-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E7%BB%BF%E8%89%B2%E9%80%9A%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>高二数学《绿色通道》总共有 $n$ 道题目要抄，编号 $1\dots n$，抄第 $i$ 题要花 $a_i$ 分钟。小 Y 决定只用不超过 $t$ 分钟抄这个，因此必然有空着的题。每道题要么不写，要么抄完，不能写一半。下标连续的一些空题称为一个空题段，它的长度就是所包含的题目数。这样应付自然会引起马老师的愤怒，最长的空题段越长，马老师越生气。 现在，小 Y 想知道他在这 $t$ 分钟内写哪些题，才能够尽量减轻马老师的怒火。由于小 Y 很聪明，你只要告诉他最长的空题段至少有多长就可以了，不需输出方案。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很明显这道题可以使用二分来寻找最短的最长空题段。（有点绕口）</p><h3 id="90分做法"><a href="#90分做法" class="headerlink" title="90分做法"></a>90分做法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>然而发现这道题的数据： 对于所有数据，$0&lt;n \le 5\times 10^4,0&lt;a_i\le 3000,0&lt;t\le 10^8$ 所以直接二分+check(dp)肯定是不行的。 这样复杂度达到了$O(logN \times N^2)$ 但是这样能拿90分(逃: 在使用dp check时： 设$f[i]$表示前i道题目的最少时间。 那么：$f[i]&#x3D;min(f[i],f[j]+a[i])$且$max(0,i-t-1)\leq j \leq i-1$</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,t,a[50010],f[50010],l,r,ans;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    memset(f,63,sizeof(f));f[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=max(0,i-x-1);j&lt;=i-1;j++)&#123;</span><br><span class="line">            f[i]=min(f[i],f[j]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n-x;i&lt;=n;i++)</span><br><span class="line">        if(f[i]&lt;=t) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();t=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    l=1;r=n;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line">        if(check(mid)==1) ans=mid,r=mid-1;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>与90分做法差不多，只是把check的dp进行单调队列优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(h&lt;=t&amp;&amp;q[h]&lt;max(0,i-x-1)) h++;//如果j不在规定范围内</span><br><span class="line">f[i]=min(f[i],f[q[h]]+a[i]);//取得最小值</span><br><span class="line">while(h&lt;=t&amp;&amp;f[q[t]]&gt;f[i]) t--;//比较大小</span><br><span class="line">q[++t]=i;</span><br></pre></td></tr></table></figure><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,txx,a[50010],f[50010],l,r,ans,h,t,q[50010];</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">    memset(f,63,sizeof(f));f[0]=0;</span><br><span class="line">    memset(q,0,sizeof(q));h=t=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(h&lt;=t&amp;&amp;q[h]&lt;max(0,i-x-1)) h++;</span><br><span class="line">        f[i]=min(f[i],f[q[h]]+a[i]);</span><br><span class="line">        while(h&lt;=t&amp;&amp;f[q[t]]&gt;f[i]) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=n-x;i&lt;=n;i++)</span><br><span class="line">        if(f[i]&lt;=txx) return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();txx=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    l=1;r=n;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int mid=(l+r)&gt;&gt;1;</span><br><span class="line">        if(check(mid)==1) ans=mid,r=mid-1;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得算法与应用</title>
      <link href="/2019/03/03/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/03/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h1><p>即：$gcd(a,b)&#x3D;gcd(b,a$%$b)$<br>欧几里得算法在oi里非常常用，几乎每个数学题都有欧几里得算法——$gcd$。<br>说白了就是求最大公约数。一行代码搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return !b?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>定理1：设$a$和$n$不全为$0$，则存在整数$x,y$，满足$ax+by&#x3D;gcd(a,b)$。<br>证明：<br>当$b&#x3D;0$时，$gcd(a,b)&#x3D;a$。因为$1\times a + 0 \times 0 &#x3D;a$，所以，$ax+by&#x3D;gcd(a,b)$有一组解为$x&#x3D;1,y&#x3D;0$。<br>当$b \not &#x3D; 0 $时，$gcd(a,b)&#x3D;gcd(b,a$%$b)$。<br>设$x’,y’$满足$gcd(a,b)&#x3D;bx’+(a$%$b)y’&#x3D;gcd(b,a$%$b)$。<br>那么，$bx’+(a$%$b)y’&#x3D;gcd(a,b)$<br>即，$bx’+(a-(a&#x2F;b)\times b )y’&#x3D;gcd(a,b)$，其中$’&#x2F;‘$为整除。<br>所以，$bx’+ay’-(a&#x2F;b)\times b \times y’&#x3D;gcd(a,b)$<br>即，$ay’+b\times (x’-(a&#x2F;b)\times y’)&#x3D;gcd(a,b)$<br>那么可以继续递归拓展欧几里得：$x&#x3D;y’,y&#x3D;(x’-(a&#x2F;b)\times y’)$。<br>因为欧几里得算法的递归过程，可知定理1成立。<br>证毕。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)&#123;</span><br><span class="line">//求解ax+by=gcd(a,b)的一组解(x,y),d=gcd(a,b)。</span><br><span class="line">    if(!b) d=a,x=1,y=0;</span><br><span class="line">    else&#123;</span><br><span class="line">        Exgcd(b,a%b,d,x,y);</span><br><span class="line">        int tmp=x;x=y;y=tmp-(a/b)*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展欧几里得算法的应用"><a href="#拓展欧几里得算法的应用" class="headerlink" title="拓展欧几里得算法的应用"></a>拓展欧几里得算法的应用</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>求解不定方程$ax+by&#x3D;c$的所有整数解。  </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当$gcd(a,b)$整除$c$时该方程有解。<br>设$g&#x3D;gcd(a,b),a’&#x3D;a&#x2F;g,b’&#x3D;b&#x2F;g$。<br>我们可以用上文的拓展欧几里得算法来求出不定方程$a’x’+b’y’&#x3D;1$的整数解$x’,y’$。<br>那么<br>$$a’c’x’+b’c’y’&#x3D;c’$$<br>$$a’gc’x’+b’gc’y’&#x3D;c’g$$<br>即：<br>$$ac’x’+bc’y’&#x3D;c$$<br>所以$x_0&#x3D;c’x’,y_0&#x3D;c’y’$是方程的一组解。<br>因为不定方程$a’x+b’y&#x3D;c’→$同余方程$a’x \equiv c’(mod \quad b’)$。所以$x$为$mod$ $b’$的一个剩余类，所以该补丁方程的<strong>通解</strong>为:<br>$$x&#x3D;x_0+b’ \times t,y&#x3D;y_0 -a’ \times t,(t \in Z)$$<br>当$gcd(a,b)$不能整除$c$时，就没有上文求解过程，方程无解。</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123;</span><br><span class="line">    // ax+by=gcd(a,b) : (x,y)</span><br><span class="line">    ll t=0;</span><br><span class="line">    if(b==0) d=a,x=1,y=0;</span><br><span class="line">    else&#123;</span><br><span class="line">        Exgcd(b,a%b,d,x,y);</span><br><span class="line">        t=x;x=y;y=t-(a/b)*y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int a,b,c;</span><br><span class="line">int main()&#123;</span><br><span class="line">    a=read();b=read();c=read();</span><br><span class="line">    int g=__gcd(a,b),a1=a/g,b1=b/g,c1=c/g,x1,y1,d;</span><br><span class="line">    Exgcd(a1,b1,d,x1,y1);</span><br><span class="line">    cout&lt;&lt;x1*c1&lt;&lt;&quot; &quot;&lt;&lt;c1*y1&lt;&lt;endl;</span><br><span class="line">    for(int i=-10000;i&lt;=10000;i++)&#123;</span><br><span class="line">        int x=x1+b1*i,y=y1-a1*i;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu 2019三月月赛 P5239 回忆京都 题解</title>
      <link href="/2019/03/03/luogu-2019%E4%B8%89%E6%9C%88%E6%9C%88%E8%B5%9B-p5239-%E5%9B%9E%E5%BF%86%E4%BA%AC%E9%83%BD-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/03/03/luogu-2019%E4%B8%89%E6%9C%88%E6%9C%88%E8%B5%9B-p5239-%E5%9B%9E%E5%BF%86%E4%BA%AC%E9%83%BD-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目背景讲太多了吧。。。一句话题意： 有$Q$个询问，每个询问求出： $$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m C_j^i$$  </p><p>对于$60$%的数据，$q \leq 10, n\leq100,m\leq100$。  </p><p>对于$100$%的数据，$q \leq 1000,n\leq1000,m\leq1000$。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="对于60-的数据"><a href="#对于60-的数据" class="headerlink" title="对于60%的数据"></a>对于60%的数据</h3><p>直接暴力就好了。  </p><p>预计得分：60分。  </p><p>实际得分：70分。  </p><p>O(∩_∩)O数据好水  </p><p>直接用递归的方式记忆化求组合数。竟然可以拿70。  </p><p>代码：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mod 19260817</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[2010][2010];</span><br><span class="line">int C(int n,int m)&#123;//递归求组合数</span><br><span class="line">    if(a[n][m]!=0)&#123;</span><br><span class="line">        return a[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&lt;m)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n==mm==0)&#123;</span><br><span class="line">        return a[n][m]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m==1)&#123;</span><br><span class="line">        a[n][m]=n%mod;</span><br><span class="line">        return n%mod;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        a[n][m]=C(n-1,m-1)%mod+C(n-1,m)%mod;//C(n,m)=C(n-1,m)+C(n-1,m-1)</span><br><span class="line">        a[n][m]%=mod;</span><br><span class="line">        return a[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int q,n,m,ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    q=read();</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        n=read();m=read();ans=0;//ANS清零</span><br><span class="line">        for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                ans+=C(i,j);</span><br><span class="line">                ans%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(ans);putchar(&#x27;n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于100-的数据"><a href="#对于100-的数据" class="headerlink" title="对于100%的数据"></a>对于100%的数据</h3><p>这里就有两种解法了：</p><h4 id="1-利用前缀和"><a href="#1-利用前缀和" class="headerlink" title="1.利用前缀和"></a>1.利用前缀和</h4><p>因为有许多题解都详细讲了，比如chen_zhe的题解，所以这里就不提了。</p><h4 id="2-利用组合数的性质"><a href="#2-利用组合数的性质" class="headerlink" title="2.利用组合数的性质"></a>2.利用组合数的性质</h4><p>这里先摆一条组合数的性质：$C(0,n)+C(1,n)+C(2,n)+…+C(n,n)&#x3D;2^n$  </p><p>这怎么证明呢？  </p><p>根据二项式定理，可得：<br>$$(1+x)^n&#x3D;C(0,n)+C(1,n)\times x +C(2,n)\times x^2+ … +C(n,n) \times x^n $$  </p><p>令$x&#x3D;1$，可得：  </p><p>$$2^n&#x3D;C(0,n)+C(1,n)+C(2,n)+(3,n)+…+C(n,n)$$  </p><p>证毕。  </p><p>什么？你不会二项式定理？<a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/7134359?fr=aladdin">百度百科</a>  </p><p>好了，再回归题目：  </p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m C_j^i$$  </p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i-\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^m C_j^i$$  </p><p>于是求解这道题就变成了求解两个子问题：  </p><h5 id="1-求解-sum-i-x3D-1-m-sum-j-x3D-1-m-C-j-i"><a href="#1-求解-sum-i-x3D-1-m-sum-j-x3D-1-m-C-j-i" class="headerlink" title="1.求解$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i$"></a>1.求解$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i$</h5><p>根据上面的组合数的性质：$C(0,n)+C(1,n)+C(2,n)+…+C(n,n)&#x3D;2^n$  </p><p>我们可以得出：  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;1}^m [C(1,m)+C(2,m)+…+C(m,m)]$$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;1}^m [C(0,m)+C(1,m)+C(2,m)+…+C(m,m)-C(0,m)]$$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;1}^m [2^m-C(0,m)]$$  </p><p>那么$C(0,m)&#x3D;?$  </p><p>答案是1。  </p><p>所以<br>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;1}^m [2^m-1]$$  </p><p>然后再把最外层的化开：  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;[2^1-1]+[2^2-1]+…+[2^m-1]$$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;2^1+2^2+…+2^m-1 \times m$$  </p><p>根据：$2^0+2^1+2^2+…+2^n&#x3D;2^{n+1}-1$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;2^{m+1}-1-2^0-1 \times m$$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;2^{m+1}-2-1 \times m$$  </p><p>$$\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m C_j^i&#x3D;2^{m+1}-2-m$$  </p><h5 id="2-求解-sum-i-x3D-n-1-m-sum-j-x3D-1-m-C-j-i"><a href="#2-求解-sum-i-x3D-n-1-m-sum-j-x3D-1-m-C-j-i" class="headerlink" title="2.求解$\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^m C_j^i$"></a>2.求解$\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^m C_j^i$</h5><p>$$\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^i C_j^i+\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;i+1}^m C_j^i$$  </p><p>又因为题目：其中当$i&gt;j$的时候，钦定$C^i_j&#x3D;0$  </p><p>并且：$C(n,n)&#x3D;1$  </p><p>所以：<br>$$\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;1}^m C_j^i&#x3D;\sum_{i&#x3D;n+1}^m {(1+\sum_{j&#x3D;i+1}^m C_j^i)}$$  </p><p>于是对于每一个询问，只需要求出$\sum_{i&#x3D;n+1}^m \sum_{j&#x3D;i+1}^m C_j^i$即可。  </p><h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><p>好了，两个子问题都结束了。  </p><p>那么对于每个询问：  </p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m C_j^i&#x3D;2^{m+1}-2-m-\sum_{i&#x3D;n+1}^m {(1+ \sum_{j&#x3D;i+1}^m C_j^i)}$$</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mod 19260817</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;//读入优化</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;//输出优化</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[2010][2010],pw[1010];//分别记录组合数、2的次幂</span><br><span class="line">int C(int n,int m)&#123;//递归记忆化求组合数</span><br><span class="line">    if(a[n][m]!=0)&#123;</span><br><span class="line">        return a[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&lt;m)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n==mm==0)&#123;</span><br><span class="line">        return a[n][m]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m==1)&#123;</span><br><span class="line">        a[n][m]=n%mod;</span><br><span class="line">        return n%mod;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        a[n][m]=C(n-1,m-1)%mod+C(n-1,m)%mod;</span><br><span class="line">        a[n][m]%=mod;</span><br><span class="line">        return a[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int q,n,m,ans;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    q=read();pw[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=1005;i++)&#123;//预处理2^k</span><br><span class="line">        pw[i]=pw[i-1]*2;pw[i]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        n=read();m=read();</span><br><span class="line">        ans=pw[m+1];ans-=2;ans-=m;ans+=mod;ans%=mod;//子问题1</span><br><span class="line">        for(int j=n+1;j&lt;=m;j++)&#123;//子问题2</span><br><span class="line">            ans--;</span><br><span class="line">            for(int i=j+1;i&lt;=m;i++) ans-=C(i,j),ans+=mod,ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        write(ans);putchar(&#x27;n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10182. 「一本通 5.5 练习 3」理想的正方形</title>
      <link href="/2019/02/27/10182-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2019/02/27/10182-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E7%BB%83%E4%B9%A0-3%E3%80%8D%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个 $a\times b$ 的整数组成的矩阵，现请你从中找出一个 $n\times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$dp[i][j][k]$表示以$i,j$为左上角的正方形变成为$k$内的最大值，$dp2[i][j][k]$表示最小值。 可知，$dp[i][j][k]&#x3D;max(dp[i+1][j+1][k-1],dp[i][j+1][k-1],dp[i+1][j][k-1])$。当然，这样枚举复杂度为$O(a \times b \times n)$肯定会TLE。 考虑优化。 发现该式子很像RMQ。于是可得： $$dp[i][j][k]&#x3D;max(dp[i][j][k], dp[i+2^(k-1)][j+2^(k-1)][k-1],dp[i,j+2^(k-1)][k-1], dp[i+2^(k-1)][j][k-1])$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int a,b,n,g[1010][1010],ans=2e18,logn=20;</span><br><span class="line">int dp[1500][1500];</span><br><span class="line">int dp1[1500][1500];</span><br><span class="line">void st()&#123;</span><br><span class="line">    for(int k=0;k&lt;logn;k++)&#123;</span><br><span class="line">        for(int i=0;i+(1&lt;&lt;k)&lt;a;i++)&#123;</span><br><span class="line">            for(int j=0;j+(1&lt;&lt;k)&lt;b;j++)&#123;</span><br><span class="line">                dp[i][j]=max(dp[i][j],max(dp[i+(1&lt;&lt;k)][j+(1&lt;&lt;k)],max(dp[i+(1&lt;&lt;k)][j],dp[i][j+(1&lt;&lt;k)])));</span><br><span class="line">                dp1[i][j]=min(dp1[i][j],min(dp1[i+(1&lt;&lt;k)][j+(1&lt;&lt;k)],min(dp1[i+(1&lt;&lt;k)][j],dp1[i][j+(1&lt;&lt;k)])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    a=read();b=read();n=read();</span><br><span class="line">    for(register int i=0;i&lt;a;i++)&#123;</span><br><span class="line">        for(register int j=0;j&lt;b;j++) dp[i][j]=dp1[i][j]=g[i][j]=read();</span><br><span class="line">    &#125;</span><br><span class="line">    logn=log2(n);</span><br><span class="line">    st();</span><br><span class="line">    for(register int i=0;i&lt;=a-n;i++)&#123;</span><br><span class="line">        for(register int j=0;j&lt;=b-n;j++)&#123;</span><br><span class="line">            int Max=0,Min=0;</span><br><span class="line">            Max=max(dp[i][j],max(dp[i+n-(1&lt;&lt;logn)][j+n-(1&lt;&lt;logn)],max(dp[i+n-(1&lt;&lt;logn)][j], dp[i][j+n-(1&lt;&lt;logn)])));</span><br><span class="line">            Min=min(dp1[i][j],min(dp1[i+n-(1&lt;&lt;logn)][j+n-(1&lt;&lt;logn)],min(dp1[i+n-(1&lt;&lt;logn)][j], dp1[i][j+n-(1&lt;&lt;logn)])));</span><br><span class="line">            ans=min(ans,Max-Min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>理论上这道题用二维线段树、二维RMQ都是可以的。 结果我全炸了。。。</p><p><img src="https://s2.ax1x.com/2019/02/27/kTRUu6.png"></p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnackDown 2017 Online Elimination Round Prefix XOR</title>
      <link href="/2019/02/24/snackdown-2017-online-elimination-round-prefix-xor/"/>
      <url>/2019/02/24/snackdown-2017-online-elimination-round-prefix-xor/</url>
      
        <content type="html"><![CDATA[<h2 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.codechef.com/problems/PREFIXOR">题目传送门</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出$n$个数，定义上升为$a_i\leq a_i \quad xor \quad a_{i+1} \leq a_i \quad xor \quad a_{i+1} \quad xor \quad a_{i+2} \leq \dots \leq a_i \quad xor \quad a_{i+1} \quad xor \quad \dots \quad xor \quad a_{j}$，问每个区间的上升数对有多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$rig_i$表示以$i$为区间左端，使$(i,j)$满足上升的最大$j$。 设$sum_i$表示$xor$前缀和。 如果$a_r \quad xor \quad a_{r-1} \quad xor \quad \dots \quad xor \quad a_{i-1}&gt;<br>a_{r+1} \quad xor \quad a_{r} \quad xor \quad \dots \quad xor \quad a_{i-1} $则不满足条件，那么$rig_i\leq r$。 即： 如果$sum_r \quad xor \quad sum_{i-1}&gt; sum_{r+1} \quad xor \quad sum_{i-1} $则不满足条件，那么$rig_i\leq r$。 由于$xor$是位运算，所以考虑二进制下优化。 要满足条件，必须使$sum_r$与$sum_{r+1}$中至少有一位在二进制下不相同。 假设不相同的最高位是第$k$位，那么$sum_{i−1}$的第$k$位其实就有了限制，易得： (二进制下)</p><ol><li>$sum_r$的第$k$位为0，那么$sum_{i-1}$的第$k$位必须是1。</li><li>$sum_r$的第$k$位为1，那么$sum_{i-1}$的第$k$位必须是0。</li></ol><p>那么我们可以倒序枚举$i$,记录$S[j][0&#x2F;1]$表示当前第$j$位限制为$0&#x2F;1$时的位置，那样就可以快速求出$rig_i$了。 如果$[l,r]$不存在$rig_i&gt;r$，那么答案显然就是$rig_i-i+1(l \leq i \leq r $且$ rig_i \leq r)$，但如果存在$rig_i&gt;r$，由于不能越界，该部分的答案应该就是$r-i+1(l \leq i \leq r $且$ rig_i &gt; r)$。由于<strong>强制在线</strong>，用<strong>主席树</strong>就可以解决了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 600010 </span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,q,Qt;</span><br><span class="line">int a[MAXN],b[MAXN],rt[MAXN],xo[MAXN],rig[MAXN],S[31][500],Q,ans,ntt;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r,sum,cnt;</span><br><span class="line">&#125;tree[MAXN*20];</span><br><span class="line">void insert(int &amp;x,int y,int l,int r,int p)&#123;</span><br><span class="line">    x=++ntt;</span><br><span class="line">    tree[x]=tree[y];</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        tree[x].sum+=p;</span><br><span class="line">        tree[x].cnt++;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(p&lt;=mid) insert(tree[x].l,tree[y].l,l,mid,p);</span><br><span class="line">    else insert(tree[x].r,tree[y].r,mid+1,r,p);</span><br><span class="line">    tree[x].sum=tree[tree[x].l].sum+tree[tree[x].r].sum;</span><br><span class="line">    tree[x].cnt=tree[tree[x].l].cnt+tree[tree[x].r].cnt;</span><br><span class="line">&#125;</span><br><span class="line">int Sum(int x,int y,int l,int r,int L,int R)&#123;</span><br><span class="line">    if(L&gt;R) return 0;</span><br><span class="line">    if(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        return tree[x].sum-tree[y].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1,res=0;</span><br><span class="line">    if(L&lt;=mid) res+=Sum(tree[x].l,tree[y].l,l,mid,L,R);</span><br><span class="line">    if(R&gt;mid) res+=Sum(tree[x].r,tree[y].r,mid+1,r,L,R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int Cnt(int x,int y,int l,int r,int L,int R)&#123;</span><br><span class="line">    if(L&gt;R) return 0;</span><br><span class="line">    if(l&gt;r) return 0;</span><br><span class="line">    if(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        return tree[x].cnt-tree[y].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    int tmp=tree[tree[y].l].cnt-tree[tree[x].l].cnt;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1,res=0;</span><br><span class="line">    if(L&lt;=mid) res+=Cnt(tree[x].l,tree[y].l,l,mid,L,R);</span><br><span class="line">    if(R&gt;mid) res+=Cnt(tree[x].r,tree[y].r,mid+1,r,L,R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int Ge(int x)&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    return x*(x-1)/2;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();Qt=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) xo[i]=xo[i-1]^a[i];</span><br><span class="line">    for(int i=0;i&lt;=31;i++) S[i][0]=S[i][1]=n+1;</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        rig[i]=n+1;</span><br><span class="line">        for(int j=0;j&lt;=31;j++) rig[i]=min(rig[i],S[j][(xo[i-1]&gt;&gt;j)&amp;1]);</span><br><span class="line">        rig[i]--;</span><br><span class="line">        for(int k=31;k&gt;=0;k--)</span><br><span class="line">            if(((xo[i-1]&gt;&gt;k)&amp;1)^((xo[i]&gt;&gt;k)&amp;1))&#123;</span><br><span class="line">                S[k][(xo[i]&gt;&gt;k)&amp;1]=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) insert(rt[i],rt[i-1],1,n,rig[i]);</span><br><span class="line">    Q=read();</span><br><span class="line">    while(Q--)&#123;</span><br><span class="line">        int x,y,l,r;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        x=(x+ans*Qt)%n;y=(y+ans*Qt)%n;</span><br><span class="line">        x++;y++;</span><br><span class="line">        l=min(x,y);r=max(x,y);</span><br><span class="line">        ans=Sum(rt[r],rt[l-1],1,n,l,r)+Cnt(rt[r],rt[l-1],1,n,r+1,n)*r-(Ge(r)-Ge(l-1))+(r-l+1);</span><br><span class="line">        write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> xor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zkw线段树 学习笔记</title>
      <link href="/2019/02/24/zkw%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/24/zkw%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>C++位运算</li><li>学过线段树（其实关系不大）</li></ol><h2 id="什么是zkw线段树"><a href="#什么是zkw线段树" class="headerlink" title="什么是zkw线段树"></a>什么是zkw线段树</h2><p>就是一种线段树。（废话） 与普通线段树相比，zkw线段树更快、更短小。 本篇博客讲一个例题：<a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372</a></p><h4 id="普通线段树"><a href="#普通线段树" class="headerlink" title="普通线段树"></a><a href="https://www.luogu.org/recordnew/show/14188476">普通线段树</a></h4><p><img src="https://s2.ax1x.com/2019/02/24/k4u7fU.png"></p><h4 id="zkw线段树"><a href="#zkw线段树" class="headerlink" title="zkw线段树"></a><a href="https://www.luogu.org/recordnew/show/14188476">zkw线段树</a></h4><p><img src="https://s2.ax1x.com/2019/02/24/k4uTYT.png"></p><h2 id="zkw线段树的实现"><a href="#zkw线段树的实现" class="headerlink" title="zkw线段树的实现"></a>zkw线段树的实现</h2><h4 id="首先来看一看变量的定义与BuildTree操作"><a href="#首先来看一看变量的定义与BuildTree操作" class="headerlink" title="首先来看一看变量的定义与BuildTree操作"></a>首先来看一看变量的定义与BuildTree操作</h4><p><img src="https://s2.ax1x.com/2019/02/24/k4K24K.png"></p><p>这是一棵求和的线段树（废话） 然后我们发现它有16个叶子节点。 而$16&#x3D;2^{log_2(16+1)}$ 那我们定义一个N代表叶子节点的数目,n代表原数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n,m,tree[MAXN],add[MAXN],N;</span><br><span class="line">inline void build()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(N=1;N&lt;=n+1;N&lt;&lt;=1) ;//计算N，叶子节点数目</span><br><span class="line">    for(int i=N+1;i&lt;=N+n;i++) tree[i]=read();</span><br><span class="line">    build();</span><br><span class="line">    for(int i=N-1;i&gt;=1;i--) tree[i]=tree[i&lt;&lt;1]+tree[i&lt;&lt;11];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者们肯定会发现上面的计算N的方法计算出来为$32$，是$16$的两倍。对，这样对以后有用。</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>直接放代码了QWQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline void add(int x,int k)&#123;//在原数组编号为x的节点加k</span><br><span class="line">    for(x+=N;x;x&gt;&gt;=1) tree[x]+=k; //x+N代表在树中这个点的编号，然后不断向上GetFa（x&gt;&gt;=1等价于x/=2），直到根节点操作结束（根节点编号为1，到0结束）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><p>单点查询更简单啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline int query(int x)&#123;</span><br><span class="line">    return tree[x+N];//别忘记在原数组中的编号与树中的编号不同！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><p>蒟蒻：区间修改复杂度不会很高吗？zkw线段树怎样让他复杂度降低呢？ 神犇：直接像线段树那样加一个<strong>可持久化标记</strong>不就好了吗？ 这是一棵树：</p><p><img src="https://s2.ax1x.com/2019/02/24/k4K24K.png"></p><p>比如说要修改区间$[7,14]$。 就是修改这一段区间：</p><p><img src="https://s2.ax1x.com/2019/02/24/k4M4iV.png"></p><p>标记$l$为待修改区间的左标记的左边一格，标记$r$为待修改区间的右标记的右边一格。</p><p><img src="https://s2.ax1x.com/2019/02/24/k4MOd1.png"></p><p>那么$[7,7]$节点需要$+k\times 1$，同理，$[6,7]$也要$+k\times 1$，以此类推，但是$[8,9]$节点需要$+k \times 2$因为它的两个儿子都修改，而上文提到这是一棵求和线段树，所以需要$\times 2$。那么可知，$[8,11]$需要$+k \times 4$，$[8,15]$需要$+k\times 8$。 问题来了，怎么求$k$的系数呢？ 我们可以设$now&#x3D;1,CountLeft&#x3D;0,CountRight&#x3D;0$分别表示本层包含多少个节点、$l$指针从叶子节点走来总共走了多少节点、$r$指针从叶子节点走来总共走了多少节点。那么每向上一次GetFa都需要将$now&lt;&lt;&#x3D;1$(即：$now*&#x3D;2$)，$l$指针每向上一次GetFa都需要$l&gt;&gt;&#x3D;1$(即：$l&#x2F;&#x3D;2$)，$r$指针每向上一次GetFa都需要$r&gt;&gt;&#x3D;1$(即：$r&#x2F;&#x3D;2$)。 注意：这次修改需要到达根节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline void update(int l,int r,int k)&#123;</span><br><span class="line">    int CountLeft=0,CountRight=0,now=1;</span><br><span class="line">    for(l=N+l-1,r=N+r+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1,now&lt;&lt;=1)&#123;</span><br><span class="line">        tree[l]+=k*CountLeft;</span><br><span class="line">        tree[r]+=k*CountRight;</span><br><span class="line">        if(l%2==0) add[l^1]+=k,tree[l^1]+=k*now,CountLeft+=now;</span><br><span class="line">        if(r%2==1) add[r^1]+=k,tree[r^1]+=k*now,CountRight+=now;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;l;l&gt;&gt;=1,r&gt;&gt;=1)&#123;</span><br><span class="line">        tree[l]+=k*CountLeft;</span><br><span class="line">        tree[r]+=k*CountRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>与上文的区间修改差不多。只是将修改改成了查询，这里不讲了，直接放代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inline int query(int l,int r)&#123;</span><br><span class="line">    int CountLeft=0,CountRight=0,now=1,res=0;</span><br><span class="line">    for(l=N+l-1,r=N+r+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1,now&lt;&lt;=1)&#123;</span><br><span class="line">        if(add[l]) res+=add[l]*CountLeft;</span><br><span class="line">        if(add[r]) res+=add[r]*CountRight;</span><br><span class="line">        if(l%2==0) res+=tree[l^1],CountLeft+=now;</span><br><span class="line">        if(r%2==1) res+=tree[r^1],CountRight+=now;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;l;l&gt;&gt;=1,r&gt;&gt;=1)&#123;</span><br><span class="line">        res+=add[l]*CountLeft;</span><br><span class="line">        res+=add[r]*CountRight;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于例题"><a href="#关于例题" class="headerlink" title="关于例题"></a>关于例题</h2><p>对对对，就是<a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372</a> 直接上代码，因为就是区间修改+区间查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 100010*4</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[MAXN],tree[MAXN],add[MAXN],N;</span><br><span class="line">inline void build()&#123;</span><br><span class="line">    for(int i=N-1;i&gt;=1;i--) tree[i]=tree[i&lt;&lt;1]+tree[i&lt;&lt;11];</span><br><span class="line">&#125;</span><br><span class="line">inline void update(int l,int r,int k)&#123;</span><br><span class="line">    int CountLeft=0,CountRight=0,now=1;</span><br><span class="line">    for(l=N+l-1,r=N+r+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1,now&lt;&lt;=1)&#123;</span><br><span class="line">        tree[l]+=k*CountLeft;</span><br><span class="line">        tree[r]+=k*CountRight;</span><br><span class="line">        if(l%2==0) add[l^1]+=k,tree[l^1]+=k*now,CountLeft+=now;</span><br><span class="line">        if(r%2==1) add[r^1]+=k,tree[r^1]+=k*now,CountRight+=now;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;l;l&gt;&gt;=1,r&gt;&gt;=1)&#123;</span><br><span class="line">        tree[l]+=k*CountLeft;</span><br><span class="line">        tree[r]+=k*CountRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline int query(int l,int r)&#123;</span><br><span class="line">    int CountLeft=0,CountRight=0,now=1,res=0;</span><br><span class="line">    for(l=N+l-1,r=N+r+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1,now&lt;&lt;=1)&#123;</span><br><span class="line">        if(add[l]) res+=add[l]*CountLeft;</span><br><span class="line">        if(add[r]) res+=add[r]*CountRight;</span><br><span class="line">        if(l%2==0) res+=tree[l^1],CountLeft+=now;</span><br><span class="line">        if(r%2==1) res+=tree[r^1],CountRight+=now;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;l;l&gt;&gt;=1,r&gt;&gt;=1)&#123;</span><br><span class="line">        res+=add[l]*CountLeft;</span><br><span class="line">        res+=add[r]*CountRight;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(N=1;N&lt;=n+1;N&lt;&lt;=1) ;</span><br><span class="line">    for(int i=N+1;i&lt;=N+n;i++) tree[i]=read();</span><br><span class="line">    build();</span><br><span class="line">    for(int op,x,y,k,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read();</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            x=read();y=read();k=read();</span><br><span class="line">            update(x,y,k);</span><br><span class="line">        &#125;else if(op==2)&#123;</span><br><span class="line">            x=read();y=read();</span><br><span class="line">            write(query(x,y));putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> zkw线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2240. 「CQOI2014」数三角形</title>
      <link href="/2019/02/23/2240-%E3%80%8Ccqoi2014%E3%80%8D%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2019/02/23/2240-%E3%80%8Ccqoi2014%E3%80%8D%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>三倍经验</p><p><img src="https://i.loli.net/2019/02/22/5c6febb58ef30.jpg"></p><h3 id="LOJ-2240-「CQOI2014」数三角形"><a href="#LOJ-2240-「CQOI2014」数三角形" class="headerlink" title="LOJ #2240. 「CQOI2014」数三角形"></a><a href="https://loj.ac/problem/2240">LOJ #2240. 「CQOI2014」数三角形</a></h3><h3 id="BZOJ-3505-Cqoi2014-数三角形"><a href="#BZOJ-3505-Cqoi2014-数三角形" class="headerlink" title="BZOJ 3505: [Cqoi2014]数三角形"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3505">BZOJ 3505: [Cqoi2014]数三角形</a></h3><h2 id="Luogu-P3166-CQOI2014-数三角形"><a href="#Luogu-P3166-CQOI2014-数三角形" class="headerlink" title="Luogu P3166 [CQOI2014]数三角形"></a><a href="https://www.luogu.org/problemnew/show/P3166">Luogu P3166 [CQOI2014]数三角形</a></h2><p>（Luogu要大一些。。。）</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个$n \times m$的网格，请计算三点都在格点上的三角形共有多少个。下图为$4 \times 4$的网格上的一个三角形。注意三角形的三点不能共线。</p><p><img src="https://i.loli.net/2017/05/03/59091867eebda.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由题意可知，其实就是让你求一个网格内有多少个不同的三角形。 First Of All，这个网格是从$(0,0)$到$(n,m)$的，出现了令人难受的$0$，于是我们可以在一开始把$n++,m++$范围就变成了$(1,1)$到$(n,m)$$\quad (n,m)$都已$+1$。 由于三角形是不可以三点共线的，所以我们可以求出不符合条件的三角形个数（三点共线）以及所有的三角形个数（包括不符合的与符合的）。 那么最终的答案&#x3D;总方案数即所有的三角形个数（包括不符合的与符合的）-不符合条件的三角形个数（三点共线） 有了这个思路后就可以开始解决这道题了。 总方案数很简单，无非就是在一个$(n,m)$的网格中任意选取$3$个点，求方案数嘛！所以我们可以搬出小学~，不对，初中，不对，高中，对对对，学的知识——组合公式。 先来看看百度百科对组合数的介绍：</p><blockquote><p>组合数公式是指从$n$个不同元素中，任取$m(m≤n)$个元素并成一组，叫做从$n$个不同元素中取出$m$个元素的一个组合；从$n$个不同元素中取出$m(m≤n)$个元素的所有组合的个数，叫做$n$个不同元素中取出$m$个元素的组合数。用符号$C(m,n)$ 表示。</p></blockquote><p>相信你一定看(mei)懂(kan)了。 没关系，反正你只需要记住组合公式：<br>$$C_{n}^{m}&#x3D;\frac{n!}{m!(n-m)!}$$ 那么组合数的C++怎么实现呢？</p><h4 id="方法一：暴力？不介绍。"><a href="#方法一：暴力？不介绍。" class="headerlink" title="方法一：暴力？不介绍。"></a>方法一：暴力？不介绍。</h4><h4 id="方法二：优化的暴力"><a href="#方法二：优化的暴力" class="headerlink" title="方法二：优化的暴力"></a>方法二：优化的暴力</h4><p>首先感觉枚举两次虽然不会TLE，但是容易爆long long。然而我非常懒，所以就不想打高精。<br>为了防止爆long long。这里给出某个大佬的做法： 首先你枚举一个$i$从$1$~$m$。那么看一看上面的组合公式，哪些量可以用$i$、$n$、$m$来表示? 首先$m!&#x3D;m\times (m-1) \times (m-2) \times \dots \times 1$。然后惊人的发现，这不就是$res&#x2F;i$吗？ 然后看$\frac{n!}{(n-m)!}$。因为$n!&#x3D;n \times (n-1) \times (n-2) \times(n-3) \times \dots \times 1$，$(n-m)!&#x3D;(n-m) \times (n-m-1) \times \dots \times 1$。因为$n&gt;n-m$，所以$\frac{n!}{(n-m)!}&#x3D;n \times (n-1) \times (n-2) \times \dots \times (n-m+1)$。这不就是$res \times (n-m+i)$吗？ 如果觉得有问题，可以动脑想一想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long long C(long long a,long long b)&#123;</span><br><span class="line">    long long res=1;</span><br><span class="line">    for(long long i=1;i&lt;=b;i++)</span><br><span class="line">        res=(res*(long long)(a-b+i))/i;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于把组合数介绍完了。。。<br>接下来废话少说，返回到这道题上。 总方案数$&#x3D;C_{3}^{n\times m}$。 接下来算一算不满足的方案数（三点共线）。 如果是一列的三点共线：方案数$&#x3D;C_{3}^{n}\times m$ 如果是一行的三点共线：方案数$&#x3D;C_{3}^{m}\times n$ 如果是斜着的三点共线。那么就要通过枚举来看一看有多少是不满足的（三点共线） PS:一条斜线从$(0,0)$到$(x,y)$有$gcd(x,y)-1$个整点。 于是乎，我们可以枚举$x$、$y$，因为起点不一定为$(0,0)$，所以，每次枚举就要将答案减去整点的个数$\times (n-i)\times(m-j )\times 2$（因为有两条对角线，所以乘$2$）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我知道泥萌就想看这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long n,m,ans;</span><br><span class="line">long long gcd(long long x,long long y)&#123;</span><br><span class="line">    return y==0?x:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">long long C(long long a,long long b)&#123;</span><br><span class="line">    long long res=1;</span><br><span class="line">    for(long long i=1;i&lt;=b;i++)</span><br><span class="line">        res=(res*(long long)(a-b+i))/i;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">//C(n,m)=n!/(m!*(n-m)!)</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);</span><br><span class="line">    n++;m++;</span><br><span class="line">    ans=C(n*m,3);</span><br><span class="line">    ans-=C(n,3)*m;</span><br><span class="line">    ans-=C(m,3)*n;</span><br><span class="line">    for(long long i=2;i&lt;=n-1;i++)&#123;</span><br><span class="line">        for(long long j=2;j&lt;=m-1;j++)&#123;</span><br><span class="line">            long long Pt=gcd(i,j)-1;</span><br><span class="line">            ans-=Pt*(n-i)*(m-j)*2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主席树（静态） 学习笔记</title>
      <link href="/2019/02/18/%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/18/%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="在学习主席树之前"><a href="#在学习主席树之前" class="headerlink" title="在学习主席树之前"></a>在学习主席树之前</h2><p>你必须学习：</p><ol><li>线段树。</li><li>前缀和。</li><li>sort函数、unique函数以及lower_bound函数的使用方法。</li></ol><h2 id="什么是主席树"><a href="#什么是主席树" class="headerlink" title="什么是主席树"></a>什么是主席树</h2><p>主席树又叫函数式线段树，又名可持久化线段树。所以主席树的名称与他的功能一点关系都没有。 主席树的时空复杂度为$O(n logn)$。</p><h2 id="主席树的模板"><a href="#主席树的模板" class="headerlink" title="主席树的模板"></a>主席树的模板</h2><p>由于主席树比较难理解，所以结合代码理解一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int l,r,sum,cnt;//分别表示左儿子、右儿子、和、子节点中叶子节点个数</span><br><span class="line">&#125;tree[MAXN*20];//主席树与线段树不同，因为主席树中包含着许多线段树，所以内存调大</span><br><span class="line">void insert(int &amp;x,int y,int l,int r,int p)&#123;</span><br><span class="line">    x=++ntt;//编号</span><br><span class="line">    tree[x]=tree[y];//先复制上一个节点</span><br><span class="line">    if(l==r)&#123;//叶子节点</span><br><span class="line">        tree[x].sum+=p;//和增加</span><br><span class="line">        tree[x].cnt++;//个数增加</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;//与线段树差不多</span><br><span class="line">    if(p&lt;=mid) insert(tree[x].l,tree[y].l,l,mid,p);</span><br><span class="line">    else insert(tree[x].r,tree[y].r,mid+1,r,p);</span><br><span class="line">    tree[x].sum=tree[tree[x].l].sum+tree[tree[x].r].sum;//pushup</span><br><span class="line">    tree[x].cnt=tree[tree[x].l].cnt+tree[tree[x].r].cnt;</span><br><span class="line">&#125;</span><br><span class="line">int Sum(int x,int y,int l,int r,int L,int R)&#123;//求[l,r]区间中满足值在[L,R]区间的和</span><br><span class="line">    if(L&gt;R) return 0;//没有该区间</span><br><span class="line">    if(L&lt;=l&amp;&amp;r&lt;=R)&#123;//符合条件</span><br><span class="line">        return tree[x].sum-tree[y].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1,res=0;//和线段树差不多</span><br><span class="line">    if(L&lt;=mid) res+=Sum(tree[x].l,tree[y].l,l,mid,L,R);</span><br><span class="line">    if(R&gt;mid) res+=Sum(tree[x].r,tree[y].r,mid+1,r,L,R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int Cnt(int x,int y,int l,int r,int L,int R)&#123;//求[l,r]区间中满足值在[L,R]区间的叶子节点个数</span><br><span class="line">    if(L&gt;R) return 0;//没有该区间</span><br><span class="line">    if(l&gt;r) return 0;//没有该区间</span><br><span class="line">    if(L&lt;=l&amp;&amp;r&lt;=R)&#123;//符合条件</span><br><span class="line">        return tree[x].cnt-tree[y].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1,res=0;//与线段树差不多</span><br><span class="line">    if(L&lt;=mid) res+=Cnt(tree[x].l,tree[y].l,l,mid,L,R);</span><br><span class="line">    if(R&gt;mid) res+=Cnt(tree[x].r,tree[y].r,mid+1,r,L,R);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看一看模板题： <a href="https://www.luogu.org/problemnew/show/P3834">P3834 【模板】可持久化线段树 1（主席树）</a> 这里放一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 200010 </span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,q,t=0;</span><br><span class="line">int a[MAXN],b[MAXN],rt[MAXN];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r,sum;</span><br><span class="line">&#125;tree[MAXN*20];</span><br><span class="line">void lsh()&#123;</span><br><span class="line">    sort(b+1,b+n+1);</span><br><span class="line">    m=unique(b+1,b+n+1)-(b+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int y,int &amp;x,int l,int r,int p)&#123;</span><br><span class="line">    x=++t;</span><br><span class="line">    tree[x]=tree[y];</span><br><span class="line">    tree[x].sum++;</span><br><span class="line">    if(l==r)  return;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(p&lt;=mid) insert(tree[y].l,tree[x].l,l,mid,p);</span><br><span class="line">    else insert(tree[y].r,tree[x].r,mid+1,r,p);</span><br><span class="line">&#125;</span><br><span class="line">int query(int x,int y,int l,int r,int k)&#123;</span><br><span class="line">    if(l==r) return l;</span><br><span class="line">    int tmp=tree[tree[y].l].sum-tree[tree[x].l].sum;</span><br><span class="line">    int mid=(l+r)&gt;&gt;1;</span><br><span class="line">    if(k&lt;=tmp) return query(tree[x].l,tree[y].l,l,mid,k);</span><br><span class="line">    else return query(tree[x].r,tree[y].r,mid+1,r,k-tmp);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lsh();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) insert(rt[i-1],rt[i],1,m,a[i]);</span><br><span class="line">    for(int l,r,k,i=1;i&lt;=q;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class="line">        cout&lt;&lt;b[query(rt[l-1],rt[r],1,m,k)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题： <a href="https://www.codechef.com/problems/PREFIXOR">SnackDown 2017 Online Elimination Round Prefix XOR</a> 详情见<a href="https://yzx233.xyz/archives/412">这篇博客</a></p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 静态主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10137. 「一本通 4.4 练习 4」跳跳棋</title>
      <link href="/2019/02/17/10137-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-4-%E7%BB%83%E4%B9%A0-4%E3%80%8D%E8%B7%B3%E8%B7%B3%E6%A3%8B/"/>
      <url>/2019/02/17/10137-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-4-%E7%BB%83%E4%B9%A0-4%E3%80%8D%E8%B7%B3%E8%B7%B3%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋来做一个简单的游戏：棋盘上有三颗棋子，分别在 $a,b,c$ 这三个位置。我们要通过最少的跳动把他们的位置移动成 $x,y,z$（注意：棋子是没有区别的）。<br>跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过一颗棋子。<br>写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。<br><img src="https://coding.net/u/HeRaNO/p/PicPlace/git/raw/master/halma.png">  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以将状态视为一个三元组$(x,y,z)$。</p><ol><li>中间往左跳：$(x,y,z) –&gt; (2x-y,x,z)$</li><li>中间往右跳：$(x,y,z) –&gt; (x,z,2z-y)$</li><li>左边往右跳：$if (y-x)&lt;(z-y) then (x,y,z) –&gt; (y,2y-x,z) Because ‘Only one chess piece is allowed to be skipped at a time.’$</li><li>右边往左跳：$if (y-x)&gt;(z-y) then (x,y,z) –&gt; (x,2y-z,y) Because ‘Only one chess piece is allowed to be skipped at a time.’$</li></ol><p>可以注意到，操作1与操作2可以使该三元组区间扩大。而操作3与操作4可以使三元组区间缩小。 那我们将区间扩大的视为父亲，区间缩小的状态视为儿子。 那么我们可以由此构建一棵树。 先把深度大的节点移到深度小的节点，然后二分到LCA的距离，往上走n步和求根。 当然，这样是会TLE的，比如说这组数据：9998 9999 10000000 如果以1步每次的速度的话就需要跳 (10000000-9999)&#x2F;(9999-9998)次嘛！所以就有一个优化：MOD。 这样就可以像gcd一样，跑得飞快。省去了很多时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">#define MAXN 500010</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;endsss,tmps;</span><br><span class="line">node make(int x,int y,int z)&#123;</span><br><span class="line">    node pp;pp.x=x;pp.y=y;pp.z=z;return pp;</span><br><span class="line">&#125;</span><br><span class="line">int GetFa(node p)&#123;</span><br><span class="line">    int x=p.x,y=p.y,z=p.z,res=0;</span><br><span class="line">    if(y-x&lt;z-y)&#123;</span><br><span class="line">        int pt=y-x;</span><br><span class="line">        int zr=z-y;</span><br><span class="line">        int kkk=zr%pt;res=zr/pt;</span><br><span class="line">        if(kkk==0) --res,kkk+=pt;</span><br><span class="line">        res+=GetFa(make(z-kkk-(y-x),z-kkk,z));</span><br><span class="line">        return res;</span><br><span class="line">        //-----X--Y-Z----------</span><br><span class="line">    &#125;else if(y-x&gt;z-y)&#123;</span><br><span class="line">        int pt=z-y;</span><br><span class="line">        int zr=y-x;</span><br><span class="line">        int kkk=zr%pt;res=zr/pt;</span><br><span class="line">        if(kkk==0) --res,kkk+=pt;</span><br><span class="line">        res+=GetFa(make(x,x+kkk,x+kkk+(z-y)));</span><br><span class="line">        return res;</span><br><span class="line">        //------X-Y---Z----------</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        endsss=p;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void move(node p,int stp)&#123;</span><br><span class="line">    int x=p.x,y=p.y,z=p.z;</span><br><span class="line">    int pt=y-x,zr=z-y,cz,res=0;</span><br><span class="line">    if(stp==0pt==zr)&#123;endsss=p;return ;&#125;</span><br><span class="line">    if(pt&lt;zr)&#123;</span><br><span class="line">        res=zr/pt;</span><br><span class="line">        cz=zr%pt;</span><br><span class="line">        if(cz==0) cz=pt,--res;</span><br><span class="line">        if(stp&lt;res) move(make(z-cz-(res-stp+1)*pt,z-cz-(res-stp)*pt,z),0);</span><br><span class="line">        else move(make(z-cz-pt,z-cz,z),stp-res);</span><br><span class="line">        //X,Y,Z</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res=pt/zr;</span><br><span class="line">        cz=pt%zr;</span><br><span class="line">        if(cz==0) cz=zr,--res;</span><br><span class="line">        if(stp&lt;res) move(make(x,x+cz+zr*(res-stp),x+cz+zr*(res-stp+1)),0);</span><br><span class="line">        else move(make(x,x+cz,x+cz+zr),stp-res);</span><br><span class="line">        //X,Y,Z </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int tmp[5];</span><br><span class="line">void Sort(int &amp;x,int &amp;y,int &amp;z)&#123;</span><br><span class="line">    tmp[1]=x;tmp[2]=y;tmp[3]=z;</span><br><span class="line">    sort(tmp+1,tmp+3+1);</span><br><span class="line">    x=tmp[1];y=tmp[2];z=tmp[3];</span><br><span class="line">&#125;</span><br><span class="line">int a,b,c;</span><br><span class="line">int x,y,z;</span><br><span class="line">bool judge(node q,node p)&#123;</span><br><span class="line">    if(q.x==p.x&amp;&amp;q.y==p.y&amp;&amp;q.z==p.z) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int mid)&#123;</span><br><span class="line">    move(make(x,y,z),mid);tmps=endsss;</span><br><span class="line">    move(make(a,b,c),mid);</span><br><span class="line">    if(judge(tmps,endsss)==1) return 0;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    a=read();b=read();c=read();</span><br><span class="line">    x=read();y=read();z=read();</span><br><span class="line">    Sort(x,y,z);</span><br><span class="line">    Sort(a,b,c);</span><br><span class="line">    int stp1=GetFa(make(a,b,c));tmps=endsss;</span><br><span class="line">    int stp2=GetFa(make(x,y,z));</span><br><span class="line">    if(judge(tmps,endsss)==1)&#123;</span><br><span class="line">        puts(&quot;NO&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stp1&lt;stp2) move(make(x,y,z),stp2-stp1),x=endsss.x,y=endsss.y,z=endsss.z;</span><br><span class="line">    else if(stp1&gt;stp2) move(make(a,b,c),stp1-stp2),a=endsss.x,b=endsss.y,c=endsss.z;</span><br><span class="line">    int l=0,r=min(stp1,stp2),mid,ans;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        mid=l+r&gt;&gt;1;</span><br><span class="line">        if(check(mid)) r=mid-1,ans=mid;</span><br><span class="line">        else l=mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;YES&quot;);</span><br><span class="line">    write(ans*2+abs(stp1-stp2));putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//(x,y,z) --&gt; (2x-y,x,z)</span><br><span class="line">//(x,y,z) --&gt; (x,z,2z-y)</span><br><span class="line">//if (y-x)&lt;(z-y) then (x,y,z) --&gt; (y,2y-x,z) Because &#x27;Only one chess piece is allowed to be skipped at a time.&#x27;</span><br><span class="line">//if (y-x)&gt;(z-y) then (x,y,z) --&gt; (x,2y-z,y) Because &#x27;Only one chess piece is allowed to be skipped at a time.&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> MOD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10187. 「一本通 5.6 例 4」Cats Transport</title>
      <link href="/2019/02/17/10187-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-6-%E4%BE%8B-4%E3%80%8Dcats-transport/"/>
      <url>/2019/02/17/10187-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-6-%E4%BE%8B-4%E3%80%8Dcats-transport/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>小S养了$M$只猫，雇了$P$位饲养员。农场旁边有$N$座山，从$1$到$N$编号，第$i$座山与第$i-1$座山的距离为$D_i$，饲养员都住在$1$号山上。 有一天，第$i$只猫到第$H_i$座山玩，一直玩到$T_i$停止。饲养员们必须接回所有的猫，饲养员们行走的速度为$1$个单位每单位时间。 问如何计划每个饲养员从$1$号山出发的时间，使得所有猫的等待时间最少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$A_i&#x3D;T_i-\sum{D_j}(1 \leq j \leq H_i)$。一名饲养员若想接到第$i$只猫就必须要在$A_i$时刻出发。若出发时间为$t$，那么这只猫等待的时间就是$t-A_i$。 先把$A_i$从小到大排序，求出排好序的$A$数组的前缀和，记录在数组$S$中。 然后根据贪心的思想，每个饲养员带走的猫一定是按照$A$从小到大排序后的连续的几只猫。 设$f[i][j]$表示前$i$个饲养员带走前$j$只猫，猫们等待的最少时间。 很容易就可以得出转移方程： $$f[i][j]&#x3D;min(f[i-1][k]+a[j]\times (j-k) - (s[j]-s[k]))(0 \leq k &lt; j)$$ 直接枚举$k$肯定会超时，时间复杂度为$O(PM^2)$。 将$min$去掉，进行化简、移项可得： $$f[i-1][k]+s[k]&#x3D;a[j] \times k +f[i][j]-a[j]\times j +s[j]$$ 设$y&#x3D;f[i-1][k]+s[k],k&#x3D;a[j],x&#x3D;k,b&#x3D;f[i][j]-a[j] \times j+s[j]$。由一次函数$y&#x3D;kx+b$可得，当$b$为最小时，$f[i][j]$取得最小值。 那么就加上单调队列斜率优化即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,m,p,a[100010],s[100010],q[100010],h,t,g[100010],d[100010],f[110][100010];</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();m=read();p=read();</span><br><span class="line">    for(int i=2;i&lt;=n;i++) d[i]=d[i-1]+read();</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        h=read();t=read();</span><br><span class="line">        a[i]=t-d[h];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+m+1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) s[i]=s[i-1]+a[i];</span><br><span class="line">    //O(PM^2)做法</span><br><span class="line">//  memset(f,0x3f,sizeof(f));f[0][0]=0;</span><br><span class="line">//  for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">//      for(int j=0;j&lt;=m;j++)&#123;</span><br><span class="line">//          for(int k=0;k&lt;=m;k++)&#123;</span><br><span class="line">//              f[i][j]=min(f[i][j],f[i-1][k]+a[j]*j-a[j]*k-s[j]+s[k]);</span><br><span class="line">//          &#125;</span><br><span class="line">//      &#125;</span><br><span class="line">//  &#125;</span><br><span class="line">//  cout&lt;&lt;f[p][m]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    memset(f,127,sizeof(f));f[0][0]=0;</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++) g[j]=f[i-1][j]+s[j];</span><br><span class="line">        h=1;t=1;q[1]=0;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            while(h&lt;t&amp;&amp;(g[q[h+1]]-g[q[h]])&lt;=a[j]*(q[h+1]-q[h])) h++;</span><br><span class="line">            f[i][j]=min(f[i-1][j],g[q[h]]+a[j]*(j-q[h])-s[j]);</span><br><span class="line">            if(g[j]&gt;=2e18) continue;</span><br><span class="line">            while(h&lt;t&amp;&amp;(g[j]-g[q[t]])*(q[t]-q[t-1])&lt;=(g[q[t]]-g[q[t-1]])*(j-q[t])) t--;</span><br><span class="line">            q[++t]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write(f[p][m]);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10162. 「一本通 5.2 练习 5」骑士</title>
      <link href="/2019/02/17/10162-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E7%BB%83%E4%B9%A0-5%E3%80%8D%E9%AA%91%E5%A3%AB/"/>
      <url>/2019/02/17/10162-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E7%BB%83%E4%B9%A0-5%E3%80%8D%E9%AA%91%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个骑士，每个骑士有一个自己的战斗值，每个骑士也有且仅有唯一一个自己讨厌的骑士，每个骑士不可能与自己讨厌的骑士一起上场战斗，问最高的战斗值之和是多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题与没有上司的舞会很像。但是注意，这道题可能会有环的存在，所以我们需要对于每个环，把它切割成两部分，再分别树形dp，然后取最大值，加入ans中。 树形dp的思路很简单： 设$f[x][0]$表示第$x$个骑士不上战场。 设$f[x][1]$表示第$x$个骑士上战场。 那么很简单就可以推出： $$f[x][0]&#x3D;\sum{max(f[to][0],f[to][1]),to∈son_x}$$ $$f[x][1]&#x3D;a[x]+\sum{f[to][0],to∈son_x}$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,v[1000010],a[1000010],f[1000010][2],in[1000010],rt=1,vis[1000010],d[1000010],t;</span><br><span class="line">int fir[1000010],nxt[1000010],w[1000010],son[1000010],tot,fa[1000010],ans;</span><br><span class="line">void add(int x,int y)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void TreeDp(int x)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    f[x][0]=0;f[x][1]=a[x];</span><br><span class="line">    for(int i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        int to=son[i];</span><br><span class="line">        if(to==rt)&#123;</span><br><span class="line">            f[to][1]=-2e9;continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeDp(to);</span><br><span class="line">        f[x][0]+=max(f[to][0],f[to][1]);</span><br><span class="line">        f[x][1]+=f[to][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void circle(int x)&#123;</span><br><span class="line">    rt=x;</span><br><span class="line">    while(vis[rt]==0)&#123;</span><br><span class="line">        vis[rt]=1;</span><br><span class="line">        rt=fa[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    TreeDp(rt);</span><br><span class="line">    long long tmp=max(f[rt][0],f[rt][1]);</span><br><span class="line">    rt=fa[rt];</span><br><span class="line">    TreeDp(rt);</span><br><span class="line">    long long temp=max(f[rt][0],f[rt][1]);</span><br><span class="line">    ans+=max(tmp,temp);</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=read();</span><br><span class="line">        int x=read();</span><br><span class="line">        add(x,i);</span><br><span class="line">        fa[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i]==0)&#123;</span><br><span class="line">            circle(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10161. 「一本通 5.2 练习 4」叶子的染色</title>
      <link href="/2019/02/16/10161-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E7%BB%83%E4%B9%A0-4%E3%80%8D%E5%8F%B6%E5%AD%90%E7%9A%84%E6%9F%93%E8%89%B2/"/>
      <url>/2019/02/16/10161-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E7%BB%83%E4%B9%A0-4%E3%80%8D%E5%8F%B6%E5%AD%90%E7%9A%84%E6%9F%93%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一棵有 $m$ 个节点的无根树，你可以选择一个度数大于 $1$ 的节点作为根，然后给一些节点（根、内部节点、叶子均可）着以黑色或白色。你的着色方案应保证根节点到各叶子节点的简单路径上都包含一个有色节点，哪怕是叶子本身。<br>对于每个叶子节点 $u$，定义 $c_u$ 为从根节点到 $u$ 的简单路径上最后一个有色节点的颜色。给出每个 $c_u$ 的值，设计着色方案使得着色节点的个数尽量少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$f[i][0]$表示第$i$个节点着成黑色时以$i$为根节点的子树最少的着色个数，<br>设$f[i][1]$表示第$i$个节点着成白色时以$i$为根节点的子树最少的着色个数，<br>设$f[i][2]$表示第$i$个节点着成无色时以$i$为根节点的子树最少的着色个数 。 那么很<del>容易</del>就可以知道： $$f[x][0]&#x3D;\sum{min(f[to][0]-1,f[to][1],f[to][2]),to∈son_x}$$ $$f[x][1]&#x3D;\sum{min(f[to][0],f[to][1]-1,f[to][2]),to∈son_x}$$ $$f[x][2]&#x3D;\sum{min(f[to][0],f[to][1],f[to][2]),to∈son_x}$$ 然后注意一下边界问题。 如果$x$为叶子节点，即$x \leq n$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(c[x]) f[x][1]=1,f[x][0]=2e9,f[x][2]=1;//如果为白色</span><br><span class="line">else f[x][0]=1,f[x][1]=2e9,f[x][2]=1;//如果为黑色</span><br></pre></td></tr></table></figure><p>如果$x$不为叶子节点，即$x&gt;n$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[x][1]=1,f[x][0]=1;</span><br></pre></td></tr></table></figure><p>好了鸭。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll m,n,c[10010],in[10010],rt,f[10010][5];</span><br><span class="line">vector&lt;ll&gt; v[10010];</span><br><span class="line">void TreeDp(ll x,ll fa)&#123;</span><br><span class="line">    if(x&lt;=n)&#123;//Leaf</span><br><span class="line">        if(c[x]) f[x][1]=1,f[x][0]=2e9,f[x][2]=1;</span><br><span class="line">        else f[x][0]=1,f[x][1]=2e9,f[x][2]=1;</span><br><span class="line">    &#125;else f[x][1]=1,f[x][0]=1;</span><br><span class="line">    for(ll i=0;i&lt;v[x].size();i++)&#123;</span><br><span class="line">        ll to=v[x][i];</span><br><span class="line">        if(to==fa) continue ;</span><br><span class="line">        TreeDp(to,x);</span><br><span class="line">        f[x][0]+=min(f[to][0]-1,min(f[to][1],f[to][2]));</span><br><span class="line">        f[x][1]+=min(f[to][0],min(f[to][1]-1,f[to][2]));</span><br><span class="line">        f[x][2]+=min(f[to][0],min(f[to][1],f[to][2]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    m=read();n=read();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) c[i]=read();</span><br><span class="line">    for(ll i=1;i&lt;=m-1;i++)&#123;</span><br><span class="line">        ll x=read(),y=read();</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        v[y].push_back(x);</span><br><span class="line">        in[x]++;in[y]++;</span><br><span class="line">        if(rt==0)&#123;</span><br><span class="line">            if(in[x]&gt;1) rt=x;</span><br><span class="line">            else if(in[y]&gt;1) rt=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeDp(rt,0);</span><br><span class="line">    write(min(f[rt][0],f[rt][1]));putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10206. 「一本通 6.3 练习 1」X-factor Chain</title>
      <link href="/2019/02/16/10206-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-3-%E7%BB%83%E4%B9%A0-1%E3%80%8Dx-factor-chain/"/>
      <url>/2019/02/16/10206-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-3-%E7%BB%83%E4%B9%A0-1%E3%80%8Dx-factor-chain/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>输入正整数 $x$，求 $x$ 的大于 $1$ 的因子组成的满足任意前一项都能整除后一项的序列的最大长度，以及满足最大长度的序列的个数。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目读起来很困难？告诉你题目的<strong>实际</strong>意思。 给你一个数，要求你输出将这个数分解成因式相乘，并且后面一个因子至少是前面一个因子的2倍，问最长的因式相乘链有多长，有几条最长的因式相乘链。 为什么可以这样转化呢？ 拿个样例来看看。 $$100&#x3D;2^2*5^2$$ 所以最长的序列长度为4，可以是这样的：100,50,25,5。 那是不是就是直接从原数不断除就好了，所以题面就相当于上述。 将读入的那个数字进行分解质因数。分解出来自然后面一个数必然大于前面一个数的两倍。 满足最大长度的序列的个数 ，就是全排列。但是要除去重复因子的全排列。所以$n$个不同的数的全排列就是$n!$，除去重复的就是$n!$除以每个重复因子数的阶乘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll x,prime[1024*1024+10],f[1024*1024+10],tot;</span><br><span class="line">ll pw[1024];</span><br><span class="line">void primes()&#123;</span><br><span class="line">    for(ll i=2;i&lt;=1024*1024;i++)&#123;</span><br><span class="line">        if(f[i]==0)&#123;</span><br><span class="line">            prime[++tot]=i;</span><br><span class="line">            for(ll j=i*2;j&lt;=1024*1024;j+=i)&#123;</span><br><span class="line">                f[j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;ll,ll&gt; &gt; v;</span><br><span class="line">void work(ll n)&#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    ll p=n,fk=0;</span><br><span class="line">    for(ll i=1;prime[i]&lt;=n&amp;&amp;i&lt;=tot;i++)&#123;</span><br><span class="line">        ll fsum=0;</span><br><span class="line">        if(p%prime[i]==0)&#123;</span><br><span class="line">            while(p%prime[i]==0) fsum++,p/=prime[i];</span><br><span class="line">            v.push_back(make_pair(prime[i],fsum));</span><br><span class="line">            fk+=fsum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p!=1)&#123;</span><br><span class="line">        v.push_back(make_pair(p,1));</span><br><span class="line">        p=1;fk++;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fk);putchar(&#x27; &#x27;);</span><br><span class="line">    ll Ans=1;</span><br><span class="line">    for(ll i=1;i&lt;=fk;i++) Ans*=i;</span><br><span class="line">    for(ll i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">        ll fg=v[i].second,ttt=1;</span><br><span class="line">        for(ll j=1;j&lt;=fg;j++) ttt*=j;</span><br><span class="line">        Ans/=ttt;</span><br><span class="line">    &#125;</span><br><span class="line">    write(Ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    primes();</span><br><span class="line">    while(cin&gt;&gt;x) work(x);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10204. 「一本通 6.3 例 2」Hankson 的趣味题</title>
      <link href="/2019/02/16/10204-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-3-%E4%BE%8B-2%E3%80%8Dhankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/"/>
      <url>/2019/02/16/10204-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-3-%E4%BE%8B-2%E3%80%8Dhankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：<br>1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；<br>2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。<br>Hankson 的「逆问题」就是求出满足条件的正整数 $x$ 的个数。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先从第二个条件入手。 $$lcm(x,b_0)&#x3D;b_1$$ 因为$lcm(x,y)&#x3D;x*y&#x2F;gcd(x,y)$ 所以$lcm(x,b_0)&#x3D;x*b_0&#x2F;gcd(x,b_0)&#x3D;b_1$ 化简，得: $$x&#x3D;(b_1&#x2F;b_0)*gcd(x,b_0)$$ 因为$b_1,b_0$都是已知量，所以只需要枚举$gcd(x,b_0)$即可求解出$x$。 <del>而$gcd(x,b_0)$必须是$b_0$的因数（废话）</del> 所以只需要从$1$枚举到$sqrt(b_0)$就好了。 注意判断$b_0$是完全平方数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int T;</span><br><span class="line">int a0,a1,b0,b1,ans,x;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b==0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    T=read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        a0=read();a1=read();b0=read();b1=read();</span><br><span class="line">        int bb=b1/b0;ans=0;</span><br><span class="line">        for(int i=1;i&lt;=sqrt(b0);i++)&#123;//For gcd(x,b0)</span><br><span class="line">            if(i==sqrt(b0)&amp;&amp;((int)(sqrt(b0)))*((int)(sqrt(b0)))==b0&amp;&amp;b0%(((int)(sqrt(b0))))==0)&#123;</span><br><span class="line">                x=bb*((int)(sqrt(b0)));</span><br><span class="line">                if(gcd(x,b0)==((int)(sqrt(b0)))&amp;&amp;gcd(x,a0)==a1) ans++;</span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(b0%i==0)&#123;</span><br><span class="line">                x=bb*i;</span><br><span class="line">                if(gcd(x,b0)==i&amp;&amp;gcd(x,a0)==a1) ans++;</span><br><span class="line">                x=bb*(b0/i);</span><br><span class="line">                if(gcd(x,b0)==b0/i&amp;&amp;gcd(x,a0)==a1) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 数论 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10156. 「一本通 5.2 例 4」战略游戏</title>
      <link href="/2019/02/16/10156-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E4%BE%8B-4%E3%80%8D%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/02/16/10156-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E4%BE%8B-4%E3%80%8D%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一座古城堡，里面的路形成一棵树， 某个士兵在一个节点上时，与该节点相连的所有边都将能被瞭望到。问最少需要多少士兵才可以使所有的路都被瞭望到。 输入数据表示一棵树，描述如下。 第一行一个数 $N$ ，表示树中节点的数目。 第二到第 $N+1$ 行，每行描述每个节点信息，依次为该节点编号 $i$，数值 $k$，$k$ 表示后面有 $k$ 条边与节点 $i$ 相连，接下来 $k$ 个数，分别是每条边的所连节点编号 $r_1,r_2,\cdots ,r_k$。 对于一个有 $N$ 个节点的树，节点标号在 $0$ 到 $N-1$ 之间，且在输入文件中每条边仅出现一次。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$f[x][0]$表示第$i$个节点不放士兵，以$x$节点为根节点的子树所需要士兵的最少数量。 设$f[x][1]$表示第$i$个节点放士兵，以$x$节点为根节点的子树所需要士兵的最少数量。 那么有： $$f[x][0]&#x3D;\sum{f[y][1],y∈x的儿子}$$ $$f[x][1]&#x3D;1+\sum{min(f[y][0],f[y][1]),y∈x的儿子}$$ 那么这个问题就愉快的解决了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n,root=0,r[1600],f[1600][3];</span><br><span class="line">vector&lt;int&gt; v[1600];</span><br><span class="line">void dp(int x)&#123;</span><br><span class="line">    f[x][1]=1;</span><br><span class="line">    f[x][0]=0;</span><br><span class="line">    if(v[x].size()==0) return ;</span><br><span class="line">    for(int i=0;i&lt;v[x].size();i++)&#123;</span><br><span class="line">        dp(v[x][i]);</span><br><span class="line">        f[x][0]+=f[v[x][i]][1];</span><br><span class="line">        f[x][1]+=min(f[v[x][i]][0],f[v[x][i]][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int vs=read();</span><br><span class="line">        int k=read();</span><br><span class="line">        while(k--)&#123;</span><br><span class="line">            int x=read();</span><br><span class="line">            v[vs].push_back(x);</span><br><span class="line">            r[x]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;r[root]==1;root++) ;</span><br><span class="line">    dp(root);</span><br><span class="line">    write(min(f[root][0],f[root][1]));putchar(&#x27;\n&#x27;); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10230. 「一本通 6.6 练习 1」牡牛和牝牛</title>
      <link href="/2019/02/15/10230-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-6-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%89%A1%E7%89%9B%E5%92%8C%E7%89%9D%E7%89%9B/"/>
      <url>/2019/02/15/10230-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-6-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%89%A1%E7%89%9B%E5%92%8C%E7%89%9D%E7%89%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>牡 mǔ，畜父也。牝 pìn，畜母也。 ——《说文解字》  </p></blockquote><p>约翰要带 $N$ 只牛去参加集会里的展示活动，这些牛可以是牡牛，也可以是牝牛。牛们要站成一排，但是牡牛是好斗的，为了避免牡牛闹出乱子，约翰决定任意两只牡牛之间至少要有 $K$ 只牝牛。请计算一共有多少种排队的方法，所有牡牛可以看成是相同的，所有牝牛也一样，答案对 $5000011$ 取模。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$f_i$表示当前第$i$头牛放牡牛，那么组合数为$sum_{i-k+1}$。$sum_i&#x3D;sum_{i-1}+f_i$。最后输出总方案数：$sum_n+1$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXE 400010</span><br><span class="line">#define ll long long </span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    char ch=getchar();ll res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll f[100010],sum[100010];</span><br><span class="line">ll n,k;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();k=read();</span><br><span class="line">    fill(f,f+100001,1);</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(i&gt;k)&#123;</span><br><span class="line">            f[i]+=sum[i-k-1];</span><br><span class="line">            f[i]%=5000011;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i]=sum[i-1]+f[i];</span><br><span class="line">        sum[i]%=5000011;</span><br><span class="line">    &#125;</span><br><span class="line">    write(sum[n]+1);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P3419 [POI2005]SAM-Toy Cars题解</title>
      <link href="/2019/02/15/%E6%B4%9B%E8%B0%B7-p3419-poi2005sam-toy-cars%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/%E6%B4%9B%E8%B0%B7-p3419-poi2005sam-toy-cars%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Jasio 是一个三岁的小男孩,他最喜欢玩玩具了,他有n 个不同的玩具,它们都被放在了很高的架子上所以Jasio 拿不到它们. 为了让他的房间有足够的空间,在任何时刻地板上都不会有超过k 个玩具. Jasio 在地板上玩玩具. Jasio’的妈妈则在房间里陪他的儿子. 当Jasio 想玩地板上的其他玩具时,他会自己去拿,如果他想玩的玩具在架子上,他的妈妈则会帮他去拿,当她拿玩具的时候,顺便也会将一个地板上的玩具放上架子使得地板上有足够的空间. 他的妈妈很清楚自己的孩子所以他能够预料到Jasio 想玩些什么玩具. 所以她想尽量的使自己去架子上拿玩具的次数尽量的少,应该怎么安排放玩具的顺序呢?</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一 行三 个整数:n,k,p(1≤k≤n≤100,000,1≤p≤500000), 分别表示玩具的总数,地板上玩具的最多个数以及 JasioJasio 他想玩玩具的序列的个数,接下来 pp 行每行描述一个玩具编号表示 Jasio 想玩的玩具。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>一个数表示 JasioJasio 的妈妈最少要拿多少次玩具。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><p>3 2 7<br>1<br>2<br>3<br>1<br>3<br>1<br>2</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><p>4</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="luogu一直AC不了的小朋友们看这里："><a href="#luogu一直AC不了的小朋友们看这里：" class="headerlink" title="luogu一直AC不了的小朋友们看这里："></a>luogu一直AC不了的小朋友们看这里：</h4><h4 id="不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars"><a href="#不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars" class="headerlink" title="不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars"></a>不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars</h4><h4 id="不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars-1"><a href="#不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars-1" class="headerlink" title="不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars"></a>不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars</h4><h4 id="不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars-2"><a href="#不要提交SP688，提交P3419-POI2005-SAM-Toy-Cars-2" class="headerlink" title="不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars"></a>不要提交SP688，提交P3419 [POI2005]SAM-Toy Cars</h4><p>至于为什么，我也不知道。。。反正本人卡了3次提交在luogu上（手动滑稽）</p><blockquote><p>这道题使用贪心+堆优化。</p></blockquote><p>贪心为： 每一次输入一个数将弹出一个大小为k的集合中的一个数才能使该数加入。 当然，如果该数早就在集合当中就可以直接切换到下一个数。 前k个数也可以直接进入集合中。 问题来了？到底弹集合中的哪一个数才能最优呢？ 当然是下一次出现的距离最远的那一个数了。 堆优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure><p>就是一个大根堆。 那么这道题需要将堆里的类型修改一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q;</span><br></pre></td></tr></table></figure><p>pair的前一个储存节点的下一次出现位置，第二个储存该节点的值。 这样就可以自动的排序出距离最远的那一个数了。 所以每次操作只需要将q.top()取出，然后将头元素删除——q.pop()。 最后，上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define ll long long </span><br><span class="line">#define FHAKIOI int</span><br><span class="line">using namespace std;//头文件结束</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll ret=0,f=1;char ch=getchar();</span><br><span class="line">    while (ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;) &#123;if (ch==&#x27;-&#x27;) f=-f;ch=getchar();&#125;</span><br><span class="line">    while (ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;//读优结束</span><br><span class="line">inline void write(ll zx)&#123;</span><br><span class="line">    if(zx&lt;0)&#123;zx=-zx;putchar(&#x27;-&#x27;);&#125;</span><br><span class="line">    if(zx&lt;10) putchar(zx+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(zx/10);</span><br><span class="line">        putchar(zx%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//输优结束</span><br><span class="line">ll n,k,p,a[500010];</span><br><span class="line">ll use[100010];</span><br><span class="line">ll f[500010];</span><br><span class="line">ll las[500010],ans;</span><br><span class="line">ll nxt[500010];</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;//堆</span><br><span class="line">FHAKIOI main()&#123;</span><br><span class="line">    n=read();k=read();p=read();</span><br><span class="line">    for(ll i=1;i&lt;=p;i++) a[i]=read(),las[a[i]]=p+1;//读入</span><br><span class="line">    for(ll i=p;i&gt;=1;i--)&#123;</span><br><span class="line">        nxt[i]=las[a[i]];</span><br><span class="line">        las[a[i]]=i;</span><br><span class="line">    &#125;//先预处理与下一次出现的位置的距离</span><br><span class="line">    for(int i=1;i&lt;=p;i++)&#123;</span><br><span class="line">        if(use[a[i]]!=0)&#123;</span><br><span class="line">            q.push(make_pair(nxt[i],a[i]));//已经在集合里了</span><br><span class="line">        &#125;else if(k!=0)&#123;//前K个数</span><br><span class="line">            k--;</span><br><span class="line">            ans++;</span><br><span class="line">            use[a[i]]=1;</span><br><span class="line">            q.push(make_pair(nxt[i],a[i]));</span><br><span class="line">        &#125;else&#123;//最后一种情况，需要弹出一个数</span><br><span class="line">            while(!use[q.top().second]) q.pop();//目前没有在集合中</span><br><span class="line">            int x=q.top().second;//取距离最远的</span><br><span class="line">            q.pop();</span><br><span class="line">            use[x]=0;</span><br><span class="line">            ans++;//ans加一</span><br><span class="line">            use[a[i]]=1;</span><br><span class="line">            q.push(make_pair(nxt[i],a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);/输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 堆优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF293B Distinct Paths 题解</title>
      <link href="/2019/02/15/cf293b-distinct-paths-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/cf293b-distinct-paths-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个$n\times m$的矩形色板，有kk种不同的颜料，有些格子已经填上了某种颜色，现在需要将其他格子也填上颜色，使得从左上角到右下角的任意路径经过的格子都不会出现两种及以上相同的颜色。路径只能沿着相邻的格子，且只能向下或者向右。 计算所有可能的方案，结果对 $1000000007 (10^9 + 7)$</p><h2 id="输入及输出格式"><a href="#输入及输出格式" class="headerlink" title="输入及输出格式"></a>输入及输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，三个整数$ n, m, k (1 \le n, m \le 1000, 1 \le k \le 10)$； 接下来$n$行，每行包含$m$个整数，表示颜色。其中$0$表示未涂色，非$0$表示颜色的编号， 颜色编号为$1$到$k$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行，一个整数，表示涂色方案对$ 1000000007 (10^9 + 7)$求模的结果。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>此处就不挂了：<a href="https://www.luogu.org/problemnew/show/CF293B">传送门</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看似数据很大：$ n, m, k (1 \le n, m \le 1000, 1 \le k \le 10)$，但是，$k&lt;n+m-1$时，可以直接输出0。因为无法走完一条路径（一条路径长度为$n+m-1$，因为是只能向下、向右走）。 那么实际数据范围很小，大概是$n+m-1 \le 10$左右吧。 这么小的范围很容易就可想到$dfs$。这里有两个优化，一个是如果搜到一半，发现剩下的颜色不够用了就直接$return$。还有一个就是利用颜色$A$与颜色$B$的先后次序问题，路径$AB$与路径$BA$并不是同一种方案，所以搜索时如果搜到是第一次时，就可以直接乘$now$就可以省去很多$dfs$。 代码很丑，勿喷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define MOD 1000000007</span><br><span class="line">using namespace std;//恶心的头文件</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;//读入优化</span><br><span class="line">inline void write(int zx)&#123;</span><br><span class="line">    if(zx&lt;0) zx=-zx,putchar(&#x27;-&#x27;);</span><br><span class="line">    if(zx&lt;10) putchar(zx+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(zx/10);</span><br><span class="line">        putchar(zx%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//输出优化</span><br><span class="line">int n,m,k,cnt[50],a[50][50],sum,f[30][30],ps,ans,vv;</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">    if(y==m+1)&#123;return dfs(x+1,1);&#125;</span><br><span class="line">    if(x==n+1) return 1;</span><br><span class="line">    int S=0,num=0,mar=0,res=0,las=0;</span><br><span class="line">    f[x][y]=f[x-1][y]f[x][y-1];</span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        if(!(f[x][y]&amp;(1&lt;&lt;i-1))) ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num&lt;n+m-x-y+1) return 0;//第一个优化</span><br><span class="line">    if(a[x][y]==0)&#123;</span><br><span class="line">        for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">            if(!(f[x][y]&amp;(1&lt;&lt;i-1)))&#123;</span><br><span class="line">                if(cnt[i]==0)&#123;</span><br><span class="line">                    if(mar) res+=las,res%=MOD;//第二个优化</span><br><span class="line">                    else&#123;</span><br><span class="line">                        mar=1;</span><br><span class="line">                        cnt[i]++;</span><br><span class="line">                        f[x][y]=1&lt;&lt;i-1;</span><br><span class="line">                        las=dfs(x,y+1);</span><br><span class="line">                        f[x][y]^=1&lt;&lt;i-1;</span><br><span class="line">                        cnt[i]--;</span><br><span class="line">                        res+=las;</span><br><span class="line">                        res%=MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                    continue ;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[i]++;</span><br><span class="line">                f[x][y]=1&lt;&lt;i-1;</span><br><span class="line">                res+=dfs(x,y+1);</span><br><span class="line">                f[x][y]^=1&lt;&lt;i-1;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                res%=MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(!(f[x][y]&amp;(1&lt;&lt;a[x][y]-1)))&#123;</span><br><span class="line">            f[x][y]=1&lt;&lt;a[x][y]-1;</span><br><span class="line">            res+=dfs(x,y+1);</span><br><span class="line">            f[x][y]^=1&lt;&lt;a[x][y]-1;</span><br><span class="line">            res%=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();k=read();</span><br><span class="line">    vv=n+m-1;</span><br><span class="line">    if(k&lt;vv)&#123;//开始先特判</span><br><span class="line">        puts(&quot;0&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            a[i][j]=read();</span><br><span class="line">            cnt[a[i][j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=dfs(1,1);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P1992 不想兜圈的老爷爷 题解</title>
      <link href="/2019/02/15/%E6%B4%9B%E8%B0%B7-p1992-%E4%B8%8D%E6%83%B3%E5%85%9C%E5%9C%88%E7%9A%84%E8%80%81%E7%88%B7%E7%88%B7-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/%E6%B4%9B%E8%B0%B7-p1992-%E4%B8%8D%E6%83%B3%E5%85%9C%E5%9C%88%E7%9A%84%E8%80%81%E7%88%B7%E7%88%B7-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一位年过古稀的老爷爷在乡间行走 而他不想兜圈子 因为那会使他昏沉 偶然路过小A发扬助人为乐优良传统 带上地图 想知道路况是否一定使他清醒 usqwedf补充：为了让欢乐赛充满欢乐 小A还想问你一些数学作业……</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>一行 n m k 表示乡间共有 n 个村庄 m 条道路 接下来 m 行 每行两个整数 x y 表示 村 x -&gt; 村 y 单向连通</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>第一行 输出 Yes&#x2F;No [清醒&#x2F;不清醒] 第二行 若为 Yes 输出 2^k对9997取模 反之 输出 k^2</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h3><p>3 3 3<br>1 2<br>2 3<br>3 1</p><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><p>No<br>9</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="[数据范围]"></a>[数据范围]</h3><p>对于70%的数据$1&lt;&#x3D;n&lt;&#x3D;100 1&lt;&#x3D;m&lt;&#x3D;1000 1&lt;&#x3D;k&lt;&#x3D;30$ 对于100%的数据$1&lt;&#x3D;n&lt;&#x3D;1000 1&lt;&#x3D;m&lt;&#x3D;10000 1&lt;&#x3D;k&lt;&#x3D;10^9$</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先明确这道题其实就是求是否有负环+快速幂。<br>然后可以使用spfa判断负环（每次加入队列时记录一下进队的次数，如果超过了总点数$n$，那么就是有负环）。<br>快速幂就不多说了吧。。。</p><h2 id="坑：输出-No-时，要求的-k-2-其实是不需要Mod的。"><a href="#坑：输出-No-时，要求的-k-2-其实是不需要Mod的。" class="headerlink" title="坑：输出$No$时，要求的$k^2$其实是不需要Mod的。"></a>坑：输出$No$时，要求的$k^2$其实是不需要Mod的。</h2><p>快速幂代码：（其实就是分类讨论的思想（手动滑稽））</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define ll long long</span><br><span class="line">ll Fp(ll x,ll y)&#123;</span><br><span class="line">    ll a=x,b=y,kk=9997;</span><br><span class="line">    ll result=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b%2==1) result = result*x%kk;</span><br><span class="line">        b/=2;</span><br><span class="line">        x=x*x%kk;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>废话不多说，上总代码（真的很短）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">ll n,m,k;</span><br><span class="line">vector&lt;int&gt; v[1010];</span><br><span class="line">ll vis[10000],dis[10000],tt[10000],ans;</span><br><span class="line">void spfa(ll x)&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(dis,63,sizeof(dis));</span><br><span class="line">    memset(tt,0,sizeof(tt));</span><br><span class="line">    dis[x]=0;vis[x]=1;</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        ll u=q.front();q.pop();vis[u]=0;</span><br><span class="line">        for(ll i=0;i&lt;v[u].size();i++)&#123;</span><br><span class="line">            if(dis[v[u][i]]&gt;dis[u]-1)&#123;</span><br><span class="line">                dis[v[u][i]]=dis[u]-1;</span><br><span class="line">                if(vis[v[u][i]]==0)&#123;</span><br><span class="line">                    vis[v[u][i]]=1;</span><br><span class="line">                    tt[v[u][i]]++;</span><br><span class="line">                    if(tt[v[u][i]]&gt;=n)&#123;</span><br><span class="line">                        ans=-1;</span><br><span class="line">                        return ;</span><br><span class="line">                    &#125;//判负环其实就是在这里，添加tt数组统计次数</span><br><span class="line">                    q.push(v[u][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll Fp(ll x,ll y)&#123;</span><br><span class="line">    ll a=x,b=y,kk=9997;</span><br><span class="line">    ll result=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b%2==1) result = result*x%kk;</span><br><span class="line">        b/=2;</span><br><span class="line">        x=x*x%kk;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;//快速幂</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    for(ll i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        ll x,y;scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);v[x].push_back(y);//读入</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        spfa(i);</span><br><span class="line">        if(ans==-1)&#123;</span><br><span class="line">            puts(&quot;No&quot;);</span><br><span class="line">            printf(&quot;%lld\n&quot;,k*k);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Yes&quot;);</span><br><span class="line">    printf(&quot;%lld\n&quot;,Fp(2,k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spfa </tag>
            
            <tag> 快速幂 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF2B The least round way 题解</title>
      <link href="/2019/02/15/cf2b-the-least-round-way-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/cf2b-the-least-round-way-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/pic/44868.png" alt="alt"></p><h3 id="都是泪呀。。。↑"><a href="#都是泪呀。。。↑" class="headerlink" title="都是泪呀。。。↑"></a>都是泪呀。。。↑</h3><h1 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.luogu.org/problemnew/show/CF2B">题目传送门</a></h1><h1 id="题意（直接复制了QWQ）"><a href="#题意（直接复制了QWQ）" class="headerlink" title="题意（直接复制了QWQ）"></a>题意（直接复制了QWQ）</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定由非负整数组成的$n \times n$的正方形矩阵，你需要寻找一条路径：<br>以左上角为起点,<br>每次只能向右或向下走,<br>以右下角为终点 并且，如果我们把沿路遇到的数进行相乘，积应当是最小“round”，换句话说，应当以最小数目的0的结尾.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 $(2 \leq n \leq 1000)$，$n$为矩阵的规模，接下来的$n$行包含矩阵的元素（不超过$10^9$的非负整数）.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行应包含最小尾0的个数，第二行打印出相应的路径（译注：D为下，R为右）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>楼下其实说得蛮清楚了，我主要就是说一下坑。。。<br>构成末尾是0的只能是$2^a$与$5^b$相乘，所得的0的个数为$min(a,b)$，所以，只要2、5分别dp一遍，取一下上与左的最小值就好啦。。。最后求路径时递归求一遍就好啦。。。</p><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h3 id="TLE的小朋友们看这里啦。。。"><a href="#TLE的小朋友们看这里啦。。。" class="headerlink" title="TLE的小朋友们看这里啦。。。"></a>TLE的小朋友们看这里啦。。。</h3><h3 id="TLE的小朋友们看这里啦。。。-1"><a href="#TLE的小朋友们看这里啦。。。-1" class="headerlink" title="TLE的小朋友们看这里啦。。。"></a>TLE的小朋友们看这里啦。。。</h3><h3 id="TLE的小朋友们看这里啦。。。-2"><a href="#TLE的小朋友们看这里啦。。。-2" class="headerlink" title="TLE的小朋友们看这里啦。。。"></a>TLE的小朋友们看这里啦。。。</h3><h4 id="（重要的事情说三遍）"><a href="#（重要的事情说三遍）" class="headerlink" title="（重要的事情说三遍）"></a>（重要的事情说三遍）</h4><p>此题特别会卡时。<br>比如说一开始预处理每个数是$2^a$与$2^b$时，需要将此数不间断地除下去，为什么呢？因为卡常数。。。也许时我RP的原因吧。。。卡了半天，终于卡过去了。。。</p><p>感谢$Seanq$提供hack数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 1 </span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>现已添加特判，第一个格子必须要走且第一个格子为0，使得结果为0的情况。<br>感谢$Liuyuzhuo$提供hack数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 0 </span><br></pre></td></tr></table></figure><p>现已添加特判，最后一个格子如果为0，结果为0。<br>具体详见代码：</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>（我知道你要看这个）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">//#define int long long </span><br><span class="line">using namespace std;//奇丑无比的码风</span><br><span class="line">inline int read()&#123;//cf数据加强，只能加读优了。</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,a[1010][1010],f[2][1010][1010],dp[2][1010][1010];</span><br><span class="line">int ans,qx,qy;</span><br><span class="line">bool ff;</span><br><span class="line">inline int get2(register int x,register int y)&#123;</span><br><span class="line">    if(a[x][y]==0)&#123;return 0;&#125; //特判</span><br><span class="line">    register int pt=0;</span><br><span class="line">    while(a[x][y]%2==0) ++pt,a[x][y]/=2; //卡常数</span><br><span class="line">    return pt;</span><br><span class="line">&#125;</span><br><span class="line">inline int get5(register int x,register int y)&#123;</span><br><span class="line">    if(a[x][y]==0)&#123;return 0;&#125; //特判</span><br><span class="line">    register int pt=0;</span><br><span class="line">    while(a[x][y]%5==0) ++pt,a[x][y]/=5; //卡常数</span><br><span class="line">    return pt;</span><br><span class="line">&#125;</span><br><span class="line">inline void print(register int k,register int x,register int y,register int first)&#123;</span><br><span class="line">    if(x==1&amp;&amp;y==1) ;</span><br><span class="line">    else if(x==1) print(k,x,y-1,0);</span><br><span class="line">    else if(y==1) print(k,x-1,y,1);</span><br><span class="line">    else if(dp[k][x][y]==dp[k][x-1][y]+f[k][x][y]) print(k,x-1,y,1);</span><br><span class="line">    else print(k,x,y-1,0);</span><br><span class="line">    if(first==6666) return ;</span><br><span class="line">    putchar(first==0?&#x27;R&#x27;:&#x27;D&#x27;); //一开始在n,n点时不需要输出</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">signed main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    ff=0;qx=0;qy=0;</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(register int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            a[i][j]=read();</span><br><span class="line">            if(a[i][j]==0)&#123;</span><br><span class="line">                qx=i;qy=j;</span><br><span class="line">                ff=1;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[1][1]==0a[n][n]==0)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        for(int i=1;i&lt;=n-1;i++) putchar(&#x27;D&#x27;);</span><br><span class="line">        for(int i=1;i&lt;=n-1;i++) putchar(&#x27;R&#x27;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    for(register int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(register int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            f[0][i][j]=get2(i,j);</span><br><span class="line">            f[1][i][j]=get5(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp,63,sizeof(dp));</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)</span><br><span class="line">        for(register int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[0][i][j]=min(dp[0][i][j],dp[0][i-1][j]);</span><br><span class="line">            dp[0][i][j]=min(dp[0][i][j],dp[0][i][j-1]);//从左格子与上格子中取最小值</span><br><span class="line">            if(i==1&amp;&amp;j==1) dp[0][i][j]=0;</span><br><span class="line">            dp[0][i][j]+=f[0][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    for(register int i=1;i&lt;=n;i++)</span><br><span class="line">        for(register int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[1][i][j]=min(dp[1][i][j],dp[1][i-1][j]);</span><br><span class="line">            dp[1][i][j]=min(dp[1][i][j],dp[1][i][j-1]);//从左格子与上格子中取最小值</span><br><span class="line">            if(i==1&amp;&amp;j==1) dp[1][i][j]=0;</span><br><span class="line">            dp[1][i][j]+=f[1][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    ans=min(dp[0][n][n],dp[1][n][n]);//初步ans</span><br><span class="line">    if(ans&gt;1&amp;&amp;ff==1)&#123; //特判有0的情况，如果有0，那么答案只有0或1.</span><br><span class="line">        putchar(&#x27;1&#x27;);</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">        for(register int i=1;i&lt;qx;i++) putchar(&#x27;D&#x27;);</span><br><span class="line">        for(register int i=1;i&lt;qy;i++) putchar(&#x27;R&#x27;);</span><br><span class="line">        for(register int i=qx;i&lt;n;i++) putchar(&#x27;D&#x27;);</span><br><span class="line">        for(register int i=qy;i&lt;n;i++) putchar(&#x27;R&#x27;);</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">        if(dp[0][n][n]&lt;dp[1][n][n]) print(0,n,n,6666); //分2、5讨论</span><br><span class="line">        else print(1,n,n,6666);</span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">3</span><br><span class="line">0 1 1 </span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4009 汽车加油行驶问题 题解</title>
      <link href="/2019/02/15/p4009-%E6%B1%BD%E8%BD%A6%E5%8A%A0%E6%B2%B9%E8%A1%8C%E9%A9%B6%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/p4009-%E6%B1%BD%E8%BD%A6%E5%8A%A0%E6%B2%B9%E8%A1%8C%E9%A9%B6%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>当然食用spfa啦。 但本蒟蒻不会分层。所以就二维spfa啦。 基本思路就是：一开始先把(1,1)点的状态扔进队列。 然后分类讨论 详细见代码 丑陋无比的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define mod 100003</span><br><span class="line">#define E 1000010</span><br><span class="line">using namespace std;//丑陋的头文件终于结束</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;//丑陋的读优</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//丑陋的输优</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">int n,k,a,b,c;</span><br><span class="line">int has[110][110];//有木有油箱</span><br><span class="line">int dis[110][110][15];//当前状态的最小花费</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,z;//状态记录，分别为x坐标、y坐标、还有多少油</span><br><span class="line">&#125;;</span><br><span class="line">struct queue&#123;</span><br><span class="line">    node val[10000000];int s,t;</span><br><span class="line">    void clean()&#123;</span><br><span class="line">        memset(val,0,sizeof(val));</span><br><span class="line">        s=0;t=0;//清空（貌似没有用到过）</span><br><span class="line">    &#125;</span><br><span class="line">    void push(node tmp)&#123;</span><br><span class="line">        ++t;</span><br><span class="line">        t%=10000000;</span><br><span class="line">        val[t]=tmp;//加入队尾</span><br><span class="line">    &#125;</span><br><span class="line">    inline node front()&#123;</span><br><span class="line">        return val[(s+1)%10000000];//循环队列，get队首</span><br><span class="line">    &#125;</span><br><span class="line">    void pop()&#123;</span><br><span class="line">        s++;//弹出</span><br><span class="line">        s%=10000000;//循环队列</span><br><span class="line">    &#125;</span><br><span class="line">    bool empty()&#123;//判断是否为空</span><br><span class="line">        if(s&gt;=t) return 1;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q;//队列</span><br><span class="line">node make(int x,int y,int z)&#123;</span><br><span class="line">    node pp;pp.x=x;pp.y=y;pp.z=z;</span><br><span class="line">    return pp;</span><br><span class="line">&#125;//方便快捷一些</span><br><span class="line">const int dx[]=&#123;0,0,1,-1&#125;,</span><br><span class="line">          dy[]=&#123;1,-1,0,0&#125;;//四个方向</span><br><span class="line">void print()&#123;</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            int ss=2e9;</span><br><span class="line">            for(int l=0;l&lt;=k;l++) ss=min(ss,dis[i][j][l]);</span><br><span class="line">            cout&lt;&lt;ss&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//调试输出函数</span><br><span class="line">void spfa()&#123;//spfa开始</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        node u=q.front();q.pop();</span><br><span class="line">        int x=u.x,y=u.y,K=u.z;//取出队首元素</span><br><span class="line">        if(K==0)&#123;//没油了</span><br><span class="line">            if(has[x][y]==1)&#123;//真棒！这里就有油箱</span><br><span class="line">                if(dis[x][y][K]+a&lt;dis[x][y][k])&#123;</span><br><span class="line">                    dis[x][y][k]=min(dis[x][y][k],dis[x][y][K]+a);//加油花费a</span><br><span class="line">                    q.push(make(x,y,k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;//这里没有油箱</span><br><span class="line">                if(dis[x][y][k]&gt;dis[x][y][K]+c+a)&#123;</span><br><span class="line">                    dis[x][y][k]=min(dis[x][y][k],dis[x][y][K]+c+a);//新建油箱花费c，加油花费a</span><br><span class="line">                    q.push(make(x,y,k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(has[x][y]==1)&#123;//坑，如果经过油箱必须加油</span><br><span class="line">                if(dis[x][y][K]+a&lt;dis[x][y][k])&#123;</span><br><span class="line">                    dis[x][y][k]=dis[x][y][K]+a;//愉快的花费a</span><br><span class="line">                    q.push(make(x,y,k));continue ;//因为加油，本次状态取消，直接退出</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">                int xx=x+dx[i],yy=y+dy[i];//四个方向</span><br><span class="line">                if(xx&gt;=1&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=1&amp;&amp;yy&lt;=n)&#123;//判断是否越界</span><br><span class="line">                    if(dis[xx][yy][K-1]&gt;dis[x][y][K]+((i==1i==3)?b:0))&#123;//如果往负方向花费b</span><br><span class="line">                        dis[xx][yy][K-1]=dis[x][y][K]+((i==1i==3)?b:0);//更新</span><br><span class="line">                        q.push(make(xx,yy,K-1));//保存状态</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">//        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();k=read();a=read();b=read();c=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            has[i][j]=read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//丑陋无比的读入</span><br><span class="line">    memset(dis,63,sizeof(dis));//初始化</span><br><span class="line">    dis[1][1][k]=0;//初始化</span><br><span class="line">    q.push(make(1,1,k));//塞入队列</span><br><span class="line">    spfa();//spfa</span><br><span class="line">    int ans=2e9;//取最小值前设定最大</span><br><span class="line">    for(int i=0;i&lt;=k;i++) ans=min(ans,dis[n][n][i]);//更新，因为终点有很多状态，取最小值</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;//输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spfa </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷P1331 海战 题解</title>
      <link href="/2019/02/15/%E6%B4%9B%E8%B0%B7p1331-%E6%B5%B7%E6%88%98-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/02/15/%E6%B4%9B%E8%B0%B7p1331-%E6%B5%B7%E6%88%98-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.luogu.org/problemnew/show/P1331">题目传送门</a></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="肯定食用dfs啦。。。"><a href="#肯定食用dfs啦。。。" class="headerlink" title="肯定食用dfs啦。。。"></a>肯定食用dfs啦。。。</h2><h2 id="但关键是两条船接触了怎么判断呢？？"><a href="#但关键是两条船接触了怎么判断呢？？" class="headerlink" title="但关键是两条船接触了怎么判断呢？？"></a>但关键是两条船接触了怎么判断呢？？</h2><h3 id="上图："><a href="#上图：" class="headerlink" title="上图："></a>上图：</h3><p><img src="https://cdn.luogu.org/upload/pic/46248.png"></p><h3 id="可以发现一下规律"><a href="#可以发现一下规律" class="headerlink" title="可以发现一下规律"></a>可以发现一下规律</h3><h3 id="当两条船接触时，必有一条直线连续穿过两条船"><a href="#当两条船接触时，必有一条直线连续穿过两条船" class="headerlink" title="当两条船接触时，必有一条直线连续穿过两条船"></a>当两条船接触时，必有一条直线连续穿过两条船</h3><h3 id="当一条船不与另一条船接触时，没有一条直线连续穿过两条船"><a href="#当一条船不与另一条船接触时，没有一条直线连续穿过两条船" class="headerlink" title="当一条船不与另一条船接触时，没有一条直线连续穿过两条船"></a>当一条船不与另一条船接触时，没有一条直线连续穿过两条船</h3><h2 id="所以只需要在每一次碰见一条船的一部分（一条船内每个点都要拓展一遍）时，将其沿右上、左下分别拓展一遍，边拓展边用sum前缀和check一遍就好啦。。。。"><a href="#所以只需要在每一次碰见一条船的一部分（一条船内每个点都要拓展一遍）时，将其沿右上、左下分别拓展一遍，边拓展边用sum前缀和check一遍就好啦。。。。" class="headerlink" title="所以只需要在每一次碰见一条船的一部分（一条船内每个点都要拓展一遍）时，将其沿右上、左下分别拓展一遍，边拓展边用sum前缀和check一遍就好啦。。。。"></a>所以只需要在每一次碰见一条船的一部分（一条船内每个点都要拓展一遍）时，将其沿右上、左下分别拓展一遍，边拓展边用sum前缀和check一遍就好啦。。。。</h2><h2 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//码风很丑，勿喷</span><br><span class="line">int k=1;</span><br><span class="line">while(a[i+k][j+k]==1) k++;//找到最左下的一个点（即连线段的另一个端点）</span><br><span class="line">--k;//别忘了再加回来</span><br><span class="line">int hh=sum[i+k][j+k]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1];//前缀和</span><br><span class="line">++k;</span><br><span class="line">if(hh&lt;k*k)&#123;//前缀和必须是k*k（一个正方形）</span><br><span class="line">    puts(&quot;Bad placement.&quot;);</span><br><span class="line">    return 0;//强制结束</span><br><span class="line">&#125;//沿右上</span><br><span class="line">k=1;//清零</span><br><span class="line">while(a[i+k][j-k]==1) ++k;//找到最左下的一个点（即连线段的另一个端点）</span><br><span class="line">--k;</span><br><span class="line">hh=sum[i+k][j]-sum[i-1][j]-sum[i+k][j-k-1]+sum[i-1][j-k-1];//前缀和</span><br><span class="line">++k;//别忘了再加回来</span><br><span class="line">if(hh&lt;k*k)&#123;//前缀和必须是k*k（一个正方形）</span><br><span class="line">    puts(&quot;Bad placement.&quot;);</span><br><span class="line">    return 0;//强制结束</span><br><span class="line">&#125;//沿左下</span><br></pre></td></tr></table></figure><h1 id="如果没有接触的话，可以直接dfs啦。。。代码简洁："><a href="#如果没有接触的话，可以直接dfs啦。。。代码简洁：" class="headerlink" title="如果没有接触的话，可以直接dfs啦。。。代码简洁："></a>如果没有接触的话，可以直接dfs啦。。。代码简洁：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">    if(vis[x][y]==1) return ;//如果已经拓展过直接退出</span><br><span class="line">    vis[x][y]=1;//标记</span><br><span class="line">    if(a[x][y+1]==1) dfs(x,y+1);//向四个方向拓展，标记为此船</span><br><span class="line">    if(a[x-1][y]==1) dfs(x-1,y);</span><br><span class="line">    if(a[x+1][y]==1) dfs(x+1,y);</span><br><span class="line">    if(a[x][y-1]==1) dfs(x,y-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有代码：（非常“简洁”。。。）"><a href="#所有代码：（非常“简洁”。。。）" class="headerlink" title="所有代码：（非常“简洁”。。。）"></a>所有代码：（非常“简洁”。。。）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int ret=0,f=1;char ch=getchar();</span><br><span class="line">    while (ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;) &#123;if (ch==&#x27;-&#x27;) f=-f;ch=getchar();&#125;</span><br><span class="line">    while (ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) ret=ret*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return ret*f;</span><br><span class="line">&#125;//丑陋的读优</span><br><span class="line">void write(int x)&#123;</span><br><span class="line">    if(x&lt;0)&#123;</span><br><span class="line">        putchar(&#x27;-&#x27;);</span><br><span class="line">        write(-x);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//丑陋的输优</span><br><span class="line">int n,m,a[1010][1010],sum[1010][1010];</span><br><span class="line">int vis[1010][1010],ans;</span><br><span class="line">void dfs(int x,int y)&#123;</span><br><span class="line">    if(vis[x][y]==1) return ;</span><br><span class="line">    vis[x][y]=1;</span><br><span class="line">    if(a[x][y+1]==1) dfs(x,y+1);</span><br><span class="line">    if(a[x-1][y]==1) dfs(x-1,y);</span><br><span class="line">    if(a[x+1][y]==1) dfs(x+1,y);</span><br><span class="line">    if(a[x][y-1]==1) dfs(x,y-1);</span><br><span class="line">&#125;//丑陋的dfs</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            char ch;cin&gt;&gt;ch;</span><br><span class="line">            if(ch==&#x27;#&#x27;) a[i][j]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//读入</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//前缀和</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(a[i][j]==1)&#123;</span><br><span class="line">                int k=1;</span><br><span class="line">                while(a[i+k][j+k]==1) k++;</span><br><span class="line">                --k;</span><br><span class="line">                int hh=sum[i+k][j+k]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1];</span><br><span class="line">                ++k;</span><br><span class="line">                if(hh&lt;k*k)&#123;</span><br><span class="line">                    puts(&quot;Bad placement.&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                k=1;</span><br><span class="line">                while(a[i+k][j-k]==1) ++k;</span><br><span class="line">                --k;</span><br><span class="line">                hh=sum[i+k][j]-sum[i-1][j]-sum[i+k][j-k-1]+sum[i-1][j-k-1];</span><br><span class="line">                ++k;</span><br><span class="line">                if(hh&lt;k*k)&#123;</span><br><span class="line">                    puts(&quot;Bad placement.&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//不想再提了。。。判断船只是否接触</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            if(a[i][j]==1&amp;&amp;vis[i][j]==0)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;//dfs统计答案</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;There are &quot;;</span><br><span class="line">    write(ans);</span><br><span class="line">    cout&lt;&lt;&quot; ships.&quot;;putchar(&#x27;\n&#x27;);//输出</span><br><span class="line">    return 0;//结束。。。。</span><br><span class="line">&#125;</span><br><span class="line">/*************************</span><br><span class="line">用时: 102ms / 内存: 5152KB</span><br><span class="line">代码：1.63KB C++</span><br><span class="line">By yuzhengxi</span><br><span class="line">**************************/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10082. 「一本通 3.3 例 1」Word Rings</title>
      <link href="/2019/02/15/10082-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-3-%E4%BE%8B-1%E3%80%8Dword-rings/"/>
      <url>/2019/02/15/10082-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-3-%E4%BE%8B-1%E3%80%8Dword-rings/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>每组数据读入一个n和n个字符串。定义前2个与末尾2个字母相同可以连接。问使这个环串的平均长度最大。求这个最大值。不存在输出No solution。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>平均值公式：<br>$$Average&#x3D;(E_1+E_2+…..+E_n)&#x2F;n$$ $$Average*n&#x3D;(E_1+E_2+…+E_n)$$ $$(E_1-Average)+(E_2-Average)+…+(E_n-Average)&#x3D;0$$ 那么可以二分答案：<br>$$(E_1-Ans)+(E_2-Ans)+…+(E_n-Ans)\geq0$$<br>然后瞎搞spfa。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 200010</span><br><span class="line">#define eps 1e-3</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;int&gt; q;</span><br><span class="line">//set&lt;int&gt; s;</span><br><span class="line">//priority_queue&lt;int&gt; q1;</span><br><span class="line">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;</span><br><span class="line">//list&lt;int&gt; l;</span><br><span class="line">//stack&lt;int&gt; s;</span><br><span class="line">int n;</span><br><span class="line">string str[100010];</span><br><span class="line">int fir[E],nxt[E],son[E],tot,cnt,Max;</span><br><span class="line">double w[E],dis[E],flag;</span><br><span class="line">int vis[E];</span><br><span class="line">int f[6666];</span><br><span class="line">void add(int x,int y,double z)&#123;++tot;son[tot]=y;nxt[tot]=fir[x];fir[x]=tot;w[tot]=z;&#125;</span><br><span class="line">void spfa(int s,int v,double mid)&#123;</span><br><span class="line">    if(flag==1) return ;</span><br><span class="line">    vis[s]=v;</span><br><span class="line">    for(int i=fir[s];i;i=nxt[i])&#123;</span><br><span class="line">        int to=son[i];</span><br><span class="line">        if(dis[s]+w[i]&gt;dis[to]+mid)&#123;</span><br><span class="line">            dis[to]=dis[s]+w[i]-mid;</span><br><span class="line">            if(dis[to]&gt;Max)&#123;</span><br><span class="line">                flag=1;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!vis[to]) spfa(to,v,mid);</span><br><span class="line">            if(flag) return ;</span><br><span class="line">            else if(vis[to]==v)&#123;</span><br><span class="line">                flag=1;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s]=0;</span><br><span class="line">&#125;</span><br><span class="line">bool check(double mid)&#123;</span><br><span class="line">    flag=0;</span><br><span class="line">    for(int i=0;i&lt;=cnt;i++) dis[i]=0.0;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        spfa(i,i,mid);</span><br><span class="line">        if(flag==1) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen(&quot;code.in&quot;,&quot;r&quot;,stdin);freopen(&quot;code.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    n=read();</span><br><span class="line">    while(n!=0)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++) cin&gt;&gt;str[i];</span><br><span class="line">        memset(fir,0,sizeof(fir));</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        tot=0;cnt=0;Max=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int len=str[i].length();</span><br><span class="line">            Max=max(Max,len);</span><br><span class="line">            int a=(str[i][0]-&#x27;a&#x27;)*26+str[i][1]-&#x27;a&#x27;;</span><br><span class="line">            int b=(str[i][len-2]-&#x27;a&#x27;)*26+str[i][len-1]-&#x27;a&#x27;;</span><br><span class="line">            if(!f[a]) f[a]=++cnt;</span><br><span class="line">            int A=f[a];</span><br><span class="line">            if(!f[b]) f[b]=++cnt;</span><br><span class="line">            int B=f[b];</span><br><span class="line">            add(A,B,(double)len);</span><br><span class="line">        &#125;</span><br><span class="line">        Max*=n;</span><br><span class="line">        double l=0,r=1000,ans=-1,mid;</span><br><span class="line">        while(l+eps&lt;r)&#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            if(check(mid)) l=mid,ans=mid;</span><br><span class="line">            else r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans!=-1) printf(&quot;%.2lf\n&quot;,ans);</span><br><span class="line">        else puts(&quot;No solution&quot;);</span><br><span class="line">        n=read();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10086. 「一本通 3.3 练习 3」Easy SSSP</title>
      <link href="/2019/02/15/10086-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-3-%E7%BB%83%E4%B9%A0-3%E3%80%8Deasy-sssp/"/>
      <url>/2019/02/15/10086-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-3-%E7%BB%83%E4%B9%A0-3%E3%80%8Deasy-sssp/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个图，问从源点到每个节点的最短路径分别是多少。 如果存在负权回路，只输出一行 -1；如果不存在负权回路，再求出一个点 S 到每个点的最短路的长度。如果 S 与这个点不连通，则输出 <code>NoPath</code>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然食用spfa啦。 先跑一下非源点的。万一数据卡你其他有环呢？ 然后再跑一次源点。得出Ans</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 2000010</span><br><span class="line">#define eps 1e-10</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll n,m;</span><br><span class="line">ll fir[E],nxt[E],son[E],tot;</span><br><span class="line">double w[E],Max;</span><br><span class="line">void add(ll x,ll y,double z)&#123;++tot;nxt[tot]=fir[x];son[tot]=y;fir[x]=tot;w[tot]=z;&#125;</span><br><span class="line">double dis[E],flag;</span><br><span class="line">ll vis[E];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int tt[E];</span><br><span class="line">ll spfa(ll s)&#123;</span><br><span class="line">    vis[s]=1;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(ll i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            ll to=son[i];</span><br><span class="line">            if(dis[u]+w[i]&lt;dis[to])&#123;</span><br><span class="line">                dis[to]=dis[u]+w[i];</span><br><span class="line">                tt[to]++;</span><br><span class="line">                if(tt[to]&gt;n+1)&#123;</span><br><span class="line">                    puts(&quot;-1&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[to]==0)&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">ll st[E];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll T=1,S;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        n=read();m=read();S=read();</span><br><span class="line">        tot=0;</span><br><span class="line">        memset(fir,0,sizeof(fir));</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            ll x=read(),y=read();double z;</span><br><span class="line">            cin&gt;&gt;z;</span><br><span class="line">            add(x,y,(double)z);</span><br><span class="line">        &#125;</span><br><span class="line">        for(ll i=0;i&lt;=n;i++) dis[i]=2e18;</span><br><span class="line">        dis[S]=0;</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        spfa(2);</span><br><span class="line">        for(ll i=0;i&lt;=n;i++) dis[i]=2e18;</span><br><span class="line">        dis[S]=0;</span><br><span class="line">        memset(vis,0,sizeof(vis));</span><br><span class="line">        spfa(S);</span><br><span class="line"></span><br><span class="line">        for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(i==S) puts(&quot;0&quot;);</span><br><span class="line">            else if(dis[i]&gt;=2e18) puts(&quot;NoPath&quot;);</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;%.0lf\n&quot;,dis[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10087. 「一本通 3.4 例 1」Intervals</title>
      <link href="/2019/02/15/10087-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E4%BE%8B-1%E3%80%8Dintervals/"/>
      <url>/2019/02/15/10087-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E4%BE%8B-1%E3%80%8Dintervals/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>从$0\sim 5\times 10^4$中选出尽量少的整数，使每个区间$ [a_i,b_i]$内都有至少 $c_i$个数被选出。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然食用spfa啦。 设s[k]表示0~k中至少选多少个整数。根据题意可得：<br>$$s[b_i]-s[a_i-1]\geq c_i$$ $$s[k]-s[k-1]\geq0$$ $$s[k]-s[k-1]\leq1$$ 也就是：<br>$$s[k-1]-s[k]\geq-1$$<br>那么跑一次最长路就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 2000010</span><br><span class="line">#define eps 1e-10</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll n,m;</span><br><span class="line">ll fir[E],nxt[E],son[E],tot;</span><br><span class="line">double w[E];</span><br><span class="line">void add(ll x,ll y,double z)&#123;++tot;nxt[tot]=fir[x];son[tot]=y;fir[x]=tot;w[tot]=z;&#125;</span><br><span class="line">double dis[E],flag;</span><br><span class="line">ll vis[E];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int tt[E];</span><br><span class="line">ll spfa(ll s)&#123;</span><br><span class="line">    vis[s]=1;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(ll i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            ll to=son[i];</span><br><span class="line">            if(dis[u]+w[i]&gt;dis[to])&#123;</span><br><span class="line">                dis[to]=dis[u]+w[i];</span><br><span class="line">                tt[to]++;</span><br><span class="line">                if(tt[to]&gt;n+1)&#123;</span><br><span class="line">                    puts(&quot;-1&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[to]==0)&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">ll st[E],Min,Max;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    Max=-1;Min=2e9;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x=read(),y=read(),z=read();</span><br><span class="line">        add(x-1,y,z);</span><br><span class="line">        Max=max(Max,y);</span><br><span class="line">        Min=min(Min,x-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=Min;i&lt;=Max;i++)&#123;</span><br><span class="line">        add(i,i+1,0);</span><br><span class="line">        add(i+1,i,-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=Min;i&lt;=Max;i++) dis[i]=-2e9;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    dis[Min]=0;</span><br><span class="line">    spfa(Min);</span><br><span class="line">    printf(&quot;%.0lf\n&quot;,dis[Max]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10088. 「一本通 3.4 例 2」出纳员问题</title>
      <link href="/2019/02/15/10088-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E4%BE%8B-2%E3%80%8D%E5%87%BA%E7%BA%B3%E5%91%98%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/15/10088-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E4%BE%8B-2%E3%80%8D%E5%87%BA%E7%BA%B3%E5%91%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>R(0)、R(1)、R(2)…R(23)表示第x个时刻需要R(x)个出纳员，有n个出纳员申请工作，第i个出纳员从t_i时刻开始工作8小时，问至少需要多少出纳员？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$x[i]$表示第$i$时刻实际上需要雇佣$x[i]$人，$r[i]$为第$i$时刻至少需要$r[i]$个人。<br>$$x[i-7]+x[i-6]+x[i-5]+x[i-4]+x[i-3]+x[i-2]+x[i-1]+x[i]\geq r[i]$$<br>设$s[i]&#x3D;x[1]+x[2]+x[3]+…+x[i]$，可得：<br>$$s[i]-s[i-1]\geq0$$ $$s[i-1]-s[i]\geq-num[i]$$ $$s[i]-s[i-8]\geq r[i]$$ $$s[i]-s[i+16]\geq r[i]-s[23]$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 2000010</span><br><span class="line">#define eps 1e-10</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll n,m;</span><br><span class="line">ll fir[E],nxt[E],son[E],tot;</span><br><span class="line">int w[E];</span><br><span class="line">void add(ll x,ll y,ll z)&#123;++tot;nxt[tot]=fir[x];son[tot]=y;fir[x]=tot;w[tot]=z;&#125;</span><br><span class="line">int dis[E],flag;</span><br><span class="line">ll vis[E];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int tt[E];</span><br><span class="line">ll spfa(ll s)&#123;</span><br><span class="line">    memset(dis,63,sizeof(dis));</span><br><span class="line">    memset(tt,0,sizeof(tt));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    dis[24]=0;</span><br><span class="line">    vis[24]=1;</span><br><span class="line">    q.push(24);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();q.pop();</span><br><span class="line">        for(ll i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            ll to=son[i];</span><br><span class="line">            if(dis[u]+w[i]&lt;dis[to])&#123;</span><br><span class="line">                dis[to]=dis[u]+w[i];</span><br><span class="line">                tt[to]++;</span><br><span class="line">                if(tt[to]&gt;n+1)&#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if(vis[to]==0)&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    q.push(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[0]==-s;</span><br><span class="line">&#125;</span><br><span class="line">ll T,r[E],Min,Max,s[E],num[E];</span><br><span class="line">void work(int x)&#123;</span><br><span class="line">    memset(fir,0,sizeof(fir));tot=0;</span><br><span class="line">    for(register int i=1;i&lt;=24;i++) add(i,i-1,0),add(i-1,i,num[i]);</span><br><span class="line">    for(register int i=8;i&lt;=24;i++) add(i,i-8,-r[i]);</span><br><span class="line">    for(register int j=1;j&lt;=7;j++) add(j,j+16,x-r[j]);</span><br><span class="line">    add(24,0,-x);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    T=read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        for(int i=1;i&lt;=24;i++)&#123;</span><br><span class="line">            r[i]=read();num[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        n=read();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int t=read();t++;</span><br><span class="line">            num[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int l=0,r=n,ans=2e9;</span><br><span class="line">        while(l&lt;=r)&#123;</span><br><span class="line">            int mid=(l+r)/2;</span><br><span class="line">            work(mid);</span><br><span class="line">            if(spfa(mid)) ans=mid,r=mid-1;</span><br><span class="line">            else l=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==2e9) puts(&quot;No Solution&quot;);</span><br><span class="line">        else write(ans),putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10089. 「一本通 3.4 练习 1」糖果</title>
      <link href="/2019/02/15/10089-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%B3%96%E6%9E%9C/"/>
      <url>/2019/02/15/10089-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>满足条件： 如果 X&#x3D;1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的精果一样多。 如果 X&#x3D;2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。 如果 X&#x3D;3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。 如果 X&#x3D;4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。 如果 X&#x3D;5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。 求至少需要准备的糖果数？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果 X&#x3D;1<br>$$B&#x3D;A$$<br>如果 X&#x3D;2<br>$$B+1\ge A$$<br>如果 X&#x3D;3<br>$$A\ge B$$<br>如果 X&#x3D;4<br>$$A-1\ge B$$<br>如果 X&#x3D;5<br>$$B \ge A$$<br>那么就好了嘛：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 300010</span><br><span class="line">#define eps 1e-10</span><br><span class="line">#define ll long long</span><br><span class="line">#pragma GCC optimize(2)</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll n,k;</span><br><span class="line">ll fir[E],nxt[E],son[E],w[E],tot,inf,ans;</span><br><span class="line">inline void add(register ll x,register ll y,register ll z)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">&#125;</span><br><span class="line">ll dis[E],vis[E],tt[E];</span><br><span class="line">deque&lt;ll&gt; q;</span><br><span class="line">inline void spfa()&#123;</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    memset(tt,0,sizeof(tt));</span><br><span class="line">    memset(vis,0,sizeof(vis));inf=dis[0];</span><br><span class="line">    dis[0]=0;vis[0]=1;</span><br><span class="line">    while(!q.empty()) q.pop_front();</span><br><span class="line">    q.push_back(0);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        register ll u=q.front();q.pop_front();</span><br><span class="line">        vis[u]=0;</span><br><span class="line">        for(register ll i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            register ll to=son[i];</span><br><span class="line">            if(dis[to]&lt;dis[u]+w[i])&#123;</span><br><span class="line">                tt[to]++;</span><br><span class="line">                dis[to]=dis[u]+w[i];</span><br><span class="line">                if(tt[to]&gt;n+1)&#123;</span><br><span class="line">                    puts(&quot;-1&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(!vis[to])&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    if(!q.empty()&amp;&amp;dis[to]&lt;dis[q.front()]) q.push_front(to);</span><br><span class="line">                    else q.push_back(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();k=read();</span><br><span class="line">    for(register ll i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        ll x=read(),a=read(),b=read();</span><br><span class="line">        if(a==b&amp;&amp;(x==2x==4))&#123;</span><br><span class="line">            puts(&quot;-1&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x==1) add(a,b,0),add(b,a,0);</span><br><span class="line">        if(x==2) add(a,b,1);</span><br><span class="line">        if(x==3) add(b,a,0);</span><br><span class="line">        if(x==4) add(b,a,1);</span><br><span class="line">        if(x==5) add(a,b,0);</span><br><span class="line">    &#125;</span><br><span class="line">    for(register ll i=1;i&lt;=n;i++) add(0,i,1);</span><br><span class="line">    spfa();</span><br><span class="line">    for(register ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10090. 「一本通 3.4 练习 2」布局 Layout</title>
      <link href="/2019/02/15/10090-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E5%B8%83%E5%B1%80-layout/"/>
      <url>/2019/02/15/10090-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-4-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E5%B8%83%E5%B1%80-layout/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有些奶牛是好基友，它们希望彼此之间的距离小于等于某个数。有些奶牛是情敌，它们希望彼此之间的距离大于等于某个数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果两只奶牛是好基友，那么:<br>$$A-B\leq D$$<br>如果两只奶牛是情敌，那么:<br>$$A-B\ge D$$<br>即:<br>$$D\leq A-B$$<br>也就是:<br>$$B-A\leq -D$$<br>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 300010</span><br><span class="line">#define eps 1e-10</span><br><span class="line">#define ll long long</span><br><span class="line">#pragma GCC optimize(2)</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//queue&lt;ll&gt; q;</span><br><span class="line">//set&lt;ll&gt; s;</span><br><span class="line">//priority_queue&lt;ll&gt; q1;</span><br><span class="line">//priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q2;</span><br><span class="line">//list&lt;ll&gt; l;</span><br><span class="line">//stack&lt;ll&gt; s;</span><br><span class="line">ll n,k;</span><br><span class="line">ll fir[E],nxt[E],son[E],w[E],tot,inf,ans;</span><br><span class="line">inline void add(register ll x,register ll y,register ll z)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">&#125;</span><br><span class="line">ll dis[E],vis[E],tt[E];</span><br><span class="line">deque&lt;ll&gt; q;</span><br><span class="line">inline void spfa(int s)&#123;</span><br><span class="line">    memset(dis,63,sizeof(dis));</span><br><span class="line">    memset(tt,0,sizeof(tt));</span><br><span class="line">    memset(vis,0,sizeof(vis));inf=dis[0];</span><br><span class="line">    dis[s]=0;vis[s]=1;</span><br><span class="line">    while(!q.empty()) q.pop_front();</span><br><span class="line">    q.push_back(s);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        register ll u=q.front();q.pop_front();</span><br><span class="line">        vis[u]=0;</span><br><span class="line">        for(register ll i=fir[u];i;i=nxt[i])&#123;</span><br><span class="line">            register ll to=son[i];</span><br><span class="line">            if(dis[to]&gt;dis[u]+w[i])&#123;</span><br><span class="line">                tt[to]++;</span><br><span class="line">                dis[to]=dis[u]+w[i];</span><br><span class="line">                if(tt[to]&gt;n+1)&#123;</span><br><span class="line">                    puts(&quot;-1&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">                if(!vis[to])&#123;</span><br><span class="line">                    vis[to]=1;</span><br><span class="line">                    if(!q.empty()&amp;&amp;dis[to]&lt;dis[q.front()]) q.push_front(to);</span><br><span class="line">                    else q.push_back(to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int k1,k2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();k1=read();k2=read();</span><br><span class="line">    for(register ll i=1;i&lt;=k1;i++)&#123;</span><br><span class="line">        ll x=read(),y=read(),z=read();</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    for(register ll i=1;i&lt;=k2;i++)&#123;</span><br><span class="line">        ll x=read(),y=read(),z=read();</span><br><span class="line">        add(y,x,-z);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(1);</span><br><span class="line">    ans=dis[n];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) spfa(i);</span><br><span class="line">    if(ans&gt;=inf) puts(&quot;-2&quot;);</span><br><span class="line">    else write(ans),putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> spfa </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10117. 「一本通 4.1 练习 2」简单题</title>
      <link href="/2019/02/15/10117-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-1-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E7%AE%80%E5%8D%95%E9%A2%98/"/>
      <url>/2019/02/15/10117-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-1-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E7%AE%80%E5%8D%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个 $n$ 个元素的数组，每个元素初始均为 $0$。有 $m$ 条指令，要么让其中一段连续序列数字反转——$0$ 变 $1$，$1$ 变 $0$（操作 $1$），要么询问某个元素的值（操作 $2$）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然是树状数组啦。。。 这里介绍C++的一大利器——位运算。 <code>&amp;</code>在C++里叫做与运算。应该差不多吧。。大概就是这样的：（按一个个位运算）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&amp;1=1</span><br><span class="line">0&amp;1=0</span><br><span class="line">1&amp;0=0</span><br><span class="line">0&amp;0=0</span><br></pre></td></tr></table></figure><p>在C++里叫或运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01=1</span><br><span class="line">10=1</span><br><span class="line">11=1</span><br><span class="line">00=0</span><br></pre></td></tr></table></figure><p><code>^</code>在C++里叫异或(xor)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0^0=0</span><br><span class="line">1^0=1</span><br><span class="line">0^1=1</span><br><span class="line">1^1=0</span><br></pre></td></tr></table></figure><p><code>~</code>在C++里叫取反 顾名思义。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~1=0</span><br><span class="line">~0=1</span><br></pre></td></tr></table></figure><p>然后你就会发现这道题可以用C++的异或+树状数组解决。 利用树状数组，做一个异或前缀和。然后在输出时异或一遍就好了。 （这道题的1操作就相当于异或1） （然而我们知道x xor 1 xor 1还是等于x） （所以对于每个1操作只需要先把l之前的xor 1，然后r+1之前的xor 1） （对于每个2操作只需要把前面统统xor一遍） 你就完美的解决了这道题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;//丑陋无比的头文件终于结束</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;//读入</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;//输出</span><br><span class="line">int n,k;</span><br><span class="line">int c[500010];//不解释</span><br><span class="line">void add(int x,int y)&#123;//修改</span><br><span class="line">    for(int i=x;i&lt;=n;i+=i&amp;(-i))&#123;</span><br><span class="line">        c[i]^=y;//异或前缀和</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int getsum(int x)&#123;//询问</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=x;i;i-=i&amp;(-i))&#123;</span><br><span class="line">        sum^=c[i];//询问异或</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;//返回啊</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();k=read();//读入</span><br><span class="line">    for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">        char A;cin&gt;&gt;A;</span><br><span class="line">        int m,p;</span><br><span class="line">        if(A==&#x27;1&#x27;)&#123;//操作1</span><br><span class="line">            m=read();p=read();</span><br><span class="line">            add(m,1);//先将l之前的xor 1</span><br><span class="line">            add(p+1,1);//然后把r+1之前的xor 1</span><br><span class="line">            //那么l之前的数统统 xor 1 xor 1，抵消</span><br><span class="line">        &#125;else if(A==&#x27;2&#x27;)&#123;</span><br><span class="line">            m=read();</span><br><span class="line">            write(getsum(m));putchar(&#x27;\n&#x27;);//询问输出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;//结束了。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10121. 「一本通 4.2 例 3」与众不同</title>
      <link href="/2019/02/15/10121-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-2-%E4%BE%8B-3%E3%80%8D%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C/"/>
      <url>/2019/02/15/10121-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-2-%E4%BE%8B-3%E3%80%8D%E4%B8%8E%E4%BC%97%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义完美序列：一段连续的序列满足序列中的数互不相同。 想知道区间 $[L,R]$ 之间最长的完美序列长度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$las[x]$表示盈利$x$最近出现位置。 设$st[i]$表示以第$i$个数结尾的最长完美序列的起始位置。<br>$$st[i]&#x3D;max(st[i-1],las[a[i]]+1)$$<br>设$f[i]$表示以第$i$个数结尾的最长完美序列的长度<br>$$f[i]&#x3D;i-st[i]+1$$<br>由$st$的递推式可知，$st$的值是一个非递减的序列。 对于一个询问区间$[l_i,r_i]$，该区间内的$st$值可能会有两种情况：</p><ul><li>左边一部分的$st$值不在区间内，即$&lt;l_i$</li><li>右边一部分的$st$值不在区间内，即$\ge l_i$</li></ul><p>由于$st$的值具有单调性，所以这个边界可以通过二分得到。设求出的边界为$mid$_i，可得：<br>$$st[l_i…mid_i-1]&lt;l_i$$ $$st[mid_i…r_i]\ge l_i$$ 那么整个区间$[l_i,r_i]$的最长完美序列的长度可以分两部分来求。</p><ul><li>左边：很显然为$mid_i-l_i$</li><li>右边：$MAX(m_i…r_i)$</li></ul><p>所以右边的长度要使用ST表，即RMQ来求。 整个问题的时间复杂度：<br>$$O((M+N) \times logN)$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">const int N=2e5+5,M=1e6;</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    char ch=getchar();ll res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll zx)&#123;</span><br><span class="line">    if(zx&lt;0) zx=-zx,putchar(&#x27;-&#x27;);</span><br><span class="line">    if(zx&lt;10) putchar(zx+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(zx/10);</span><br><span class="line">        putchar(zx%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,f[N][20],st[N],las[M&lt;&lt;1];</span><br><span class="line">void ST()&#123;</span><br><span class="line">    for(ll j=1;(1&lt;&lt;j)&lt;=n;j++)&#123;</span><br><span class="line">        for(ll i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">            f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll RMQ(ll l,ll r)&#123;</span><br><span class="line">    ll k=0;</span><br><span class="line">    while((1&lt;&lt;(k+1))&lt;=r-l+1) k++;</span><br><span class="line">    return max(f[l][k],f[r-(1&lt;&lt;k)+1][k]);</span><br><span class="line">&#125;</span><br><span class="line">ll find(ll l,ll r)&#123;</span><br><span class="line">    if(st[l]==l) return l;</span><br><span class="line">    if(st[r]&lt;l) return r+1;</span><br><span class="line">    int L=l,R=r;</span><br><span class="line">    while(L&lt;=R)&#123;</span><br><span class="line">        int m=L+R&gt;&gt;1;</span><br><span class="line">        if(st[m]&lt;l) L=m+1;</span><br><span class="line">        else R=m-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x=read();</span><br><span class="line">        st[i]=max(st[i-1],las[x+M]+1);</span><br><span class="line">        f[i][0]=i-st[i]+1;</span><br><span class="line">        las[x+M]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ST();</span><br><span class="line">    for(ll i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        ll L,R;</span><br><span class="line">        L=read();R=read();L++;R++;</span><br><span class="line">        ll mid=find(L,R),ans=0,tmp;</span><br><span class="line">        if(mid&gt;L) ans=mid-L;</span><br><span class="line">        if(mid&lt;=R)&#123;</span><br><span class="line">            tmp=RMQ(mid,R);</span><br><span class="line">            ans=max(ans,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2597. 「NOIP2011」选择客栈</title>
      <link href="/2019/02/15/2597-%E3%80%8Cnoip2011%E3%80%8D%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88/"/>
      <url>/2019/02/15/2597-%E3%80%8Cnoip2011%E3%80%8D%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个客栈，每个客栈都配有咖啡馆。有两名旅客想住在同色调的客栈中，又想在两客栈之间的咖啡馆中小聚，咖啡馆的价钱不能高于$p$。 对于 $100\%$ 的数据，有 $2\leq n\leq2\times 10^6$，$0&lt;k\leq10^4$ ，$0\leq p\leq100$，$0\leq$ 最低消费 $\leq100$ 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$n$的范围那么大，$k$的范围那么小。那么暴力吧。 设$h_i$表示目前颜色$i$的客栈数量，$las_i$表示最近的颜色为$i$的客栈的编号。 然后$O(n)$扫一遍就好了啊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">const int N=2e5+5,M=1e6;</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    char ch=getchar();ll res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll zx)&#123;</span><br><span class="line">    if(zx&lt;0) zx=-zx,putchar(&#x27;-&#x27;);</span><br><span class="line">    if(zx&lt;10) putchar(zx+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(zx/10);</span><br><span class="line">        putchar(zx%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,color,price,now,las[N],h[N],sum[N],ans,p;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();p=read();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        color=read(),price=read();//读入</span><br><span class="line">        if(price&lt;=p) now=i;//价钱要小于或等于p</span><br><span class="line">        if(now&gt;=las[color]) sum[color]=h[color];//如果比上一个颜色相同的近，直接加上方案数</span><br><span class="line">        ans+=sum[color];//更新ANS</span><br><span class="line">        h[color]++;las[color]=i;//更新LAS和H</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);//输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10128. 「一本通 4.3 练习 2」花神游历各国</title>
      <link href="/2019/02/15/10128-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-3-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/"/>
      <url>/2019/02/15/10128-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-4-3-%E7%BB%83%E4%B9%A0-2%E3%80%8D%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>每一次旅行中，花神会选择一条旅游路线，它在那一串国家中是连续的一段，这次旅行带来的开心值是这些国家的喜欢度的总和，当然花神对这些国家的喜欢程序并不是恒定的，有时会突然对某些国家产生反感，使他对这些国家的喜欢度 $\delta$ 变为 $\sqrt \delta$（可能是花神虐爆了那些国家的 OI，从而感到乏味）。 现在给出花神每次的旅行路线，以及开心度的变化，请求出花神每次旅行的开心值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>为了使时间复杂度降低，我们可以发现：$\sqrt 1&#x3D;1$所以，最大数字$10^9$操作较少次数便能到$1$。所以在操作前判断一下，如果区间内都是$1$即可跳过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define MAXNUM 1000000*4+10</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll l,r,lef,rig;</span><br><span class="line">    ll val,Max;</span><br><span class="line">&#125;tree[210000];</span><br><span class="line">ll a[110000],len,n,m;</span><br><span class="line">void build(ll l,ll r)&#123;</span><br><span class="line">    ll root=++len;</span><br><span class="line">    tree[root].l=l;tree[root].r=r;tree[root].lef=tree[root].rig=-1;</span><br><span class="line">    if(l==r)tree[root].val=tree[root].Max=a[l];</span><br><span class="line">    else&#123;</span><br><span class="line">        ll mid=(l+r)/2;</span><br><span class="line">        ll lef=tree[root].lef=len+1;build(l,mid);</span><br><span class="line">        ll rig=tree[root].rig=len+1;build(mid+1,r);</span><br><span class="line">        tree[root].val=tree[lef].val+tree[rig].val;</span><br><span class="line">        tree[root].Max=max(tree[lef].Max,tree[rig].Max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void update(ll root,ll l,ll r)&#123;</span><br><span class="line">    if(tree[root].Max&lt;2) return ;</span><br><span class="line">    if(tree[root].l==tree[root].r)&#123;tree[root].val=sqrt(tree[root].val);tree[root].Max=tree[root].val;return ;&#125;</span><br><span class="line">    ll lef=tree[root].lef,rig=tree[root].rig,mid=(tree[root].l+tree[root].r)/2;</span><br><span class="line">    if(r&lt;=mid) update(lef,l,r);</span><br><span class="line">    else if(mid&lt;l) update(rig,l,r);</span><br><span class="line">    else update(lef,l,mid),update(rig,mid+1,r);</span><br><span class="line">    tree[root].val=tree[lef].val+tree[rig].val;</span><br><span class="line">    tree[root].Max=max(tree[lef].Max,tree[rig].Max);</span><br><span class="line">&#125;</span><br><span class="line">ll query(ll root,ll l,ll r)&#123;</span><br><span class="line">    if(tree[root].l&gt;=l&amp;&amp;tree[root].r&lt;=r) return tree[root].val;</span><br><span class="line">    ll lef=tree[root].lef,rig=tree[root].rig,mid=(tree[root].l+tree[root].r)/2;</span><br><span class="line">    if(r&lt;=mid) return query(lef,l,r);</span><br><span class="line">    else if(mid&lt;l) return query(rig,l,r);</span><br><span class="line">    else return query(lef,l,mid)+query(rig,mid+1,r);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    build(1,n);</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        char s;cin&gt;&gt;s;</span><br><span class="line">        if(s==&#x27;2&#x27;)&#123;</span><br><span class="line">            ll x,y;scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">            update(1,x,y);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ll x,y;scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">            printf(&quot;%lld\n&quot;,query(1,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10202. 「一本通 6.2 练习 5」樱花</title>
      <link href="/2019/02/15/10202-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-2-%E7%BB%83%E4%B9%A0-5%E3%80%8D%E6%A8%B1%E8%8A%B1/"/>
      <url>/2019/02/15/10202-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-2-%E7%BB%83%E4%B9%A0-5%E3%80%8D%E6%A8%B1%E8%8A%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求不定方程：<br>$$\frac{1}{x}+\frac{1}{y}&#x3D;\frac{1}{n!}$$<br>的正整数解 $(x,y)$ 的数目。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$\frac{1}{x}+\frac{1}{y}&#x3D;\frac{1}{n!}$$ $$\frac{y}{xy}+\frac{x}{xy}&#x3D;\frac{1}{n!}$$ $$\frac{x+y}{xy}&#x3D;\frac{1}{n!}$$ $$n!\times(x+y)&#x3D;xy$$ $$x+y&#x3D;\frac{xy}{n!}$$ $$(x-n!)*(y-n!)&#x3D;(n!)^2$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long f[1000010],v[1000010],tot,ans[1000010],Ans=0;</span><br><span class="line">long long n;</span><br><span class="line">void prime()&#123;</span><br><span class="line">    for(long long i=2;i&lt;=1000000;i++)&#123;</span><br><span class="line">        if(!v[i]) v[i]=i,f[++tot]=i;</span><br><span class="line">        for(long long j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            if(f[j]&gt;v[i]f[j]&gt;1000000/i) break;</span><br><span class="line">            v[i*f[j]]=f[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    prime();long long tmp=n;</span><br><span class="line">    memset(ans,0,sizeof(ans));Ans=1;</span><br><span class="line">    for(int i=1;f[i]&lt;=n&amp;&amp;i&lt;=tot;i++)&#123;</span><br><span class="line">        long long tmp=0;</span><br><span class="line">        for(long long j=f[i];j&lt;=n;j*=f[i])&#123;</span><br><span class="line">            tmp+=n/j;</span><br><span class="line">            tmp%=1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        Ans*=2*tmp+1;</span><br><span class="line">        Ans%=1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10147. 「一本通 5.1 例 1」石子合并</title>
      <link href="/2019/02/15/10147-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E4%BE%8B-1%E3%80%8D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
      <url>/2019/02/15/10147-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E4%BE%8B-1%E3%80%8D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>将 $n$ 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 $n$ 及每堆的石子数，并进行如下计算：</p><ol><li>选择一种合并石子的方案，使得做 $n-1$ 次合并得分总和最大。</li><li>选择一种合并石子的方案，使得做 $n-1$ 次合并得分总和最小。</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>DP水过去。。。</p><h3 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h3><p>设$f[i][j]$表示区间$[i,j]$得分的最大值。 很容易可以想到：<br>$$f[i][j]&#x3D;max(f[i][k]+f[k+1][j]+dist(i,j)))$$ $$dist(i,j)&#x3D;a[i]+a[i+1]+…+a[j-1]+a[j]$$ 所以我们设$sum[i]&#x3D;a[1]+a[2]+…+a[i-1]+a[i]$ 可得：<br>$$sum[i]&#x3D;sum[i-1]+a[i]$$<br>那么：<br>$$f[i][j]&#x3D;max(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1])$$<br>但是，仔细读题，发现是环。。。! 所以我们将环转换成链，即将$a$数组往后$n$个单位复制一遍。</p><h3 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h3><p>与最大值差不多。改一个符号$max——&gt;min$。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define E 200010</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,f[210][210],a[210],sum[210],ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) a[i]=read(),a[i+n]=a[i];</span><br><span class="line">    for(int i=1;i&lt;=n*2;i++) sum[i]=sum[i-1]+a[i];</span><br><span class="line">    memset(f,63,sizeof(f));</span><br><span class="line">    for(int i=1;i&lt;=n*2;i++) f[i][i]=0;</span><br><span class="line">    for(int L=2;L&lt;=n;L++)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n*2-L+1;i++)&#123;</span><br><span class="line">            int j=i+L-1;</span><br><span class="line">            for(int k=i;k&lt;j;k++)&#123;</span><br><span class="line">                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=2e9;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=min(ans,f[i][i+n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    memset(f,0,sizeof(f));</span><br><span class="line">    for(int i=1;i&lt;=n*2;i++) f[i][i]=0;</span><br><span class="line">    for(int L=2;L&lt;=n;L++)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n*2-L+1;i++)&#123;</span><br><span class="line">            int j=i+L-1;</span><br><span class="line">            for(int k=i;k&lt;j;k++)&#123;</span><br><span class="line">                f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=max(ans,f[i][i+n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    write(ans);putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10153. 「一本通 5.2 例 1」二叉苹果树</title>
      <link href="/2019/02/15/10153-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E4%BE%8B-1%E3%80%8D%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/"/>
      <url>/2019/02/15/10153-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-2-%E4%BE%8B-1%E3%80%8D%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵二叉苹果树，如果数字有分叉，一定是分两叉，即没有只有一个儿子的节点。这棵树共 $N$ 个节点，标号 $1$ 至 $N$，树根编号一定为 $1$。</p><p><img src="https://i.loli.net/2018/08/01/5b61725185fd2.png" alt="tree.png"></p><p>我们用一根树枝两端连接的节点编号描述一根树枝的位置。一棵有四根树枝的苹果树，因为树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设$f[i][j]$表示以i为根节点，保留j个节点的最大苹果数量 $$f[i][j]&#x3D;max{f[l[i]][k]+f[r[i]][j-k-1]+a[i]}(0&lt;&#x3D;k&lt;&#x3D;j-1)$$ $$f[i][j]&#x3D;0(0&lt;i&lt;&#x3D;n,0&lt;&#x3D;j&lt;&#x3D;Q+1)$$ $$f[i][j]&#x3D;a<a href="j!=0,l%5Bi%5D==0,r%5Bi%5D==0">i</a>$$ $$Answer:f[1][Q+1]$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    char ch=getchar();ll res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,Q,f[110][110],a[110],l[110],r[110],mp[110][110];</span><br><span class="line">void MakeTree(int x)&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(mp[x][i]!=-1)&#123;</span><br><span class="line">            l[x]=i;a[i]=mp[x][i];</span><br><span class="line">            mp[x][i]=mp[i][x]=-1;</span><br><span class="line">            MakeTree(i);</span><br><span class="line">            break; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//Make Left Son</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(mp[x][i]!=-1)&#123;</span><br><span class="line">            r[x]=i;a[i]=mp[x][i];</span><br><span class="line">            mp[x][i]=mp[i][x]=-1;</span><br><span class="line">            MakeTree(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//Make Right Son</span><br><span class="line">&#125;</span><br><span class="line">int DP(int x,int j)&#123;</span><br><span class="line"></span><br><span class="line">    if(j==0)&#123;f[x][j]=0;return 0;&#125;</span><br><span class="line">    if((!l[x])&amp;&amp;(!r[x]))&#123;f[x][j]=a[x];return a[x];&#125;</span><br><span class="line">    if(f[x][j]&gt;0) return f[x][j];</span><br><span class="line">    for(int k=0;k&lt;j;k++) f[x][j]=max(f[x][j],DP(l[x],k)+DP(r[x],j-k-1)+a[x]);</span><br><span class="line">    return f[x][j];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();Q=read();Q++;</span><br><span class="line">    memset(mp,-1,sizeof(mp));</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        int x=read(),y=read(),z=read();</span><br><span class="line">        mp[y][x]=mp[x][y]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    MakeTree(1);</span><br><span class="line">    write(DP(1,Q));putchar(&#x27;\n&#x27;);</span><br><span class="line">    /*</span><br><span class="line">    cout&lt;&lt;&quot;-----------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;Node &quot;&lt;&lt;i&lt;&lt;&quot;:\n&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;Left Son:&quot;&lt;&lt;l[i]&lt;&lt;&quot; Right Son:&quot;&lt;&lt;r[i]&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;Val:&quot;&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;DP :\n&quot;;</span><br><span class="line">        for(int j=0;j&lt;=Q;j++)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;Has &quot;&lt;&lt;j&lt;&lt;&quot;:&quot;&lt;&lt;f[i][j]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">    */</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//设f[i][j]表示以i为根节点，保留j个节点的最大苹果数量</span><br><span class="line">//f[i][j]=max&#123;f[l[i]][k]+f[r[i]][j-k-1]+a[i]&#125;(0&lt;=k&lt;=j-1) </span><br><span class="line">//f[i][j]=0(0&lt;i&lt;=n,0&lt;=j&lt;=Q+1)</span><br><span class="line">//f[i][j]=a[i](j!=0&amp;&amp;l[i]==0&amp;&amp;r[i]==0)</span><br><span class="line">//Answer:f[1][Q+1]</span><br><span class="line">/*</span><br><span class="line">Sample Input:</span><br><span class="line">5 2</span><br><span class="line">1 3 1</span><br><span class="line">1 4 10</span><br><span class="line">2 3 20</span><br><span class="line">3 5 20</span><br><span class="line">Sample Output:</span><br><span class="line">21</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10149. 「一本通 5.1 例 3」凸多边形的划分</title>
      <link href="/2019/02/15/10149-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E4%BE%8B-3%E3%80%8D%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%88%92%E5%88%86/"/>
      <url>/2019/02/15/10149-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-1-%E4%BE%8B-3%E3%80%8D%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个具有 $N$ 个顶点的凸多边形，将顶点从 $1$ 至 $N$ 标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成 $N-2$ 个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先随便搞一个多边形：</p><p><img src="https://s2.ax1x.com/2019/01/30/kl3LOe.png"></p><p>然后给它顺时针每个顶点表上序号：</p><p><img src="https://s2.ax1x.com/2019/01/30/kl3jwd.png"></p><p>然后枚举$i,j$，要求：$i+1&lt;j$，然后给$i,j$连一条线，分割出来另一个多边形：多边形23456</p><p><img src="https://s2.ax1x.com/2019/01/30/kl3XeH.png"></p><p>然后在$i,j$范围内枚举$k$，使得多边形23456又可以分割。</p><p><img src="https://s2.ax1x.com/2019/01/30/kl3zFI.png"></p><p>分割成如下图：</p><p><img src="https://s2.ax1x.com/2019/01/30/kl3vTA.png"></p><p>设$f[i][j]$表示把$i,j$的多边形切割成三角形后的权值乘积之和的最小值。 可得：<br>$$f[i][j]&#x3D;min{f[i][k]+f[k][j]+a[i]_a[j]_a[k]}(0&lt;i&lt;j&lt;k\leq n)$$<br>初始化：<br>$$f[i][j]&#x3D;inf(0&lt;i\leq n,0&lt;j\leq n)$$ $$f[i][i+1]&#x3D;0(0&lt;i&lt;n)$$ 时间复杂度：$O(n^3)$ 输出结果：$f[1][n]$ 当然，这道题范围特别大：对于 $100\%$ 的数据，有 $N\le 50$，每个点权值小于 $10^9$。三个数相乘最高可达$10^{27}$，所以需要使用高精度。这里使用了C++大数类，转自<a href="https://blog.csdn.net/code4101/article/details/23020525">代号4101</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1000;  </span><br><span class="line">struct bign&#123;  </span><br><span class="line">    int d[maxn], len;  </span><br><span class="line"></span><br><span class="line">    void clean() &#123; while(len &gt; 1 &amp;&amp; !d[len-1]) len--; &#125;  </span><br><span class="line"></span><br><span class="line">    bign()          &#123; memset(d, 0, sizeof(d)); len = 1; &#125;  </span><br><span class="line">    bign(int num)   &#123; *this = num; &#125;   </span><br><span class="line">    bign(char* num) &#123; *this = num; &#125;  </span><br><span class="line">    bign operator = (const char* num)&#123;  </span><br><span class="line">        memset(d, 0, sizeof(d)); len = strlen(num);  </span><br><span class="line">        for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - &#x27;0&#x27;;  </span><br><span class="line">        clean();  </span><br><span class="line">        return *this;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator = (int num)&#123;  </span><br><span class="line">        char s[20]; sprintf(s, &quot;%d&quot;, num);  </span><br><span class="line">        *this = s;  </span><br><span class="line">        return *this;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    bign operator + (const bign&amp; b)&#123;  </span><br><span class="line">        bign c = *this; int i;  </span><br><span class="line">        for (i = 0; i &lt; b.len; i++)&#123;  </span><br><span class="line">            c.d[i] += b.d[i];  </span><br><span class="line">            if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++;  </span><br><span class="line">        c.len = max(len, b.len);  </span><br><span class="line">        if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1;  </span><br><span class="line">        return c;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator - (const bign&amp; b)&#123;  </span><br><span class="line">        bign c = *this; int i;  </span><br><span class="line">        for (i = 0; i &lt; b.len; i++)&#123;  </span><br><span class="line">            c.d[i] -= b.d[i];  </span><br><span class="line">            if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--;  </span><br><span class="line">        c.clean();  </span><br><span class="line">        return c;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator * (const bign&amp; b)const&#123;  </span><br><span class="line">        int i, j; bign c; c.len = len + b.len;   </span><br><span class="line">        for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++)   </span><br><span class="line">            c.d[i+j] += d[i] * b.d[j];  </span><br><span class="line">        for(i = 0; i &lt; c.len-1; i++)  </span><br><span class="line">            c.d[i+1] += c.d[i]/10, c.d[i] %= 10;  </span><br><span class="line">        c.clean();  </span><br><span class="line">        return c;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator / (const bign&amp; b)&#123;  </span><br><span class="line">        int i, j;  </span><br><span class="line">        bign c = *this, a = 0;  </span><br><span class="line">        for (i = len - 1; i &gt;= 0; i--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            a = a*10 + d[i];  </span><br><span class="line">            for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break;  </span><br><span class="line">            c.d[i] = j;  </span><br><span class="line">            a = a - b*j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        c.clean();  </span><br><span class="line">        return c;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator % (const bign&amp; b)&#123;  </span><br><span class="line">        int i, j;  </span><br><span class="line">        bign a = 0;  </span><br><span class="line">        for (i = len - 1; i &gt;= 0; i--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            a = a*10 + d[i];  </span><br><span class="line">            for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break;  </span><br><span class="line">            a = a - b*j;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return a;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bign operator += (const bign&amp; b)&#123;  </span><br><span class="line">        *this = *this + b;  </span><br><span class="line">        return *this;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    bool operator &lt;(const bign&amp; b) const&#123;  </span><br><span class="line">        if(len != b.len) return len &lt; b.len;  </span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--)  </span><br><span class="line">            if(d[i] != b.d[i]) return d[i] &lt; b.d[i];  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    bool operator &gt;(const bign&amp; b) const&#123;return b &lt; *this;&#125;  </span><br><span class="line">    bool operator&lt;=(const bign&amp; b) const&#123;return !(b &lt; *this);&#125;  </span><br><span class="line">    bool operator&gt;=(const bign&amp; b) const&#123;return !(*this &lt; b);&#125;  </span><br><span class="line">    bool operator!=(const bign&amp; b) const&#123;return b &lt; *this  *this &lt; b;&#125;  </span><br><span class="line">    bool operator==(const bign&amp; b) const&#123;return !(b &lt; *this) &amp;&amp; !(b &gt; *this);&#125;  </span><br><span class="line"></span><br><span class="line">    string str() const&#123;  </span><br><span class="line">        char s[maxn]=&#123;&#125;;  </span><br><span class="line">        for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+&#x27;0&#x27;;  </span><br><span class="line">        return s;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x)&#123;  </span><br><span class="line">    string s;  </span><br><span class="line">    in &gt;&gt; s;  </span><br><span class="line">    x = s.c_str();  </span><br><span class="line">    return in;  </span><br><span class="line">&#125;  </span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x)&#123;  </span><br><span class="line"></span><br><span class="line">    out &lt;&lt; x.str();  </span><br><span class="line">    return out;  </span><br><span class="line">&#125;</span><br><span class="line">#define ll bign</span><br><span class="line">ll f[55][55],a[55];</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i+=1) cin&gt;&gt;a[i];</span><br><span class="line">    memset(f,63,sizeof(f));</span><br><span class="line">    for(int i=1;i&lt;=n;i++) f[i][i+1]=0;</span><br><span class="line">    for(int L=2;L&lt;=n-1;L++)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n-L;i++)&#123;</span><br><span class="line">            int j=i+L;</span><br><span class="line">            for(int k=i+1;k&lt;=j-1;k++)&#123;</span><br><span class="line">                f[i][j]=min(f[i][k]+f[k][j]+a[i]*a[j]*a[k],f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[1][n];putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//f[i][j]=min&#123;f[i][k]+f[k][j]+a[i]*a[j]*a[k]&#125;(0&lt;i&lt;k&lt;j&lt;=n)</span><br><span class="line">//f[i][j]=inf</span><br><span class="line">//f[i][i+1]=0;</span><br><span class="line">//end:f[1][n]</span><br><span class="line">//Time:O(n^3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10106. 「一本通 3.7 例 2」单词游戏</title>
      <link href="/2019/02/15/10106-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-7-%E4%BE%8B-2%E3%80%8D%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/02/15/10106-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-3-7-%E4%BE%8B-2%E3%80%8D%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $N$ 个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子安排一个合适的顺序，使得相邻两个盘子中，前一个盘子上单词的末字母等于后一个盘子上单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。<br>多组数据。第一行给出数据组数 $T$，每组数据第一行给出盘子数量 $N$，接下去 $N$ 行给出小写字母字符串，一种字符串可能出现多次。<br>若存在一组合法解输出Ordering is possible.，否则输出 The door cannot be opened.。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很明显就是寻找有没有<strong>半</strong>欧拉图。 先来看一看<strong>半</strong>欧拉图的定义：</p><blockquote><p>有向图G为半欧拉图，当且仅当G为连通图，且存在顶点u的入度比出度大1，v的入度比出度小1，其它所有顶点的入度等于出度。 存在欧拉路径而不存在欧拉回路。</p></blockquote><p>再来看一看有向图的<strong>半</strong>欧拉图的性质： 1.图G是连通的，不能有孤立的点存在。 2.存在两个顶点，其入度不等于出度，其中一点出度比入度大1，为路径起点，另一点入度比出度大1，为路径的终点。 好了，有了这些信息，那么这道题就很好打了。 可以采用并查集来帮助check是否为半欧拉图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXE 400010</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">int type,n,m;</span><br><span class="line">int in[MAXE],out[MAXE],fa[MAXE];</span><br><span class="line">bool vis[MAXE];</span><br><span class="line">int T;</span><br><span class="line">char as[1010];</span><br><span class="line">int getfa(int x)&#123;</span><br><span class="line">    return x==fa[x]?x:fa[x]=getfa(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    T=read();</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int Fans=0;</span><br><span class="line">        n=read();m=n;</span><br><span class="line">        memset(in,0,sizeof(in));</span><br><span class="line">        memset(out,0,sizeof(out));</span><br><span class="line">        for(int i=1;i&lt;=26;i++) fa[i]=i;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int x,y;</span><br><span class="line">            cin&gt;&gt;as;</span><br><span class="line">            x=as[0]-&#x27;a&#x27;+1,y=as[strlen(as)-1]-&#x27;a&#x27;+1;</span><br><span class="line">            fa[getfa(y)]=getfa(x);</span><br><span class="line">            in[y]++;out[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;=26;i++)&#123;</span><br><span class="line">            if(((in[i]!=0out[i]!=0)&amp;&amp;(getfa(i)==i))abs(in[i]-out[i])&gt;1) ans++;//root and son &gt;=2 </span><br><span class="line">        &#125;</span><br><span class="line">        if(ans&gt;=2)&#123;puts(&quot;The door cannot be opened.&quot;);continue;&#125;</span><br><span class="line">        int ans1=0,ans2=0;</span><br><span class="line">        for(int i=1;i&lt;=26;i++) (in[i]&gt;out[i]?ans1++:(in[i]&lt;out[i]?ans2++:ans));</span><br><span class="line">        if(ans1!=ans2ans1&gt;1) puts(&quot;The door cannot be opened.&quot;);</span><br><span class="line">        else puts(&quot;Ordering is possible.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> 半欧拉图 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10178. 「一本通 5.5 例 4」旅行问题</title>
      <link href="/2019/02/15/10178-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E4%BE%8B-4%E3%80%8D%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/15/10178-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-5-5-%E4%BE%8B-4%E3%80%8D%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>John 打算驾驶一辆汽车周游一个环形公路。公路上总共有 $<em>n$</em> 车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。John 必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。在一开始的时候，汽车内油量为零，John 每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情况。 任务：判断以每个车站为起点能否按条件成功周游一周。 可以输出TAK否则输出NIE</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑顺时针 设$a_i$表示从$i$站到下一站，车内的汽油增加（减少）了多少。 设$sum_i$表示$a_i$的前缀和，那么如果要判断从某个车站出发是否能周游一周其实就是判断$sum_i-sum_{i-1},sum_{i+1}-sum_{i-1} \dots sum_{i+n-1}-sum_{i-1}$是否有负数，也就是$sum_i,sum_{i+1} \dots sum_{i+n-1}$ 的最小值减去$sum_{i-1}$是否为负数，我们知道，求最小值可以使用RMQ算法（当然线段树也可以），所以使用RMQ+ST表就可以做出<strong>顺时针</strong>是否可以绕一圈了。 至此，你已经得到了20分。 再考虑逆时针，与顺时针刚好相反。部分量需要变化。 比如逆时针判断<br>$sum_i,sum_{i+1} \dots sum_{i+n-1}$ 的最小值减去$sum_{i-1}$是否为负数时，如果为负数则代表$i+n-1$不行，而不是$i$。 逆时针的初始也要更新，与顺时针不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memcpy(tmp,p,sizeof(p));</span><br><span class="line">for(ll i=1;i&lt;=n;i++) p[i]=tmp[n-i+1];</span><br><span class="line">memcpy(tmp,d,sizeof(d));</span><br><span class="line">for(ll i=1;i&lt;=n;i++) d[i]=tmp[n-i];d[n]=tmp[n]; </span><br></pre></td></tr></table></figure><p>然后更新$sum$数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,ans[2000010],a[2000010],tmp[2000010];</span><br><span class="line">ll p[2000010],d[2000010],sum[2000010],f[2000010][20];</span><br><span class="line">void ST()&#123;</span><br><span class="line">    for(ll j=1;(1&lt;&lt;j)&lt;=n*2;j++)&#123;</span><br><span class="line">        for(ll i=1;i+(1&lt;&lt;j)-1&lt;=n*2;i++)&#123;</span><br><span class="line">            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll RMQ(ll l,ll r)&#123;</span><br><span class="line">    ll k=0;</span><br><span class="line">    while((1&lt;&lt;(k+1))&lt;=r-l+1) k++;</span><br><span class="line">    return min(f[l][k],f[r-(1&lt;&lt;k)+1][k]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) p[i]=read(),d[i]=read();</span><br><span class="line">    //顺时针 </span><br><span class="line">    sum[0]=0;</span><br><span class="line">    memset(f,63,sizeof(f));</span><br><span class="line">    for(ll i=1;i&lt;=n*2;i++)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+(p[i]-d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i=1;i&lt;=n*2;i++)&#123;</span><br><span class="line">        f[i][0]=sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ST();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ll qx=RMQ(i,i+n-1);</span><br><span class="line">        if(qx&gt;=sum[i-1]) ans[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    //逆时针</span><br><span class="line">    </span><br><span class="line">    memcpy(tmp,p,sizeof(p));</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) p[i]=tmp[n-i+1];</span><br><span class="line">    memcpy(tmp,d,sizeof(d));</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) d[i]=tmp[n-i];d[n]=tmp[n]; </span><br><span class="line">    sum[0]=0;</span><br><span class="line">    memset(f,63,sizeof(f));</span><br><span class="line">    for(ll i=1;i&lt;=n*2;i++)&#123;</span><br><span class="line">        sum[i]=sum[i-1]+(p[i]-d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(ll i=1;i&lt;=n*2;i++)&#123;</span><br><span class="line">        f[i][0]=sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ST();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ll qx=RMQ(i,i+n-1);</span><br><span class="line">        if(qx&gt;=sum[i-1]) ans[n-i+1]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(ll i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(ans[i]==1) puts(&quot;TAK&quot;);</span><br><span class="line">        else puts(&quot;NIE&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOJ </tag>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分 算法学习</title>
      <link href="/2019/02/14/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/02/14/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>树你应该懂的吧o(<em>￣︶￣</em>)o 学习树链剖分之前需要先学习：$dfs$、线段树（当然大佬们用树状数组代替线段树也可以O(∩_∩)O），据说一名普及+的$oier$应该都会呀</p><h2 id="先来了解树链剖分的用处"><a href="#先来了解树链剖分的用处" class="headerlink" title="先来了解树链剖分的用处"></a>先来了解树链剖分的用处</h2><p><a href="https://www.luogu.org/problemnew/show/P3384">Luogu题目传送门</a> 已知一棵包含$N$个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p><ul><li>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</li><li>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</li><li>操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z</li><li>操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和</li></ul><p>如果直接暴力的话，肯定会TLE（废话）。所以这时候，树链剖分闪亮登场。</p><h2 id="什么是树链剖分"><a href="#什么是树链剖分" class="headerlink" title="什么是树链剖分"></a>什么是树链剖分</h2><p>一种算法（废话），它通过分轻重边把树分割成很多链，然后利用某种数据结构维护这些链（比如上文提到的线段树、树状数组等）但前提是这种数据结构支持动态修改（你别给我整个RMQ）。本质上是一种暴力算法。 PS:树剖的复杂度<strong>约为$O(nlog^2n)$</strong></p><h2 id="树链剖分的基本概念"><a href="#树链剖分的基本概念" class="headerlink" title="树链剖分的基本概念"></a>树链剖分的基本概念</h2><p>名称</p><p>概念</p><p>重儿子</p><p>父亲节点的所有儿子中子节点数目最多(sz最大)的节点</p><p>轻儿子</p><p>父亲节点除了重儿子以外的儿子</p><p>重边</p><p>父亲节点和重儿子连成的边</p><p>轻边</p><p>父亲节点和轻儿子连成的边</p><p>重链</p><p>由多条重边连成的路径</p><p>轻链</p><p>由多条轻边连成的路径</p><p>没看懂？没关系，结合下面这张图：（红色的边代表重边，黑色的边代表轻边，红色的节点代表重儿子，黑色的节点代表轻儿子） PS:这里默认树根也是重儿子。</p><p><img src="https://yuzhengxi.gitee.io/blog/images/shupou1.png"></p><p>上图的重链有：1-4，3-6。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ll fir[MAXN],nxt[MAXN*2],son[MAXN*2],w[MAXN*2],tot;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    ll sum,tag,l,r,ls,rs;</span><br><span class="line">&#125;a[2*MAXN];</span><br><span class="line">ll root,n,m,r,mod,v[MAXN],cnt,fa[MAXN],dep[MAXN],sz[MAXN],c[MAXN],rk[MAXN],top[MAXN],id[MAXN];</span><br></pre></td></tr></table></figure><p>名称</p><p>作用</p><p>$fir_x$</p><p>关于$x$的最后一条边编号</p><p>$nxt_x$</p><p>关于$x$的上一条边编号</p><p>$son_x$</p><p>第$x$条边的连向</p><p>$w_x$</p><p>其实没啥用，打着习惯了</p><p>$a_x.ls$</p><p>编号为$x$的节点的左儿子</p><p>$a_x.rs$</p><p>编号为$x$的节点的右儿子</p><p>$fa_x$</p><p>编号为$x$的节点的父亲</p><p>$c_x$</p><p>编号为$x$的节点的重儿子</p><p>$rk_x$</p><p>当前$dfs$标号在树中所对应的节点的编号</p><p>$top_x$</p><p>编号为$x$的节点所在链的顶端节点编号</p><p>$id_x$</p><p>编号为$x$的节点$dfs$后的新编号</p><p>$dep_x$</p><p>编号为$x$的节点的深度</p><p>$sz_x$</p><p>以编号为$x$的节点为根的子树的节点个数</p><h2 id="树链剖分的实现"><a href="#树链剖分的实现" class="headerlink" title="树链剖分的实现"></a>树链剖分的实现</h2><h3 id="第一次-dfs-求出每个节点的重儿子、父亲、深度、子树大小。"><a href="#第一次-dfs-求出每个节点的重儿子、父亲、深度、子树大小。" class="headerlink" title="第一次$dfs$求出每个节点的重儿子、父亲、深度、子树大小。"></a>第一次$dfs$求出每个节点的重儿子、父亲、深度、子树大小。</h3><p>PS:如果一个点的多个儿子所在子树大小相等且最大，那随便找一个当做它的重儿子就好了，叶节点没有重儿子，非叶节点有且只有一个重儿子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inline void dfs1(ll x,ll f,ll deep)&#123;</span><br><span class="line">    fa[x]=f;//该节点的父亲</span><br><span class="line">    dep[x]=deep;//该节点深度</span><br><span class="line">    sz[x]=1;//该节点子树先设置为1（本身）</span><br><span class="line">    for(ll i=fir[x];i;i=nxt[i])&#123;//寻找与该节点相连的边</span><br><span class="line">        ll to=son[i];//该边的另一个节点</span><br><span class="line">        if(to==f) continue ;//如果另一个节点刚好是父亲，那么continue </span><br><span class="line">        dfs1(to,x,deep+1);//否则dfs该节点，并且父亲为本节点，深度+1</span><br><span class="line">        sz[x]+=sz[to];//子树大小增加</span><br><span class="line">        if(sz[to]&gt;sz[c[x]]) c[x]=to;//重儿子更新（找子树最大的）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//主函数调用</span><br><span class="line">dfs1(root,0,1);</span><br></pre></td></tr></table></figure><p>操作完以后应该是下图：</p><p><img src="https://yuzhengxi.gitee.io/blog/images/shupou2.png"></p><h3 id="第二次-dfs-求出每个节点的链顶端节点、新编号、-dfs-编号对应的节点编号。"><a href="#第二次-dfs-求出每个节点的链顶端节点、新编号、-dfs-编号对应的节点编号。" class="headerlink" title="第二次$dfs$求出每个节点的链顶端节点、新编号、$dfs$编号对应的节点编号。"></a>第二次$dfs$求出每个节点的链顶端节点、新编号、$dfs$编号对应的节点编号。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">inline void dfs2(ll x,ll ttop)&#123;</span><br><span class="line">    top[x]=ttop;//链顶端编号</span><br><span class="line">    id[x]=++cnt;//新编号（dfs序）</span><br><span class="line">    rk[cnt]=x;//新编号对应节点编号</span><br><span class="line">    if(c[x]!=0) dfs2(c[x],ttop);//如果不是叶子节点，优先dfs重儿子，因为节点与重儿子处在同一重链，所以重儿子的重链顶端还是ttop</span><br><span class="line">    for(ll i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        ll to=son[i];</span><br><span class="line">        if(to!=c[x]&amp;&amp;to!=fa[x]) dfs2(to,to);//如果既不是父亲也不是重儿子，那么就是该节点的轻儿子，那么dfs，且该节点的重链顶端为它本身</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//主函数调用</span><br><span class="line">dfs2(root,root);</span><br></pre></td></tr></table></figure><p>操作完以后应该是下图：</p><p><img src="https://yuzhengxi.gitee.io/blog/images/shupou3.png"></p><h3 id="线段树等数据结构的维护"><a href="#线段树等数据结构的维护" class="headerlink" title="线段树等数据结构的维护"></a>线段树等数据结构的维护</h3><p>接下来就是线段树、树状数组等数据结构的维护了，具体使用哪种数据结构因题目而异，这里提供模板题（上文介绍的题目）所使用的线段树（区间修改、区间询问）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">inline void pushup(ll x)&#123;</span><br><span class="line">    a[x].sum=(a[a[x].ls].sum+a[a[x].rs].sum)%mod;//更新求和</span><br><span class="line">&#125;</span><br><span class="line">inline void build(ll l,ll r,ll x)&#123;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        a[x].sum=v[rk[l]];//符合所在区间，更新</span><br><span class="line">        a[x].l=a[x].r=l;//l、r更新</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=l+r&gt;&gt;1;//线段树性质</span><br><span class="line">    a[x].ls=cnt++;a[x].rs=cnt++;//左右儿子节点编号</span><br><span class="line">    build(l,mid,a[x].ls);build(mid+1,r,a[x].rs);//分而治之</span><br><span class="line">    a[x].l=a[a[x].ls].l,a[x].r=a[a[x].rs].r;//区间更新</span><br><span class="line">    pushup(x);//sum更新</span><br><span class="line">&#125;</span><br><span class="line">inline ll len(ll x)&#123;</span><br><span class="line">    return a[x].r-a[x].l+1;//该区间的节点数量</span><br><span class="line">&#125;</span><br><span class="line">inline void pushdown(ll x)&#123;</span><br><span class="line">    if(a[x].tag!=0)&#123;//如果有lazy tag</span><br><span class="line">        a[a[x].ls].tag+=a[x].tag;a[a[x].rs].tag+=a[x].tag;//向左右儿子传递</span><br><span class="line">        a[a[x].ls].tag%=mod;a[a[x].rs].tag%=mod;</span><br><span class="line">        a[a[x].ls].sum+=a[x].tag*len(a[x].ls);a[a[x].rs].sum+=a[x].tag*len(a[x].rs);//左右儿子更新</span><br><span class="line">        a[a[x].ls].sum%=mod;a[a[x].rs].sum%=mod;</span><br><span class="line">        a[x].tag=0;//lazy tag取消</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void update(ll l,ll r,ll c,ll x)&#123;</span><br><span class="line">    if(a[x].l&gt;=l&amp;&amp;a[x].r&lt;=r)&#123;</span><br><span class="line">        a[x].tag+=c;a[x].tag%=mod;//修改lazy tag</span><br><span class="line">        a[x].sum+=len(x)*c;a[x].sum%=mod;//修改sum</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x);//标记下传</span><br><span class="line">    ll mid=a[x].l+a[x].r&gt;&gt;1;</span><br><span class="line">    if(mid&gt;=l) update(l,r,c,a[x].ls);//分而治之</span><br><span class="line">    if(mid&lt;r) update(l,r,c,a[x].rs);</span><br><span class="line">    pushup(x);//更新sum</span><br><span class="line">&#125;</span><br><span class="line">inline ll query(ll l,ll r,ll x)&#123;</span><br><span class="line">    if(a[x].l&gt;=l&amp;&amp;a[x].r&lt;=r) return a[x].sum;//如果符合在本区间内，那么return</span><br><span class="line">    pushdown(x);//标记下传</span><br><span class="line">    ll mid=a[x].l+a[x].r&gt;&gt;1,ss=0;</span><br><span class="line">    if(mid&gt;=l) ss+=query(l,r,a[x].ls);ss%=mod;//分而治之</span><br><span class="line">    if(mid&lt;r) ss+=query(l,r,a[x].rs);ss%=mod;</span><br><span class="line">    return ss;//返回</span><br><span class="line">&#125;</span><br><span class="line">//主函数调用(根据上文题目)</span><br><span class="line">cnt=0;build(1,n,root=cnt++);</span><br><span class="line">update(id[x],id[x]+sz[x]-1,y,root);</span><br><span class="line">query(id[x],id[x]+sz[x]-1,root);</span><br></pre></td></tr></table></figure><h3 id="根据题目需要添加操作"><a href="#根据题目需要添加操作" class="headerlink" title="根据题目需要添加操作"></a>根据题目需要添加操作</h3><p>就比如上文的题目中还要求的操作：</p><ul><li>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</li><li>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</li></ul><p>与操作3、操作4不同，这里要求的是一条路径上的节点，而没有告诉我们节点的编号，所以，我们这时要求出节点编号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inline ll Query(ll x,ll y)&#123;</span><br><span class="line">    ll res=0;</span><br><span class="line">    while(top[x]!=top[y])&#123;//若两点不再同一条链上</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        res+=query(id[top[x]],id[x],root);//ans更新</span><br><span class="line">        res%=mod;</span><br><span class="line">        x=fa[top[x]];//让x向上爬（与倍增思想类似，但有时复杂度更低）</span><br><span class="line">    &#125;</span><br><span class="line">    if(id[x]&gt;id[y]) swap(x,y);</span><br><span class="line">    res+=query(id[x],id[y],root);//在同一条链，跳到同一点，ans更新</span><br><span class="line">    res%=mod;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">inline void Update(ll x,ll y,ll c)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;//两点不在同一条链</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        update(id[top[x]],id[x],c,root);//更新</span><br><span class="line">        x=fa[top[x]];//让x向上爬</span><br><span class="line">    &#125;</span><br><span class="line">    if(id[x]&gt;id[y]) swap(x,y);</span><br><span class="line">    update(id[x],id[y],c,root);//在同一链，跳到同一点，更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，还有一个操作是非常常用的，那就是求lca（最近公共祖先）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline ll lca(ll x,ll y)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;//两点不在同一条链上肯定没有公共祖先</span><br><span class="line">        if(dep[top[x]]&gt;=dep[top[y]])x=fa[top[x]];//让深度低的点向上爬，x向上爬</span><br><span class="line">        else y=fa[top[y]];//y向上爬</span><br><span class="line">    &#125;</span><br><span class="line">    return dep[x]&lt;dep[y]?x:y;//取深度低的点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板题代码"><a href="#模板题代码" class="headerlink" title="模板题代码"></a>模板题代码</h2><p>对对对，就是上文提到的题目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 200010</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">ll fir[MAXN],nxt[MAXN*2],son[MAXN*2],w[MAXN*2],tot;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    ll sum,tag,l,r,ls,rs;</span><br><span class="line">&#125;a[2*MAXN];</span><br><span class="line">ll root,n,m,r,mod,v[MAXN],cnt,fa[MAXN],dep[MAXN],sz[MAXN],c[MAXN],rk[MAXN],top[MAXN],id[MAXN];</span><br><span class="line">inline void dfs1(ll x,ll f,ll deep)&#123;</span><br><span class="line">    fa[x]=f;</span><br><span class="line">    dep[x]=deep;</span><br><span class="line">    sz[x]=1;</span><br><span class="line">    for(ll i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        ll to=son[i];</span><br><span class="line">        if(to==f) continue ;</span><br><span class="line">        dfs1(to,x,deep+1);</span><br><span class="line">        sz[x]+=sz[to];</span><br><span class="line">        if(sz[to]&gt;sz[c[x]]) c[x]=to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void dfs2(ll x,ll ttop)&#123;</span><br><span class="line">    top[x]=ttop;</span><br><span class="line">    id[x]=++cnt;</span><br><span class="line">    rk[cnt]=x;</span><br><span class="line">    if(c[x]!=0) dfs2(c[x],ttop);</span><br><span class="line">    for(ll i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        ll to=son[i];</span><br><span class="line">        if(to!=c[x]&amp;&amp;to!=fa[x]) dfs2(to,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void pushup(ll x)&#123;</span><br><span class="line">    a[x].sum=(a[a[x].ls].sum+a[a[x].rs].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line">inline void build(ll l,ll r,ll x)&#123;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        a[x].sum=v[rk[l]];</span><br><span class="line">        a[x].l=a[x].r=l;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=l+r&gt;&gt;1;</span><br><span class="line">    a[x].ls=cnt++;a[x].rs=cnt++;</span><br><span class="line">    build(l,mid,a[x].ls);build(mid+1,r,a[x].rs);</span><br><span class="line">    a[x].l=a[a[x].ls].l,a[x].r=a[a[x].rs].r;</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline ll len(ll x)&#123;</span><br><span class="line">    return a[x].r-a[x].l+1;</span><br><span class="line">&#125;</span><br><span class="line">inline void pushdown(ll x)&#123;</span><br><span class="line">    if(a[x].tag!=0)&#123;</span><br><span class="line">        a[a[x].ls].tag+=a[x].tag;a[a[x].rs].tag+=a[x].tag;</span><br><span class="line">        a[a[x].ls].tag%=mod;a[a[x].rs].tag%=mod;</span><br><span class="line">        a[a[x].ls].sum+=a[x].tag*len(a[x].ls);a[a[x].rs].sum+=a[x].tag*len(a[x].rs);</span><br><span class="line">        a[a[x].ls].sum%=mod;a[a[x].rs].sum%=mod;</span><br><span class="line">        a[x].tag=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void update(ll l,ll r,ll c,ll x)&#123;</span><br><span class="line">    if(a[x].l&gt;=l&amp;&amp;a[x].r&lt;=r)&#123;</span><br><span class="line">        a[x].tag+=c;a[x].tag%=mod;</span><br><span class="line">        a[x].sum+=len(x)*c;a[x].sum%=mod;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    ll mid=a[x].l+a[x].r&gt;&gt;1;</span><br><span class="line">    if(mid&gt;=l) update(l,r,c,a[x].ls);</span><br><span class="line">    if(mid&lt;r) update(l,r,c,a[x].rs);</span><br><span class="line">    pushup(x);</span><br><span class="line">&#125;</span><br><span class="line">inline ll lca(ll x,ll y)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&gt;=dep[top[y]])x=fa[top[x]];</span><br><span class="line">        else y=fa[top[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    return dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line">inline ll query(ll l,ll r,ll x)&#123;</span><br><span class="line">    if(a[x].l&gt;=l&amp;&amp;a[x].r&lt;=r) return a[x].sum;</span><br><span class="line">    pushdown(x);</span><br><span class="line">    ll mid=a[x].l+a[x].r&gt;&gt;1,ss=0;</span><br><span class="line">    if(mid&gt;=l) ss+=query(l,r,a[x].ls);ss%=mod;</span><br><span class="line">    if(mid&lt;r) ss+=query(l,r,a[x].rs);ss%=mod;</span><br><span class="line">    return ss;</span><br><span class="line">&#125;</span><br><span class="line">inline ll Query(ll x,ll y)&#123;</span><br><span class="line">    ll res=0;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        res+=query(id[top[x]],id[x],root);</span><br><span class="line">        res%=mod;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    if(id[x]&gt;id[y]) swap(x,y);</span><br><span class="line">    res+=query(id[x],id[y],root);</span><br><span class="line">    res%=mod;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">inline void Update(ll x,ll y,ll c)&#123;</span><br><span class="line">    while(top[x]!=top[y])&#123;</span><br><span class="line">        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        update(id[top[x]],id[x],c,root);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    if(id[x]&gt;id[y]) swap(x,y);</span><br><span class="line">    update(id[x],id[y],c,root);</span><br><span class="line">&#125;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    char ch=getchar();ll res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">inline void add(ll x,ll y)&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    son[tot]=y;</span><br><span class="line">    nxt[tot]=fir[x];</span><br><span class="line">    fir[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();r=read();mod=read();</span><br><span class="line">    for(ll i=1;i&lt;=n;i++) v[i]=read();</span><br><span class="line">    for(ll x,y,i=1;i&lt;n;i++)&#123;</span><br><span class="line">        x=read(),y=read();</span><br><span class="line">        add(x,y);add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=0;dfs1(r,0,1);</span><br><span class="line">    dfs2(r,r);</span><br><span class="line">    cnt=0;build(1,n,root=cnt++);</span><br><span class="line">    for(ll op,x,y,k,i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        op=read();</span><br><span class="line">        if(op==1)&#123;</span><br><span class="line">            x=read();y=read();k=read();</span><br><span class="line">            Update(x,y,k);</span><br><span class="line">        &#125;else if(op==2)&#123;</span><br><span class="line">            x=read();y=read();</span><br><span class="line">            write(Query(x,y));putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;else if(op==3)&#123;</span><br><span class="line">            x=read();y=read();</span><br><span class="line">            update(id[x],id[x]+sz[x]-1,y,root);</span><br><span class="line">        &#125;else if(op==4)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            write(query(id[x],id[x]+sz[x]-1,root));putchar(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论之威佐夫博弈 算法学习</title>
      <link href="/2019/02/14/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B9%8B%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/02/14/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B9%8B%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论之威佐夫博弈"><a href="#博弈论之威佐夫博弈" class="headerlink" title="博弈论之威佐夫博弈"></a>博弈论之威佐夫博弈</h1><blockquote><p>威佐夫博弈（Wythoff’s game）是指的这样一个问题：有两堆各若干个物品，两个人轮流从任意一堆中取出至少一个或者同时从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜利。<br>——转自百度百科</p></blockquote><p>就比如<a href="https://www.luogu.org/problemnew/show/P2252">洛谷的P2252 取石子游戏</a>就是威佐夫博弈的裸题。。。</p><h1 id="威佐夫博弈的性质"><a href="#威佐夫博弈的性质" class="headerlink" title="威佐夫博弈的性质"></a>威佐夫博弈的性质</h1><p>首先，由题目可知，当这两堆石子一样多时，先手获胜；当有一堆石子为空时，先手获胜。 现，我们设$(a[i],b[i])$表示先手必败的局势，其中$a[i],b[i]$分别表示两堆石子的个数。我们又称这种局势为奇异局势。 那么，我们就可以推出一些较小的数据的必败局势（奇异局势）： 假如说这两堆石子的初始状态为(1,2)。那么则有如下几种情况： (1)先手从第一堆中取一个，后手从第二堆中取两个，先手输，后手赢。 (2)先手从第二堆中取一个，后手将两堆都取一个，先手输，后手赢。 (3)先手从第二堆中取两个，后手从第一堆中取一个，先手输，后手赢。 (4)先手从两堆中各取一个，后手从第二堆中取一个，先手输，后手赢。 通过推理石子状态为(1,2)的所有可能，我们可以发现石子状态为(1,2)时，先手必输(双方都采用最优策略)。 在此，我就不列举其他奇异局势的推理过程。现将奇异局势的表单贴下来：</p><p>个数</p><p>状态</p><p>1</p><p>(0,0)</p><p>2</p><p>(1,2)</p><p>3</p><p>(3,5)</p><p>4</p><p>(4,7)</p><p>5</p><p>(6,10)</p><p>6</p><p>(8,13)</p><p>7</p><p>(9,15)</p><p>8</p><p>(11,18)</p><p>9</p><p>(12,20)</p><h1 id="威佐夫博弈的结论"><a href="#威佐夫博弈的结论" class="headerlink" title="威佐夫博弈的结论"></a>威佐夫博弈的结论</h1><p>仔细观察上表，可以得出以下几个规律。 (1)状态是单调递增的（废话） (2)状态的石子数量的差是个等差数列（公差为1），这个序列为：0,1,2,3,4,5，6,7,8,9,10,11…… (3)状态的第一个数字是之前没有出现过的第一个数字。比如说第二个状态的第一个数字1，就是前几个状态没有出现的数字。 (4)每个状态的第一个数字竟然是这个状态的两堆石子数量的差$*1.618$</p><h1 id="关于-1-618"><a href="#关于-1-618" class="headerlink" title="关于$1.618$"></a>关于$1.618$</h1><p>$1.618$是一个非常神奇的数字，它既是黄金分割率的近似值+1，即$0.618+1$，也是$(\sqrt{5}+1)&#x2F;2$，即$(\sqrt{5}+1)&#x2F;2 \approx 1.618$。 有图为证：</p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike116%2C5%2C5%2C116%2C38/sign=d73f16b253df8db1a8237436684ab631/241f95cad1c8a78642485d246a09c93d70cf50bd.jpg"></p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=6c3ce8d981025aafc73f76999a84c001/14ce36d3d539b60087dca1aeea50352ac65cb79d.jpg"></p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fwtf5rp12uj306c08x74m.jpg%3Cbr%3E">  </p><p>——转自百度百科 但是为什么众多OIer在打威佐夫博弈时不直接使用1.618呢，因为C++&#x2F;Pascal有一个奇妙的东西——<strong>精度</strong></p><h1 id="解决洛谷的P2252-取石子游戏"><a href="#解决洛谷的P2252-取石子游戏" class="headerlink" title="解决洛谷的P2252 取石子游戏"></a>解决<a href="https://www.luogu.org/problemnew/show/P2252">洛谷的P2252 取石子游戏</a></h1><p>这道题就是裸的威佐夫博弈啊。。。 不多说了，上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    a=read();b=read();</span><br><span class="line">    if(a==b)&#123;                     //特判，如果两堆石子相等，那么先手直接从两堆取同样多的石子，先手赢，后手输</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a==0b==0)&#123;               //特判，如果两堆中有一堆没有石子，那么先手取一堆石子，先手赢，后手输</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int x=min(a,b),y=max(a,b);    //x,y取最小值和最大值，也就是让两堆石子有序</span><br><span class="line">    double r=(sqrt(5.0)+1.0)/2.0; //根据上述(4)规律</span><br><span class="line">    double c=(double)(y-x);       //根据上述(2)规律</span><br><span class="line">    int tmp=r*c;                  //根据上述(4)规律</span><br><span class="line">    if(tmp==x) puts(&quot;0&quot;);         //如果计算结果（利用上述规律）刚好等于第一堆石子数量（符合上述规律）那么就一定是奇异局势（先手必败）</span><br><span class="line">    else puts(&quot;1&quot;);               //不是奇异局势，那么先手一定有可能获胜</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉有点乱。。。QWQ 简洁的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">int a,b;</span><br><span class="line">int main()&#123;</span><br><span class="line">    a=read();b=read();</span><br><span class="line">    if(a==b)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a==0b==0)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int x=min(a,b),y=max(a,b);</span><br><span class="line">    double r=(sqrt(5.0)+1.0)/2.0;</span><br><span class="line">    double c=(double)(y-x);</span><br><span class="line">    int tmp=r*c;</span><br><span class="line">    if(tmp==x) puts(&quot;0&quot;);</span><br><span class="line">    else puts(&quot;1&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 威佐夫博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缩点求强连通分量——Kosaraju算法 学习笔记</title>
      <link href="/2019/02/14/%E7%BC%A9%E7%82%B9%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/14/%E7%BC%A9%E7%82%B9%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju%E7%AE%97%E6%B3%95-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kosaraju-算法学习"><a href="#Kosaraju-算法学习" class="headerlink" title="Kosaraju 算法学习"></a>Kosaraju 算法学习</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这星期捣鼓了一个新的算法——Kosaraju算法 今天分享给大家</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kosaraju算法，其实与tarjan算法差不多。但是码量较小，容易记忆。其时间复杂度与tarjan算法一样，为O(n+m)，所以，某种程度上来说Kosaraju可以替代tarjan算法。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>如果直接让我讲Kosaraju算法到底是基于什么实现的，我肯定讲不出来，但只能知道它的基本思路——dfs两次。 就是这么简单，当然，为什么广大的oier不学习Kosaraju算法呢？因为麻烦。 Kosaraju算法中将利用到反边（有向图），使其代码雅观度大大降低。。。 废话说了那么多，言归正传。Kosaraju算法就是先用正边dfs一次，将dfs时每遍历完一个点就push到一个栈中。第二次从栈顶节点反边遍历一次，记录一下id就好了。。。 PS:我真的证明不来QWQ</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void dfs_1(int x)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    for(int i=fir[x];i;i=nxt[i])&#123;</span><br><span class="line">        if(vis[son[i]]==0) dfs_1(son[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    d[++t]=x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs_2(int x)&#123;</span><br><span class="line">    vis[x]=t;</span><br><span class="line">    s[t]++;</span><br><span class="line">    for(int i=fir2[x];i;i=nxt2[i])&#123;</span><br><span class="line">        if(vis[son2[i]]==0) dfs_2(son2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Kosaraju()&#123;</span><br><span class="line">    t=0;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[i]==0) dfs_1(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(vis,0,sizeof(vis));t=0;</span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        if(vis[d[i]]==0) t++,dfs_2(d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>祝大家2019新年快乐！（手动滑稽）</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
            <tag> Kosaraju </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fhq treap 学习笔记</title>
      <link href="/2019/02/14/fhq-treap-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/14/fhq-treap-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>今天心血来潮，来学习一下fhq treap（其实原因是本校有个OIer名叫fh，当然不是我）</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>fhq treap 学名好像是“非旋转式treap及可持久化”。。。听上去怪怪的。其实就是可以代替LCT、BST等等码量很高的东东。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int son[2],val,rand_val,sz;//很好理解，从左到右依次为：左右儿子编号，权值，随机权值（用处后面会讲），此节点下（包括此节点）共有多少个节点</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="最基本的操作"><a href="#最基本的操作" class="headerlink" title="最基本的操作"></a>最基本的操作</h2><p>其实都不应该叫做操作。应该类似于维护的。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void update(int x)&#123;</span><br><span class="line">    tr[x].sz=tr[tr[x].son[0]].sz+tr[tr[x].son[1]].sz+1;//更新节点个数，将左右子树节点个数+本节点（不要忘了。。QWQ） </span><br><span class="line">&#125;</span><br><span class="line">int new_node(int v)&#123;</span><br><span class="line">    tot++;//总节点编号++</span><br><span class="line">    tr[tot].sz=1;//默认为1（叶子）</span><br><span class="line">    tr[tot].val=v;//权值赋值</span><br><span class="line">    tr[tot].rand_val=rand();//随机rand权值</span><br><span class="line">    return tot;//返回节点编号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>其实就三个啦。。。。</p><h3 id="操作1-merge（默认x-lt-y）"><a href="#操作1-merge（默认x-lt-y）" class="headerlink" title="操作1:merge（默认x&lt;y）"></a>操作1:merge（默认x&lt;y）</h3><p>merge的操作其实就是把两棵树合并成一棵（真好！）。使用递归。按照rand出来的权值进行判断是左子树还是右子树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int merge(int x,int y)&#123;</span><br><span class="line">    if(!x!y) return x+y;//如果有一棵树是空的，那么就可以直接退出</span><br><span class="line">    if(tr[x].rand_val&lt;tr[y].rand_val)&#123;//按照rand的权值确定左右子树</span><br><span class="line">        tr[x].son[1]=merge(tr[x].son[1],y);//将x的右儿子中merge树y</span><br><span class="line">        update(x);//更新节点数</span><br><span class="line">        return x;//返回</span><br><span class="line">    &#125;else&#123;//同理</span><br><span class="line">        tr[y].son[0]=merge(x,tr[y].son[0]);</span><br><span class="line">        update(y);</span><br><span class="line">        return y;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作2-split"><a href="#操作2-split" class="headerlink" title="操作2:split"></a>操作2:split</h3><p>split的操作其实就是把一棵树拆成两棵子树。当然有两种拆法，一种是按照权值，还有一种是按照节点数分。<br>这里的操作2是按照权值分，操作3按照节点数分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void split(int now,int k,int &amp;x,int &amp;y)&#123;//以权值k来分now树，成x,y</span><br><span class="line">    if(!now) x=y=0;//如果当前操作为空树，返回空子树</span><br><span class="line">    else&#123;</span><br><span class="line">        if(tr[now].val&lt;=k) x=now,split(tr[now].son[1],k,tr[now].son[1],y);//如果小于或等于权值k，将左子树改为当前的树，并将当前的树的右子树继续往下分（把所有小于等于权值k的节点划分到一棵树当中）</span><br><span class="line">        else y=now,split(tr[now].son[0],k,x,tr[now].son[0]);//同理</span><br><span class="line">        update(now);//注意更新节点数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作3-rank"><a href="#操作3-rank" class="headerlink" title="操作3:rank"></a>操作3:rank</h3><p>在操作2中已经说明过了，是按照节点数分（有点像其他数据结构中查找第k名的操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int rank(int now,int k)&#123;//在now树中，查找以权值排序的第k个节点</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if(k&lt;=tr[tr[now].son[0]].sz) now=tr[now].son[0];//如果k在左子树当中那就更新</span><br><span class="line">        else&#123;</span><br><span class="line">            if(k==tr[tr[now].son[0]].sz+1) return now;//正好找到</span><br><span class="line">            else&#123;//如果k在右子树当中，注意k还要减去左子树的个数+本节点</span><br><span class="line">                k-=tr[tr[now].son[0]].sz+1;</span><br><span class="line">                now=tr[now].son[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通的操作"><a href="#普通的操作" class="headerlink" title="普通的操作"></a>普通的操作</h2><p>拿一道例题来讲吧。。。<br><a href="https://www.luogu.org/problemnew/show/P3369">传送门</a><br>其实操作并没有高级多少（主要是想象力。。。）</p><h3 id="操作1-插入-x-数"><a href="#操作1-插入-x-数" class="headerlink" title="操作1:插入$x$数"></a>操作1:插入$x$数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">split(root,a,x,y);</span><br><span class="line">root=merge(merge(x,new_node(a)),y);</span><br></pre></td></tr></table></figure><blockquote><p>这个比较好理解，我们先把树分为x,y两部分，然后把新的节点a看做是一棵树，先与x合并，合并完之后将合并的整体与y合并</p></blockquote><h3 id="操作2-删除-x-数-若有多个相同的数，因只删除一个"><a href="#操作2-删除-x-数-若有多个相同的数，因只删除一个" class="headerlink" title="操作2:删除$x$数(若有多个相同的数，因只删除一个)"></a>操作2:删除$x$数(若有多个相同的数，因只删除一个)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split(root,a,x,z);</span><br><span class="line">split(x,a-1,x,y);</span><br><span class="line">y=merge(tr[y].son[0],tr[y].son[1]);</span><br><span class="line">root=merge(merge(x,y),z);</span><br></pre></td></tr></table></figure><blockquote><p>首先我们把树分为x和z两部分<br>那么x树中的最大权值为a<br>再把x分为x和y两部分。<br>此时x中的最大权值为a-1，且权值为a的节点一定是y的根节点。<br>然后我们可以无视y的根节点，直接把y的左右孩子合并起来，这样就成功的删除了根节点，<br>最后再把x，y，z合并起来就好</p></blockquote><h3 id="操作3-查询-x-数的排名-排名定义为比当前数小的数的个数-1。若有多个相同的数，因输出最小的排名"><a href="#操作3-查询-x-数的排名-排名定义为比当前数小的数的个数-1。若有多个相同的数，因输出最小的排名" class="headerlink" title="操作3:查询$x$数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名)"></a>操作3:查询$x$数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(root,a-1,x,y);</span><br><span class="line">printf(&quot;%d\n&quot;,tr[x].sz+1);</span><br><span class="line">root=merge(x,y);</span><br></pre></td></tr></table></figure><blockquote><p>我们首先按照a-1的权值把树分开。<br>那么x树中最大的应该是a-1。<br>那么a的排名就是siz[x]+1</p></blockquote><h3 id="操作4-查询排名为-x-的数"><a href="#操作4-查询排名为-x-的数" class="headerlink" title="操作4:查询排名为$x$的数"></a>操作4:查询排名为$x$的数</h3><p>&#x2F;&#x2F;rank函数不是白吃饭的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;,tr[rank(root,a)].val);</span><br></pre></td></tr></table></figure><blockquote><p>不解释了QWQ</p></blockquote><h3 id="操作5-求-x-的前驱-前驱定义为小于-x-，且最大的数"><a href="#操作5-求-x-的前驱-前驱定义为小于-x-，且最大的数" class="headerlink" title="操作5:求$x$的前驱(前驱定义为小于$x$，且最大的数)"></a>操作5:求$x$的前驱(前驱定义为小于$x$，且最大的数)</h3><p>&#x2F;&#x2F;rank函数真的不是白吃饭的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(root,a-1,x,y);</span><br><span class="line">printf(&quot;%d\n&quot;,tr[rank(x,tr[x].sz)].val);</span><br><span class="line">root=merge(x,y);</span><br></pre></td></tr></table></figure><blockquote><p>因为要小于a，那么我们按照a-1的权值划分，<br>x中最大的一定是&lt;&#x3D;a-1的，<br>所以我们直接输出x中最大的数就好，<br>（这里有一个小技巧，因为sz储存的是节点的数目，然后根据二叉查找树的性质，编号最大的就是值最大的）</p></blockquote><h3 id="操作6-求-x-的后继-后继定义为大于-x-，且最小的数"><a href="#操作6-求-x-的后继-后继定义为大于-x-，且最小的数" class="headerlink" title="操作6:求$x$的后继(后继定义为大于$x$，且最小的数)"></a>操作6:求$x$的后继(后继定义为大于$x$，且最小的数)</h3><p>&#x2F;&#x2F;rank函数真的不是白吃饭的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split(root,a,x,y);</span><br><span class="line">printf(&quot;%d\n&quot;,tr[rank(y,1)].val);</span><br><span class="line">root=merge(x,y);</span><br></pre></td></tr></table></figure><blockquote><p>因为要大于a，那么我们按照a的权值划分（取子树y），<br>y中最小的一定是&gt;a的，<br>所以我们直接输出y中最小的数就好，<br>（像操作5一样这里有一个小技巧，因为sz储存的是节点的数目，然后根据二叉查找树的性质，编号最小的就是值最小的）</p></blockquote><h1 id="完整的代码："><a href="#完整的代码：" class="headerlink" title="完整的代码："></a>完整的代码：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 100010</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char ch=getchar();int res=0,f=1;</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(int x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int son[2],val,rand_val,sz;</span><br><span class="line">&#125;tr[N];</span><br><span class="line">int tot=0,root=0;</span><br><span class="line">void update(int x)&#123;</span><br><span class="line">    tr[x].sz=tr[tr[x].son[0]].sz+tr[tr[x].son[1]].sz+1;   </span><br><span class="line">&#125;</span><br><span class="line">int new_node(int v)&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    tr[tot].sz=1;</span><br><span class="line">    tr[tot].val=v;</span><br><span class="line">    tr[tot].rand_val=rand();</span><br><span class="line">    return tot;</span><br><span class="line">&#125;</span><br><span class="line">int merge(int x,int y)&#123;</span><br><span class="line">    if(!x!y) return x+y;</span><br><span class="line">    if(tr[x].rand_val&lt;tr[y].rand_val)&#123;</span><br><span class="line">        tr[x].son[1]=merge(tr[x].son[1],y);</span><br><span class="line">        update(x);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        tr[y].son[0]=merge(x,tr[y].son[0]);</span><br><span class="line">        update(y);</span><br><span class="line">        return y;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void split(int now,int k,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(!now) x=y=0;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(tr[now].val&lt;=k) x=now,split(tr[now].son[1],k,tr[now].son[1],y);</span><br><span class="line">        else y=now,split(tr[now].son[0],k,x,tr[now].son[0]);</span><br><span class="line">        update(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int rank(int now,int k)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if(k&lt;=tr[tr[now].son[0]].sz) now=tr[now].son[0];</span><br><span class="line">        else&#123;</span><br><span class="line">            if(k==tr[tr[now].son[0]].sz+1) return now;</span><br><span class="line">            else&#123;</span><br><span class="line">                k-=tr[tr[now].son[0]].sz+1;</span><br><span class="line">                now=tr[now].son[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int T,type,x,y,z,a,b;</span><br><span class="line">int main()&#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;type,&amp;a);</span><br><span class="line">        if(type==1)&#123;</span><br><span class="line">            split(root,a,x,y);</span><br><span class="line">            root=merge(merge(x,new_node(a)),y);</span><br><span class="line">        &#125;else if(type==2)&#123;</span><br><span class="line">            split(root,a,x,z);</span><br><span class="line">            split(x,a-1,x,y);</span><br><span class="line">            y=merge(tr[y].son[0],tr[y].son[1]);</span><br><span class="line">            root=merge(merge(x,y),z);</span><br><span class="line">        &#125;else if(type==3)&#123;</span><br><span class="line">            split(root,a-1,x,y);</span><br><span class="line">            printf(&quot;%d\n&quot;,tr[x].sz+1);</span><br><span class="line">            root=merge(x,y);</span><br><span class="line">        &#125;else if(type==4) printf(&quot;%d\n&quot;,tr[rank(root,a)].val);</span><br><span class="line">        else if(type==5)&#123;</span><br><span class="line">            split(root,a-1,x,y);</span><br><span class="line">            printf(&quot;%d\n&quot;,tr[rank(x,tr[x].sz)].val);</span><br><span class="line">            root=merge(x,y);</span><br><span class="line">        &#125;else if(type==6)&#123;</span><br><span class="line">            split(root,a,x,y);</span><br><span class="line">            printf(&quot;%d\n&quot;,tr[rank(y,1)].val); </span><br><span class="line">            root=merge(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>当然，fhqtreap的应用不仅限于这些，还有许多，还待我继续学习。。。 参考：<a href="https://www.cnblogs.com/zwfymqz/p/7151959.html">zwfymqz</a><br><a href="https://blog.csdn.net/CABI_ZGX/article/details/79963427">mocha</a>从两位大佬的博文中窃取了许多。。。</p>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fhq treap </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂 学习笔记</title>
      <link href="/2019/02/14/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/14/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="举例1：Fibonacci"><a href="#举例1：Fibonacci" class="headerlink" title="举例1：Fibonacci"></a>举例1：Fibonacci</h2><h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://loj.ac/problem/10220">题目传送门</a></h3><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$$f[1]&#x3D;1,f[2]&#x3D;1,f[3]&#x3D;2,f[4]&#x3D;3 \dots f[n]&#x3D;f[n-1]+f[n-2]$$<br>那么输入$n$、$m$，求第n项Fibonacci的值$mod$ $m$，即$f[n]$ $mod$ $m$。<br>$$1\leq n \leq 2 \times 10^9$$<br>因为：$$f[i]&#x3D;1 \times f[i-1]+1 \times f[i-2]$$$$f[i-1]&#x3D;1\times f[i-1]+0 \times f[i-2]$$<br>所以，我们可以发现递推式可以转化为矩阵运算：<br>$$\left(\begin{array}{rcl}f[i]\\f[i-1]\end{array} \right) &#x3D; \left(\begin{array}{rcl}1 \quad 1\\1\quad 0\end{array} \right) \times \left(\begin{array}{rcl}f[i-1]\\f[i-2]\end{array} \right)&#x3D;\left(\begin{array}{rcl}1 \quad 1\\1\quad 0\end{array} \right)^2 \times \left(\begin{array}{rcl}f[i-2]\\f[i-3]\end{array} \right)$$<br>那么可得：<br>$$\left(\begin{array}{rcl}f[n]\\f[n-1]\end{array} \right)&#x3D;\left(\begin{array}{rcl}1 \quad 1\\1\quad 0\end{array} \right)^{n-2} \times \left(\begin{array}{rcl}f[2]\\f[1]\end{array} \right)$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll f[3][3];</span><br><span class="line">&#125;a,f,s;</span><br><span class="line">void build(node &amp;x)&#123;</span><br><span class="line">    for(ll i=0;i&lt;=1;i++)&#123;</span><br><span class="line">        for(ll j=0;j&lt;=1;j++)&#123;</span><br><span class="line">            if(i==j) x.f[i][j]=1;</span><br><span class="line">            else x.f[i][j]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Mul(node &amp;x,node &amp;y,node &amp;z)&#123;</span><br><span class="line">    memset(z.f,0,sizeof(z.f));</span><br><span class="line">    for(ll i=0;i&lt;=1;i++)&#123;</span><br><span class="line">        for(ll j=0;j&lt;=1;j++)&#123;</span><br><span class="line">            if(x.f[i][j]!=0)&#123;</span><br><span class="line">                for(ll k=0;k&lt;=1;k++)&#123;</span><br><span class="line">                    z.f[i][k]+=x.f[i][j]*y.f[j][k];</span><br><span class="line">                    z.f[i][k]%=m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">node Pow(ll b)&#123;</span><br><span class="line">    node res;</span><br><span class="line">    build(res);</span><br><span class="line">    node tmp=f,t;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b%2==1) Mul(res,tmp,t),res=t;</span><br><span class="line">        Mul(tmp,tmp,t),tmp=t,b&gt;&gt;=1; </span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    f.f[0][0]=1;f.f[1][0]=1;f.f[0][1]=1;f.f[1][1]=0;</span><br><span class="line">    node q=Pow(n-2);</span><br><span class="line">    write((q.f[0][0]+q.f[1][0]+m)%m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//(f[n]  )=(1 1)^(n-2)*(f[2])</span><br><span class="line">//(f[n-1])=(1 0)      *(f[1])</span><br></pre></td></tr></table></figure><h2 id="举例2：Fibonacci求和"><a href="#举例2：Fibonacci求和" class="headerlink" title="举例2：Fibonacci求和"></a>举例2：Fibonacci求和</h2><h3 id="题目传送门-1"><a href="#题目传送门-1" class="headerlink" title="题目传送门"></a><a href="https://loj.ac/problem/10221">题目传送门</a></h3><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>输入$n$、$m$，求出Fibonacci的前$n$项的和 $mod$ $m$的值，即：$f[n]\quad mod\quad m$<br>$$f[n]&#x3D;f[n-1]+f[n-2]$$<br>$$f[n-1]&#x3D;f[n-2]+f[n-3],f[n]&#x3D;2\times f[n-2]+f[n-3]$$<br>$$f[n-2]&#x3D;f[n-3]+f[n-4],f[n]&#x3D;f[n-2]+2\times f[n-3]+f[n-4]$$<br>$$f[n-3]&#x3D;f[n-4]+f[n-5],f[n]&#x3D;f[n-2]+f[n-3]+2\times f[n-4]+f[n-5]$$<br>以此类推，可得：<br>$$f[n]&#x3D;f[n-2]+f[n-3]+f[n-4]+f[n-5]+\dots f[2]+2 \times f[1]$$<br>那么：<br>$$f[n-2]+f[n-3]+f[n-4]+f[n-5]+\dots f[2]+f[1]&#x3D;f[n]-f[1]$$<br>$$f[n-2]+f[n-3]+f[n-4]+f[n-5]+\dots f[2]+f[1]&#x3D;f[n]-1$$<br>也就是：<br>$$f[n]+f[n-1]+f[n-2]+f[n-3]+\dots f[2]+f[1]&#x3D;f[n+2]-1$$<br>所以只需要将上题代码改一改就好了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">#include&lt;complex&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;exception&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;functional&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;ios&gt;</span><br><span class="line">#include&lt;iosfwd&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;istream&gt;</span><br><span class="line">#include&lt;iterator&gt;</span><br><span class="line">#include&lt;limits&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;locale&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;new&gt;</span><br><span class="line">#include&lt;numeric&gt;</span><br><span class="line">#include&lt;ostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;stdexcept&gt;</span><br><span class="line">#include&lt;streambuf&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;typeinfo&gt;</span><br><span class="line">#include&lt;utility&gt;</span><br><span class="line">#include&lt;valarray&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cerrno&gt;</span><br><span class="line">#include&lt;cfloat&gt;</span><br><span class="line">#include&lt;ciso646&gt;</span><br><span class="line">#include&lt;climits&gt;</span><br><span class="line">#include&lt;clocale&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;csetjmp&gt;</span><br><span class="line">#include&lt;csignal&gt;</span><br><span class="line">#include&lt;cstdarg&gt;</span><br><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;ctime&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">inline ll read()&#123;</span><br><span class="line">    ll res=0,f=1;char ch=getchar();</span><br><span class="line">    while(ch&lt;&#x27;0&#x27;ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125;</span><br><span class="line">    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) res=res*10+ch-&#x27;0&#x27;,ch=getchar();</span><br><span class="line">    return res*f;</span><br><span class="line">&#125;</span><br><span class="line">inline void write(ll x)&#123;</span><br><span class="line">    if(x&lt;0) putchar(&#x27;-&#x27;),x=-x;</span><br><span class="line">    if(x&lt;10) putchar(x+&#x27;0&#x27;);</span><br><span class="line">    else&#123;</span><br><span class="line">        write(x/10);</span><br><span class="line">        putchar(x%10+&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll f[3][3];</span><br><span class="line">&#125;a,f,s;</span><br><span class="line">void build(node &amp;x)&#123;</span><br><span class="line">    for(ll i=0;i&lt;=1;i++)&#123;</span><br><span class="line">        for(ll j=0;j&lt;=1;j++)&#123;</span><br><span class="line">            if(i==j) x.f[i][j]=1;</span><br><span class="line">            else x.f[i][j]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Mul(node &amp;x,node &amp;y,node &amp;z)&#123;</span><br><span class="line">    memset(z.f,0,sizeof(z.f));</span><br><span class="line">    for(ll i=0;i&lt;=1;i++)&#123;</span><br><span class="line">        for(ll j=0;j&lt;=1;j++)&#123;</span><br><span class="line">            if(x.f[i][j]!=0)&#123;</span><br><span class="line">                for(ll k=0;k&lt;=1;k++)&#123;</span><br><span class="line">                    z.f[i][k]+=x.f[i][j]*y.f[j][k];</span><br><span class="line">                    z.f[i][k]%=m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">node Pow(ll b)&#123;</span><br><span class="line">    node res;</span><br><span class="line">    build(res);</span><br><span class="line">    node tmp=f,t;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b%2==1) Mul(res,tmp,t),res=t;</span><br><span class="line">        Mul(tmp,tmp,t),tmp=t,b&gt;&gt;=1; </span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    n=read();m=read();</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    f.f[0][0]=1;f.f[1][0]=1;f.f[0][1]=1;f.f[1][1]=0;</span><br><span class="line">    node q=Pow(n);</span><br><span class="line">    write((q.f[0][0]+q.f[1][0]+m-1)%m);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> oi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
